// This file is generated by rust-protobuf 2.8.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `cdcpb.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_0;

#[derive(PartialEq,Clone,Default)]
pub struct Header {
    // message fields
    pub cluster_id: u64,
    pub ticdc_version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Header {
    fn default() -> &'a Header {
        <Header as ::protobuf::Message>::default_instance()
    }
}

impl Header {
    pub fn new() -> Header {
        ::std::default::Default::default()
    }

    // uint64 cluster_id = 1;


    pub fn get_cluster_id(&self) -> u64 {
        self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: u64) {
        self.cluster_id = v;
    }

    // string ticdc_version = 2;


    pub fn get_ticdc_version(&self) -> &str {
        &self.ticdc_version
    }
    pub fn clear_ticdc_version(&mut self) {
        self.ticdc_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticdc_version(&mut self, v: ::std::string::String) {
        self.ticdc_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticdc_version(&mut self) -> &mut ::std::string::String {
        &mut self.ticdc_version
    }

    // Take field
    pub fn take_ticdc_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ticdc_version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Header {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cluster_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ticdc_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cluster_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cluster_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ticdc_version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ticdc_version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.cluster_id != 0 {
            os.write_uint64(1, self.cluster_id)?;
        }
        if !self.ticdc_version.is_empty() {
            os.write_string(2, &self.ticdc_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Header {
        Header::new()
    }

    fn default_instance() -> &'static Header {
        static mut instance: ::protobuf::lazy::Lazy<Header> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Header,
        };
        unsafe {
            instance.get(Header::new)
        }
    }
}

impl ::protobuf::Clear for Header {
    fn clear(&mut self) {
        self.cluster_id = 0;
        self.ticdc_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for Header {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.cluster_id, "cluster_id", buf);
        ::protobuf::PbPrint::fmt(&self.ticdc_version, "ticdc_version", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for Header {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.cluster_id, "cluster_id", &mut s);
        ::protobuf::PbPrint::fmt(&self.ticdc_version, "ticdc_version", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for Header {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DuplicateRequest {
    // message fields
    pub region_id: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DuplicateRequest {
    fn default() -> &'a DuplicateRequest {
        <DuplicateRequest as ::protobuf::Message>::default_instance()
    }
}

impl DuplicateRequest {
    pub fn new() -> DuplicateRequest {
        ::std::default::Default::default()
    }

    // uint64 region_id = 1;


    pub fn get_region_id(&self) -> u64 {
        self.region_id
    }
    pub fn clear_region_id(&mut self) {
        self.region_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_region_id(&mut self, v: u64) {
        self.region_id = v;
    }
}

impl ::protobuf::Message for DuplicateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.region_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.region_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.region_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.region_id != 0 {
            os.write_uint64(1, self.region_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DuplicateRequest {
        DuplicateRequest::new()
    }

    fn default_instance() -> &'static DuplicateRequest {
        static mut instance: ::protobuf::lazy::Lazy<DuplicateRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DuplicateRequest,
        };
        unsafe {
            instance.get(DuplicateRequest::new)
        }
    }
}

impl ::protobuf::Clear for DuplicateRequest {
    fn clear(&mut self) {
        self.region_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for DuplicateRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_id, "region_id", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for DuplicateRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_id, "region_id", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for DuplicateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Compatibility {
    // message fields
    pub required_version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Compatibility {
    fn default() -> &'a Compatibility {
        <Compatibility as ::protobuf::Message>::default_instance()
    }
}

impl Compatibility {
    pub fn new() -> Compatibility {
        ::std::default::Default::default()
    }

    // string required_version = 1;


    pub fn get_required_version(&self) -> &str {
        &self.required_version
    }
    pub fn clear_required_version(&mut self) {
        self.required_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_required_version(&mut self, v: ::std::string::String) {
        self.required_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_required_version(&mut self) -> &mut ::std::string::String {
        &mut self.required_version
    }

    // Take field
    pub fn take_required_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.required_version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Compatibility {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.required_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.required_version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.required_version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.required_version.is_empty() {
            os.write_string(1, &self.required_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Compatibility {
        Compatibility::new()
    }

    fn default_instance() -> &'static Compatibility {
        static mut instance: ::protobuf::lazy::Lazy<Compatibility> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Compatibility,
        };
        unsafe {
            instance.get(Compatibility::new)
        }
    }
}

impl ::protobuf::Clear for Compatibility {
    fn clear(&mut self) {
        self.required_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for Compatibility {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.required_version, "required_version", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for Compatibility {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.required_version, "required_version", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for Compatibility {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClusterIdMismatch {
    // message fields
    pub current: u64,
    pub request: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClusterIdMismatch {
    fn default() -> &'a ClusterIdMismatch {
        <ClusterIdMismatch as ::protobuf::Message>::default_instance()
    }
}

impl ClusterIdMismatch {
    pub fn new() -> ClusterIdMismatch {
        ::std::default::Default::default()
    }

    // uint64 current = 1;


    pub fn get_current(&self) -> u64 {
        self.current
    }
    pub fn clear_current(&mut self) {
        self.current = 0;
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: u64) {
        self.current = v;
    }

    // uint64 request = 2;


    pub fn get_request(&self) -> u64 {
        self.request
    }
    pub fn clear_request(&mut self) {
        self.request = 0;
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: u64) {
        self.request = v;
    }
}

impl ::protobuf::Message for ClusterIdMismatch {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.current = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.current != 0 {
            my_size += ::protobuf::rt::value_size(1, self.current, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.request != 0 {
            my_size += ::protobuf::rt::value_size(2, self.request, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.current != 0 {
            os.write_uint64(1, self.current)?;
        }
        if self.request != 0 {
            os.write_uint64(2, self.request)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClusterIdMismatch {
        ClusterIdMismatch::new()
    }

    fn default_instance() -> &'static ClusterIdMismatch {
        static mut instance: ::protobuf::lazy::Lazy<ClusterIdMismatch> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClusterIdMismatch,
        };
        unsafe {
            instance.get(ClusterIdMismatch::new)
        }
    }
}

impl ::protobuf::Clear for ClusterIdMismatch {
    fn clear(&mut self) {
        self.current = 0;
        self.request = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ClusterIdMismatch {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.current, "current", buf);
        ::protobuf::PbPrint::fmt(&self.request, "request", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ClusterIdMismatch {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.current, "current", &mut s);
        ::protobuf::PbPrint::fmt(&self.request, "request", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClusterIdMismatch {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Error {
    // message fields
    pub not_leader: ::protobuf::SingularPtrField<super::errorpb::NotLeader>,
    pub region_not_found: ::protobuf::SingularPtrField<super::errorpb::RegionNotFound>,
    pub epoch_not_match: ::protobuf::SingularPtrField<super::errorpb::EpochNotMatch>,
    pub duplicate_request: ::protobuf::SingularPtrField<DuplicateRequest>,
    pub compatibility: ::protobuf::SingularPtrField<Compatibility>,
    pub cluster_id_mismatch: ::protobuf::SingularPtrField<ClusterIdMismatch>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Error {
    fn default() -> &'a Error {
        <Error as ::protobuf::Message>::default_instance()
    }
}

impl Error {
    pub fn new() -> Error {
        ::std::default::Default::default()
    }

    // .errorpb.NotLeader not_leader = 1;


    pub fn get_not_leader(&self) -> &super::errorpb::NotLeader {
        self.not_leader.as_ref().unwrap_or_else(|| super::errorpb::NotLeader::default_instance())
    }
    pub fn clear_not_leader(&mut self) {
        self.not_leader.clear();
    }

    pub fn has_not_leader(&self) -> bool {
        self.not_leader.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not_leader(&mut self, v: super::errorpb::NotLeader) {
        self.not_leader = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_not_leader(&mut self) -> &mut super::errorpb::NotLeader {
        if self.not_leader.is_none() {
            self.not_leader.set_default();
        }
        self.not_leader.as_mut().unwrap()
    }

    // Take field
    pub fn take_not_leader(&mut self) -> super::errorpb::NotLeader {
        self.not_leader.take().unwrap_or_else(|| super::errorpb::NotLeader::new())
    }

    // .errorpb.RegionNotFound region_not_found = 2;


    pub fn get_region_not_found(&self) -> &super::errorpb::RegionNotFound {
        self.region_not_found.as_ref().unwrap_or_else(|| super::errorpb::RegionNotFound::default_instance())
    }
    pub fn clear_region_not_found(&mut self) {
        self.region_not_found.clear();
    }

    pub fn has_region_not_found(&self) -> bool {
        self.region_not_found.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_not_found(&mut self, v: super::errorpb::RegionNotFound) {
        self.region_not_found = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_not_found(&mut self) -> &mut super::errorpb::RegionNotFound {
        if self.region_not_found.is_none() {
            self.region_not_found.set_default();
        }
        self.region_not_found.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_not_found(&mut self) -> super::errorpb::RegionNotFound {
        self.region_not_found.take().unwrap_or_else(|| super::errorpb::RegionNotFound::new())
    }

    // .errorpb.EpochNotMatch epoch_not_match = 3;


    pub fn get_epoch_not_match(&self) -> &super::errorpb::EpochNotMatch {
        self.epoch_not_match.as_ref().unwrap_or_else(|| super::errorpb::EpochNotMatch::default_instance())
    }
    pub fn clear_epoch_not_match(&mut self) {
        self.epoch_not_match.clear();
    }

    pub fn has_epoch_not_match(&self) -> bool {
        self.epoch_not_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_epoch_not_match(&mut self, v: super::errorpb::EpochNotMatch) {
        self.epoch_not_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_epoch_not_match(&mut self) -> &mut super::errorpb::EpochNotMatch {
        if self.epoch_not_match.is_none() {
            self.epoch_not_match.set_default();
        }
        self.epoch_not_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_epoch_not_match(&mut self) -> super::errorpb::EpochNotMatch {
        self.epoch_not_match.take().unwrap_or_else(|| super::errorpb::EpochNotMatch::new())
    }

    // .cdcpb.DuplicateRequest duplicate_request = 4;


    pub fn get_duplicate_request(&self) -> &DuplicateRequest {
        self.duplicate_request.as_ref().unwrap_or_else(|| DuplicateRequest::default_instance())
    }
    pub fn clear_duplicate_request(&mut self) {
        self.duplicate_request.clear();
    }

    pub fn has_duplicate_request(&self) -> bool {
        self.duplicate_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duplicate_request(&mut self, v: DuplicateRequest) {
        self.duplicate_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duplicate_request(&mut self) -> &mut DuplicateRequest {
        if self.duplicate_request.is_none() {
            self.duplicate_request.set_default();
        }
        self.duplicate_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_duplicate_request(&mut self) -> DuplicateRequest {
        self.duplicate_request.take().unwrap_or_else(|| DuplicateRequest::new())
    }

    // .cdcpb.Compatibility compatibility = 5;


    pub fn get_compatibility(&self) -> &Compatibility {
        self.compatibility.as_ref().unwrap_or_else(|| Compatibility::default_instance())
    }
    pub fn clear_compatibility(&mut self) {
        self.compatibility.clear();
    }

    pub fn has_compatibility(&self) -> bool {
        self.compatibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compatibility(&mut self, v: Compatibility) {
        self.compatibility = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compatibility(&mut self) -> &mut Compatibility {
        if self.compatibility.is_none() {
            self.compatibility.set_default();
        }
        self.compatibility.as_mut().unwrap()
    }

    // Take field
    pub fn take_compatibility(&mut self) -> Compatibility {
        self.compatibility.take().unwrap_or_else(|| Compatibility::new())
    }

    // .cdcpb.ClusterIDMismatch cluster_id_mismatch = 6;


    pub fn get_cluster_id_mismatch(&self) -> &ClusterIdMismatch {
        self.cluster_id_mismatch.as_ref().unwrap_or_else(|| ClusterIdMismatch::default_instance())
    }
    pub fn clear_cluster_id_mismatch(&mut self) {
        self.cluster_id_mismatch.clear();
    }

    pub fn has_cluster_id_mismatch(&self) -> bool {
        self.cluster_id_mismatch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster_id_mismatch(&mut self, v: ClusterIdMismatch) {
        self.cluster_id_mismatch = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id_mismatch(&mut self) -> &mut ClusterIdMismatch {
        if self.cluster_id_mismatch.is_none() {
            self.cluster_id_mismatch.set_default();
        }
        self.cluster_id_mismatch.as_mut().unwrap()
    }

    // Take field
    pub fn take_cluster_id_mismatch(&mut self) -> ClusterIdMismatch {
        self.cluster_id_mismatch.take().unwrap_or_else(|| ClusterIdMismatch::new())
    }
}

impl ::protobuf::Message for Error {
    fn is_initialized(&self) -> bool {
        for v in &self.not_leader {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.region_not_found {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.epoch_not_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.duplicate_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.compatibility {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cluster_id_mismatch {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.not_leader)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_not_found)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.epoch_not_match)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.duplicate_request)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.compatibility)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cluster_id_mismatch)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.not_leader.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.region_not_found.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.epoch_not_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.duplicate_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.compatibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cluster_id_mismatch.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.not_leader.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.region_not_found.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.epoch_not_match.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.duplicate_request.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.compatibility.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cluster_id_mismatch.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Error {
        Error::new()
    }

    fn default_instance() -> &'static Error {
        static mut instance: ::protobuf::lazy::Lazy<Error> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Error,
        };
        unsafe {
            instance.get(Error::new)
        }
    }
}

impl ::protobuf::Clear for Error {
    fn clear(&mut self) {
        self.not_leader.clear();
        self.region_not_found.clear();
        self.epoch_not_match.clear();
        self.duplicate_request.clear();
        self.compatibility.clear();
        self.cluster_id_mismatch.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for Error {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.not_leader, "not_leader", buf);
        ::protobuf::PbPrint::fmt(&self.region_not_found, "region_not_found", buf);
        ::protobuf::PbPrint::fmt(&self.epoch_not_match, "epoch_not_match", buf);
        ::protobuf::PbPrint::fmt(&self.duplicate_request, "duplicate_request", buf);
        ::protobuf::PbPrint::fmt(&self.compatibility, "compatibility", buf);
        ::protobuf::PbPrint::fmt(&self.cluster_id_mismatch, "cluster_id_mismatch", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for Error {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.not_leader, "not_leader", &mut s);
        ::protobuf::PbPrint::fmt(&self.region_not_found, "region_not_found", &mut s);
        ::protobuf::PbPrint::fmt(&self.epoch_not_match, "epoch_not_match", &mut s);
        ::protobuf::PbPrint::fmt(&self.duplicate_request, "duplicate_request", &mut s);
        ::protobuf::PbPrint::fmt(&self.compatibility, "compatibility", &mut s);
        ::protobuf::PbPrint::fmt(&self.cluster_id_mismatch, "cluster_id_mismatch", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for Error {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TxnInfo {
    // message fields
    pub start_ts: u64,
    pub primary: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxnInfo {
    fn default() -> &'a TxnInfo {
        <TxnInfo as ::protobuf::Message>::default_instance()
    }
}

impl TxnInfo {
    pub fn new() -> TxnInfo {
        ::std::default::Default::default()
    }

    // uint64 start_ts = 1;


    pub fn get_start_ts(&self) -> u64 {
        self.start_ts
    }
    pub fn clear_start_ts(&mut self) {
        self.start_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_ts(&mut self, v: u64) {
        self.start_ts = v;
    }

    // bytes primary = 2;


    pub fn get_primary(&self) -> &[u8] {
        &self.primary
    }
    pub fn clear_primary(&mut self) {
        self.primary.clear();
    }

    // Param is passed by value, moved
    pub fn set_primary(&mut self, v: ::std::vec::Vec<u8>) {
        self.primary = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.primary
    }

    // Take field
    pub fn take_primary(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.primary, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TxnInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_ts = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.primary)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_ts != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.primary.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.primary);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.start_ts != 0 {
            os.write_uint64(1, self.start_ts)?;
        }
        if !self.primary.is_empty() {
            os.write_bytes(2, &self.primary)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxnInfo {
        TxnInfo::new()
    }

    fn default_instance() -> &'static TxnInfo {
        static mut instance: ::protobuf::lazy::Lazy<TxnInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TxnInfo,
        };
        unsafe {
            instance.get(TxnInfo::new)
        }
    }
}

impl ::protobuf::Clear for TxnInfo {
    fn clear(&mut self) {
        self.start_ts = 0;
        self.primary.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for TxnInfo {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", buf);
        ::protobuf::PbPrint::fmt(&self.primary, "primary", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for TxnInfo {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.primary, "primary", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxnInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TxnStatus {
    // message fields
    pub start_ts: u64,
    pub min_commit_ts: u64,
    pub commit_ts: u64,
    pub is_rolled_back: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxnStatus {
    fn default() -> &'a TxnStatus {
        <TxnStatus as ::protobuf::Message>::default_instance()
    }
}

impl TxnStatus {
    pub fn new() -> TxnStatus {
        ::std::default::Default::default()
    }

    // uint64 start_ts = 1;


    pub fn get_start_ts(&self) -> u64 {
        self.start_ts
    }
    pub fn clear_start_ts(&mut self) {
        self.start_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_ts(&mut self, v: u64) {
        self.start_ts = v;
    }

    // uint64 min_commit_ts = 2;


    pub fn get_min_commit_ts(&self) -> u64 {
        self.min_commit_ts
    }
    pub fn clear_min_commit_ts(&mut self) {
        self.min_commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_commit_ts(&mut self, v: u64) {
        self.min_commit_ts = v;
    }

    // uint64 commit_ts = 3;


    pub fn get_commit_ts(&self) -> u64 {
        self.commit_ts
    }
    pub fn clear_commit_ts(&mut self) {
        self.commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_ts(&mut self, v: u64) {
        self.commit_ts = v;
    }

    // bool is_rolled_back = 4;


    pub fn get_is_rolled_back(&self) -> bool {
        self.is_rolled_back
    }
    pub fn clear_is_rolled_back(&mut self) {
        self.is_rolled_back = false;
    }

    // Param is passed by value, moved
    pub fn set_is_rolled_back(&mut self, v: bool) {
        self.is_rolled_back = v;
    }
}

impl ::protobuf::Message for TxnStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_ts = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.min_commit_ts = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commit_ts = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_rolled_back = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_ts != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.min_commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(3, self.commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_rolled_back != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.start_ts != 0 {
            os.write_uint64(1, self.start_ts)?;
        }
        if self.min_commit_ts != 0 {
            os.write_uint64(2, self.min_commit_ts)?;
        }
        if self.commit_ts != 0 {
            os.write_uint64(3, self.commit_ts)?;
        }
        if self.is_rolled_back != false {
            os.write_bool(4, self.is_rolled_back)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxnStatus {
        TxnStatus::new()
    }

    fn default_instance() -> &'static TxnStatus {
        static mut instance: ::protobuf::lazy::Lazy<TxnStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TxnStatus,
        };
        unsafe {
            instance.get(TxnStatus::new)
        }
    }
}

impl ::protobuf::Clear for TxnStatus {
    fn clear(&mut self) {
        self.start_ts = 0;
        self.min_commit_ts = 0;
        self.commit_ts = 0;
        self.is_rolled_back = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for TxnStatus {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", buf);
        ::protobuf::PbPrint::fmt(&self.min_commit_ts, "min_commit_ts", buf);
        ::protobuf::PbPrint::fmt(&self.commit_ts, "commit_ts", buf);
        ::protobuf::PbPrint::fmt(&self.is_rolled_back, "is_rolled_back", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for TxnStatus {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.min_commit_ts, "min_commit_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.commit_ts, "commit_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.is_rolled_back, "is_rolled_back", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxnStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Event {
    // message fields
    pub region_id: u64,
    pub index: u64,
    pub request_id: u64,
    // message oneof groups
    pub event: ::std::option::Option<Event_oneof_event>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Event {
    fn default() -> &'a Event {
        <Event as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq)]
pub enum Event_oneof_event {
    Entries(EventEntries),
    Admin(EventAdmin),
    Error(Error),
    ResolvedTs(u64),
    LongTxn(EventLongTxn),
}

impl ::protobuf::PbPrint for Event_oneof_event {
    fn fmt(&self, name: &str, buf: &mut String) {
        match self {
            Event_oneof_event::Entries(v) => ::protobuf::PbPrint::fmt(v, name, buf),
            Event_oneof_event::Admin(v) => ::protobuf::PbPrint::fmt(v, name, buf),
            Event_oneof_event::Error(v) => ::protobuf::PbPrint::fmt(v, name, buf),
            Event_oneof_event::ResolvedTs(v) => ::protobuf::PbPrint::fmt(v, name, buf),
            Event_oneof_event::LongTxn(v) => ::protobuf::PbPrint::fmt(v, name, buf),
        }
    }
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    // uint64 region_id = 1;


    pub fn get_region_id(&self) -> u64 {
        self.region_id
    }
    pub fn clear_region_id(&mut self) {
        self.region_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_region_id(&mut self, v: u64) {
        self.region_id = v;
    }

    // uint64 index = 2;


    pub fn get_index(&self) -> u64 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u64) {
        self.index = v;
    }

    // uint64 request_id = 7;


    pub fn get_request_id(&self) -> u64 {
        self.request_id
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = v;
    }

    // .cdcpb.Event.Entries entries = 3;


    pub fn get_entries(&self) -> &EventEntries {
        match self.event {
            ::std::option::Option::Some(Event_oneof_event::Entries(ref v)) => v,
            _ => EventEntries::default_instance(),
        }
    }
    pub fn clear_entries(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_entries(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(Event_oneof_event::Entries(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: EventEntries) {
        self.event = ::std::option::Option::Some(Event_oneof_event::Entries(v))
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut EventEntries {
        if let ::std::option::Option::Some(Event_oneof_event::Entries(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(Event_oneof_event::Entries(EventEntries::new()));
        }
        match self.event {
            ::std::option::Option::Some(Event_oneof_event::Entries(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_entries(&mut self) -> EventEntries {
        if self.has_entries() {
            match self.event.take() {
                ::std::option::Option::Some(Event_oneof_event::Entries(v)) => v,
                _ => panic!(),
            }
        } else {
            EventEntries::new()
        }
    }

    // .cdcpb.Event.Admin admin = 4;


    pub fn get_admin(&self) -> &EventAdmin {
        match self.event {
            ::std::option::Option::Some(Event_oneof_event::Admin(ref v)) => v,
            _ => EventAdmin::default_instance(),
        }
    }
    pub fn clear_admin(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_admin(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(Event_oneof_event::Admin(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_admin(&mut self, v: EventAdmin) {
        self.event = ::std::option::Option::Some(Event_oneof_event::Admin(v))
    }

    // Mutable pointer to the field.
    pub fn mut_admin(&mut self) -> &mut EventAdmin {
        if let ::std::option::Option::Some(Event_oneof_event::Admin(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(Event_oneof_event::Admin(EventAdmin::new()));
        }
        match self.event {
            ::std::option::Option::Some(Event_oneof_event::Admin(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_admin(&mut self) -> EventAdmin {
        if self.has_admin() {
            match self.event.take() {
                ::std::option::Option::Some(Event_oneof_event::Admin(v)) => v,
                _ => panic!(),
            }
        } else {
            EventAdmin::new()
        }
    }

    // .cdcpb.Error error = 5;


    pub fn get_error(&self) -> &Error {
        match self.event {
            ::std::option::Option::Some(Event_oneof_event::Error(ref v)) => v,
            _ => Error::default_instance(),
        }
    }
    pub fn clear_error(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(Event_oneof_event::Error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: Error) {
        self.event = ::std::option::Option::Some(Event_oneof_event::Error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut Error {
        if let ::std::option::Option::Some(Event_oneof_event::Error(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(Event_oneof_event::Error(Error::new()));
        }
        match self.event {
            ::std::option::Option::Some(Event_oneof_event::Error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> Error {
        if self.has_error() {
            match self.event.take() {
                ::std::option::Option::Some(Event_oneof_event::Error(v)) => v,
                _ => panic!(),
            }
        } else {
            Error::new()
        }
    }

    // uint64 resolved_ts = 6;


    pub fn get_resolved_ts(&self) -> u64 {
        match self.event {
            ::std::option::Option::Some(Event_oneof_event::ResolvedTs(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_resolved_ts(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_resolved_ts(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(Event_oneof_event::ResolvedTs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_resolved_ts(&mut self, v: u64) {
        self.event = ::std::option::Option::Some(Event_oneof_event::ResolvedTs(v))
    }

    // .cdcpb.Event.LongTxn long_txn = 8;


    pub fn get_long_txn(&self) -> &EventLongTxn {
        match self.event {
            ::std::option::Option::Some(Event_oneof_event::LongTxn(ref v)) => v,
            _ => EventLongTxn::default_instance(),
        }
    }
    pub fn clear_long_txn(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_long_txn(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(Event_oneof_event::LongTxn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_long_txn(&mut self, v: EventLongTxn) {
        self.event = ::std::option::Option::Some(Event_oneof_event::LongTxn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_long_txn(&mut self) -> &mut EventLongTxn {
        if let ::std::option::Option::Some(Event_oneof_event::LongTxn(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(Event_oneof_event::LongTxn(EventLongTxn::new()));
        }
        match self.event {
            ::std::option::Option::Some(Event_oneof_event::LongTxn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_long_txn(&mut self) -> EventLongTxn {
        if self.has_long_txn() {
            match self.event.take() {
                ::std::option::Option::Some(Event_oneof_event::LongTxn(v)) => v,
                _ => panic!(),
            }
        } else {
            EventLongTxn::new()
        }
    }
}

impl ::protobuf::Message for Event {
    fn is_initialized(&self) -> bool {
        if let Some(Event_oneof_event::Entries(ref v)) = self.event {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Event_oneof_event::Admin(ref v)) = self.event {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Event_oneof_event::Error(ref v)) = self.event {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Event_oneof_event::LongTxn(ref v)) = self.event {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.region_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.index = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.event = ::std::option::Option::Some(Event_oneof_event::Entries(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.event = ::std::option::Option::Some(Event_oneof_event::Admin(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.event = ::std::option::Option::Some(Event_oneof_event::Error(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.event = ::std::option::Option::Some(Event_oneof_event::ResolvedTs(is.read_uint64()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.event = ::std::option::Option::Some(Event_oneof_event::LongTxn(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.region_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.region_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.request_id != 0 {
            my_size += ::protobuf::rt::value_size(7, self.request_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.event {
            match v {
                &Event_oneof_event::Entries(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Event_oneof_event::Admin(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Event_oneof_event::Error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Event_oneof_event::ResolvedTs(v) => {
                    my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Event_oneof_event::LongTxn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.region_id != 0 {
            os.write_uint64(1, self.region_id)?;
        }
        if self.index != 0 {
            os.write_uint64(2, self.index)?;
        }
        if self.request_id != 0 {
            os.write_uint64(7, self.request_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.event {
            match v {
                &Event_oneof_event::Entries(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Event_oneof_event::Admin(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Event_oneof_event::Error(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Event_oneof_event::ResolvedTs(v) => {
                    os.write_uint64(6, v)?;
                },
                &Event_oneof_event::LongTxn(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Event {
        Event::new()
    }

    fn default_instance() -> &'static Event {
        static mut instance: ::protobuf::lazy::Lazy<Event> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Event,
        };
        unsafe {
            instance.get(Event::new)
        }
    }
}

impl ::protobuf::Clear for Event {
    fn clear(&mut self) {
        self.region_id = 0;
        self.index = 0;
        self.request_id = 0;
        self.event = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for Event {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_id, "region_id", buf);
        ::protobuf::PbPrint::fmt(&self.index, "index", buf);
        ::protobuf::PbPrint::fmt(&self.request_id, "request_id", buf);
        ::protobuf::PbPrint::fmt(&self.event, "event", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for Event {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_id, "region_id", &mut s);
        ::protobuf::PbPrint::fmt(&self.index, "index", &mut s);
        ::protobuf::PbPrint::fmt(&self.request_id, "request_id", &mut s);
        ::protobuf::PbPrint::fmt(&self.event, "event", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventRow {
    // message fields
    pub start_ts: u64,
    pub commit_ts: u64,
    pub r_type: EventLogType,
    pub op_type: EventRowOpType,
    pub key: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub old_value: ::std::vec::Vec<u8>,
    pub expire_ts_unix_secs: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventRow {
    fn default() -> &'a EventRow {
        <EventRow as ::protobuf::Message>::default_instance()
    }
}

impl EventRow {
    pub fn new() -> EventRow {
        ::std::default::Default::default()
    }

    // uint64 start_ts = 1;


    pub fn get_start_ts(&self) -> u64 {
        self.start_ts
    }
    pub fn clear_start_ts(&mut self) {
        self.start_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_ts(&mut self, v: u64) {
        self.start_ts = v;
    }

    // uint64 commit_ts = 2;


    pub fn get_commit_ts(&self) -> u64 {
        self.commit_ts
    }
    pub fn clear_commit_ts(&mut self) {
        self.commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_ts(&mut self, v: u64) {
        self.commit_ts = v;
    }

    // .cdcpb.Event.LogType type = 3;


    pub fn get_type(&self) -> EventLogType {
        self.r_type
    }
    pub fn clear_type(&mut self) {
        self.r_type = EventLogType::Unknown;
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: EventLogType) {
        self.r_type = v;
    }

    // .cdcpb.Event.Row.OpType op_type = 4;


    pub fn get_op_type(&self) -> EventRowOpType {
        self.op_type
    }
    pub fn clear_op_type(&mut self) {
        self.op_type = EventRowOpType::Unknown;
    }

    // Param is passed by value, moved
    pub fn set_op_type(&mut self, v: EventRowOpType) {
        self.op_type = v;
    }

    // bytes key = 5;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes value = 6;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // bytes old_value = 7;


    pub fn get_old_value(&self) -> &[u8] {
        &self.old_value
    }
    pub fn clear_old_value(&mut self) {
        self.old_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_old_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.old_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_old_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.old_value
    }

    // Take field
    pub fn take_old_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.old_value, ::std::vec::Vec::new())
    }

    // uint64 expire_ts_unix_secs = 8;


    pub fn get_expire_ts_unix_secs(&self) -> u64 {
        self.expire_ts_unix_secs
    }
    pub fn clear_expire_ts_unix_secs(&mut self) {
        self.expire_ts_unix_secs = 0;
    }

    // Param is passed by value, moved
    pub fn set_expire_ts_unix_secs(&mut self, v: u64) {
        self.expire_ts_unix_secs = v;
    }
}

impl ::protobuf::Message for EventRow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_ts = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commit_ts = tmp;
                },
                3 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.r_type = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                4 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.op_type = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.old_value)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.expire_ts_unix_secs = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_ts != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.r_type != EventLogType::Unknown {
            my_size += ::protobuf::rt::enum_size(3, self.r_type);
        }
        if self.op_type != EventRowOpType::Unknown {
            my_size += ::protobuf::rt::enum_size(4, self.op_type);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.value);
        }
        if !self.old_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.old_value);
        }
        if self.expire_ts_unix_secs != 0 {
            my_size += ::protobuf::rt::value_size(8, self.expire_ts_unix_secs, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.start_ts != 0 {
            os.write_uint64(1, self.start_ts)?;
        }
        if self.commit_ts != 0 {
            os.write_uint64(2, self.commit_ts)?;
        }
        if self.r_type != EventLogType::Unknown {
            os.write_enum(3, self.r_type.value())?;
        }
        if self.op_type != EventRowOpType::Unknown {
            os.write_enum(4, self.op_type.value())?;
        }
        if !self.key.is_empty() {
            os.write_bytes(5, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(6, &self.value)?;
        }
        if !self.old_value.is_empty() {
            os.write_bytes(7, &self.old_value)?;
        }
        if self.expire_ts_unix_secs != 0 {
            os.write_uint64(8, self.expire_ts_unix_secs)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventRow {
        EventRow::new()
    }

    fn default_instance() -> &'static EventRow {
        static mut instance: ::protobuf::lazy::Lazy<EventRow> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EventRow,
        };
        unsafe {
            instance.get(EventRow::new)
        }
    }
}

impl ::protobuf::Clear for EventRow {
    fn clear(&mut self) {
        self.start_ts = 0;
        self.commit_ts = 0;
        self.r_type = EventLogType::Unknown;
        self.op_type = EventRowOpType::Unknown;
        self.key.clear();
        self.value.clear();
        self.old_value.clear();
        self.expire_ts_unix_secs = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for EventRow {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", buf);
        ::protobuf::PbPrint::fmt(&self.commit_ts, "commit_ts", buf);
        ::protobuf::PbPrint::fmt(&self.r_type, "r_type", buf);
        ::protobuf::PbPrint::fmt(&self.op_type, "op_type", buf);
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        ::protobuf::PbPrint::fmt(&self.value, "value", buf);
        ::protobuf::PbPrint::fmt(&self.old_value, "old_value", buf);
        ::protobuf::PbPrint::fmt(&self.expire_ts_unix_secs, "expire_ts_unix_secs", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for EventRow {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.commit_ts, "commit_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.r_type, "r_type", &mut s);
        ::protobuf::PbPrint::fmt(&self.op_type, "op_type", &mut s);
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        ::protobuf::PbPrint::fmt(&self.value, "value", &mut s);
        ::protobuf::PbPrint::fmt(&self.old_value, "old_value", &mut s);
        ::protobuf::PbPrint::fmt(&self.expire_ts_unix_secs, "expire_ts_unix_secs", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventRow {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EventRowOpType {
    Unknown = 0,
    Put = 1,
    Delete = 2,
}

impl ::protobuf::ProtobufEnum for EventRowOpType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EventRowOpType> {
        match value {
            0 => ::std::option::Option::Some(EventRowOpType::Unknown),
            1 => ::std::option::Option::Some(EventRowOpType::Put),
            2 => ::std::option::Option::Some(EventRowOpType::Delete),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EventRowOpType] = &[
            EventRowOpType::Unknown,
            EventRowOpType::Put,
            EventRowOpType::Delete,
        ];
        values
    }
}

impl ::std::marker::Copy for EventRowOpType {
}

impl ::protobuf::PbPrint for EventRowOpType {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == EventRowOpType::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for EventRowOpType {
    fn default() -> Self {
        EventRowOpType::Unknown
    }
}

impl ::protobuf::reflect::ProtobufValue for EventRowOpType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventEntries {
    // message fields
    pub entries: ::protobuf::RepeatedField<EventRow>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventEntries {
    fn default() -> &'a EventEntries {
        <EventEntries as ::protobuf::Message>::default_instance()
    }
}

impl EventEntries {
    pub fn new() -> EventEntries {
        ::std::default::Default::default()
    }

    // repeated .cdcpb.Event.Row entries = 1;


    pub fn get_entries(&self) -> &[EventRow] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<EventRow>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<EventRow> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<EventRow> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EventEntries {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventEntries {
        EventEntries::new()
    }

    fn default_instance() -> &'static EventEntries {
        static mut instance: ::protobuf::lazy::Lazy<EventEntries> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EventEntries,
        };
        unsafe {
            instance.get(EventEntries::new)
        }
    }
}

impl ::protobuf::Clear for EventEntries {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for EventEntries {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.entries, "entries", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for EventEntries {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.entries, "entries", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventEntries {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventAdmin {
    // message fields
    pub admin_request: ::protobuf::SingularPtrField<super::raft_cmdpb::AdminRequest>,
    pub admin_response: ::protobuf::SingularPtrField<super::raft_cmdpb::AdminResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventAdmin {
    fn default() -> &'a EventAdmin {
        <EventAdmin as ::protobuf::Message>::default_instance()
    }
}

impl EventAdmin {
    pub fn new() -> EventAdmin {
        ::std::default::Default::default()
    }

    // .raft_cmdpb.AdminRequest admin_request = 1;


    pub fn get_admin_request(&self) -> &super::raft_cmdpb::AdminRequest {
        self.admin_request.as_ref().unwrap_or_else(|| super::raft_cmdpb::AdminRequest::default_instance())
    }
    pub fn clear_admin_request(&mut self) {
        self.admin_request.clear();
    }

    pub fn has_admin_request(&self) -> bool {
        self.admin_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_admin_request(&mut self, v: super::raft_cmdpb::AdminRequest) {
        self.admin_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_admin_request(&mut self) -> &mut super::raft_cmdpb::AdminRequest {
        if self.admin_request.is_none() {
            self.admin_request.set_default();
        }
        self.admin_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_admin_request(&mut self) -> super::raft_cmdpb::AdminRequest {
        self.admin_request.take().unwrap_or_else(|| super::raft_cmdpb::AdminRequest::new())
    }

    // .raft_cmdpb.AdminResponse admin_response = 2;


    pub fn get_admin_response(&self) -> &super::raft_cmdpb::AdminResponse {
        self.admin_response.as_ref().unwrap_or_else(|| super::raft_cmdpb::AdminResponse::default_instance())
    }
    pub fn clear_admin_response(&mut self) {
        self.admin_response.clear();
    }

    pub fn has_admin_response(&self) -> bool {
        self.admin_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_admin_response(&mut self, v: super::raft_cmdpb::AdminResponse) {
        self.admin_response = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_admin_response(&mut self) -> &mut super::raft_cmdpb::AdminResponse {
        if self.admin_response.is_none() {
            self.admin_response.set_default();
        }
        self.admin_response.as_mut().unwrap()
    }

    // Take field
    pub fn take_admin_response(&mut self) -> super::raft_cmdpb::AdminResponse {
        self.admin_response.take().unwrap_or_else(|| super::raft_cmdpb::AdminResponse::new())
    }
}

impl ::protobuf::Message for EventAdmin {
    fn is_initialized(&self) -> bool {
        for v in &self.admin_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.admin_response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.admin_request)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.admin_response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.admin_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.admin_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.admin_request.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.admin_response.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventAdmin {
        EventAdmin::new()
    }

    fn default_instance() -> &'static EventAdmin {
        static mut instance: ::protobuf::lazy::Lazy<EventAdmin> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EventAdmin,
        };
        unsafe {
            instance.get(EventAdmin::new)
        }
    }
}

impl ::protobuf::Clear for EventAdmin {
    fn clear(&mut self) {
        self.admin_request.clear();
        self.admin_response.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for EventAdmin {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.admin_request, "admin_request", buf);
        ::protobuf::PbPrint::fmt(&self.admin_response, "admin_response", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for EventAdmin {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.admin_request, "admin_request", &mut s);
        ::protobuf::PbPrint::fmt(&self.admin_response, "admin_response", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventAdmin {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventLongTxn {
    // message fields
    pub txn_info: ::protobuf::RepeatedField<TxnInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventLongTxn {
    fn default() -> &'a EventLongTxn {
        <EventLongTxn as ::protobuf::Message>::default_instance()
    }
}

impl EventLongTxn {
    pub fn new() -> EventLongTxn {
        ::std::default::Default::default()
    }

    // repeated .cdcpb.TxnInfo txn_info = 1;


    pub fn get_txn_info(&self) -> &[TxnInfo] {
        &self.txn_info
    }
    pub fn clear_txn_info(&mut self) {
        self.txn_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_txn_info(&mut self, v: ::protobuf::RepeatedField<TxnInfo>) {
        self.txn_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_txn_info(&mut self) -> &mut ::protobuf::RepeatedField<TxnInfo> {
        &mut self.txn_info
    }

    // Take field
    pub fn take_txn_info(&mut self) -> ::protobuf::RepeatedField<TxnInfo> {
        ::std::mem::replace(&mut self.txn_info, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EventLongTxn {
    fn is_initialized(&self) -> bool {
        for v in &self.txn_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.txn_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.txn_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.txn_info {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventLongTxn {
        EventLongTxn::new()
    }

    fn default_instance() -> &'static EventLongTxn {
        static mut instance: ::protobuf::lazy::Lazy<EventLongTxn> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EventLongTxn,
        };
        unsafe {
            instance.get(EventLongTxn::new)
        }
    }
}

impl ::protobuf::Clear for EventLongTxn {
    fn clear(&mut self) {
        self.txn_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for EventLongTxn {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.txn_info, "txn_info", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for EventLongTxn {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.txn_info, "txn_info", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventLongTxn {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EventLogType {
    Unknown = 0,
    Prewrite = 1,
    Commit = 2,
    Rollback = 3,
    Committed = 4,
    Initialized = 5,
}

impl ::protobuf::ProtobufEnum for EventLogType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EventLogType> {
        match value {
            0 => ::std::option::Option::Some(EventLogType::Unknown),
            1 => ::std::option::Option::Some(EventLogType::Prewrite),
            2 => ::std::option::Option::Some(EventLogType::Commit),
            3 => ::std::option::Option::Some(EventLogType::Rollback),
            4 => ::std::option::Option::Some(EventLogType::Committed),
            5 => ::std::option::Option::Some(EventLogType::Initialized),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EventLogType] = &[
            EventLogType::Unknown,
            EventLogType::Prewrite,
            EventLogType::Commit,
            EventLogType::Rollback,
            EventLogType::Committed,
            EventLogType::Initialized,
        ];
        values
    }
}

impl ::std::marker::Copy for EventLogType {
}

impl ::protobuf::PbPrint for EventLogType {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == EventLogType::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for EventLogType {
    fn default() -> Self {
        EventLogType::Unknown
    }
}

impl ::protobuf::reflect::ProtobufValue for EventLogType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangeDataEvent {
    // message fields
    pub events: ::protobuf::RepeatedField<Event>,
    pub resolved_ts: ::protobuf::SingularPtrField<ResolvedTs>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangeDataEvent {
    fn default() -> &'a ChangeDataEvent {
        <ChangeDataEvent as ::protobuf::Message>::default_instance()
    }
}

impl ChangeDataEvent {
    pub fn new() -> ChangeDataEvent {
        ::std::default::Default::default()
    }

    // repeated .cdcpb.Event events = 1;


    pub fn get_events(&self) -> &[Event] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<Event>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<Event> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<Event> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }

    // .cdcpb.ResolvedTs resolved_ts = 2;


    pub fn get_resolved_ts(&self) -> &ResolvedTs {
        self.resolved_ts.as_ref().unwrap_or_else(|| ResolvedTs::default_instance())
    }
    pub fn clear_resolved_ts(&mut self) {
        self.resolved_ts.clear();
    }

    pub fn has_resolved_ts(&self) -> bool {
        self.resolved_ts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resolved_ts(&mut self, v: ResolvedTs) {
        self.resolved_ts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resolved_ts(&mut self) -> &mut ResolvedTs {
        if self.resolved_ts.is_none() {
            self.resolved_ts.set_default();
        }
        self.resolved_ts.as_mut().unwrap()
    }

    // Take field
    pub fn take_resolved_ts(&mut self) -> ResolvedTs {
        self.resolved_ts.take().unwrap_or_else(|| ResolvedTs::new())
    }
}

impl ::protobuf::Message for ChangeDataEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resolved_ts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resolved_ts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.resolved_ts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.events {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.resolved_ts.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangeDataEvent {
        ChangeDataEvent::new()
    }

    fn default_instance() -> &'static ChangeDataEvent {
        static mut instance: ::protobuf::lazy::Lazy<ChangeDataEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChangeDataEvent,
        };
        unsafe {
            instance.get(ChangeDataEvent::new)
        }
    }
}

impl ::protobuf::Clear for ChangeDataEvent {
    fn clear(&mut self) {
        self.events.clear();
        self.resolved_ts.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ChangeDataEvent {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.events, "events", buf);
        ::protobuf::PbPrint::fmt(&self.resolved_ts, "resolved_ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ChangeDataEvent {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.events, "events", &mut s);
        ::protobuf::PbPrint::fmt(&self.resolved_ts, "resolved_ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeDataEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResolvedTs {
    // message fields
    pub regions: ::std::vec::Vec<u64>,
    pub ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResolvedTs {
    fn default() -> &'a ResolvedTs {
        <ResolvedTs as ::protobuf::Message>::default_instance()
    }
}

impl ResolvedTs {
    pub fn new() -> ResolvedTs {
        ::std::default::Default::default()
    }

    // repeated uint64 regions = 1;


    pub fn get_regions(&self) -> &[u64] {
        &self.regions
    }
    pub fn clear_regions(&mut self) {
        self.regions.clear();
    }

    // Param is passed by value, moved
    pub fn set_regions(&mut self, v: ::std::vec::Vec<u64>) {
        self.regions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_regions(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.regions
    }

    // Take field
    pub fn take_regions(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.regions, ::std::vec::Vec::new())
    }

    // uint64 ts = 2;


    pub fn get_ts(&self) -> u64 {
        self.ts
    }
    pub fn clear_ts(&mut self) {
        self.ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_ts(&mut self, v: u64) {
        self.ts = v;
    }
}

impl ::protobuf::Message for ResolvedTs {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.regions)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.regions {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.ts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.regions {
            os.write_uint64(1, *v)?;
        };
        if self.ts != 0 {
            os.write_uint64(2, self.ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResolvedTs {
        ResolvedTs::new()
    }

    fn default_instance() -> &'static ResolvedTs {
        static mut instance: ::protobuf::lazy::Lazy<ResolvedTs> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResolvedTs,
        };
        unsafe {
            instance.get(ResolvedTs::new)
        }
    }
}

impl ::protobuf::Clear for ResolvedTs {
    fn clear(&mut self) {
        self.regions.clear();
        self.ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ResolvedTs {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.regions, "regions", buf);
        ::protobuf::PbPrint::fmt(&self.ts, "ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ResolvedTs {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.regions, "regions", &mut s);
        ::protobuf::PbPrint::fmt(&self.ts, "ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResolvedTs {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangeDataRequest {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub region_id: u64,
    pub region_epoch: ::protobuf::SingularPtrField<super::metapb::RegionEpoch>,
    pub checkpoint_ts: u64,
    pub start_key: ::std::vec::Vec<u8>,
    pub end_key: ::std::vec::Vec<u8>,
    pub request_id: u64,
    pub extra_op: super::kvrpcpb::ExtraOp,
    pub kv_api: ChangeDataRequestKvApi,
    // message oneof groups
    pub request: ::std::option::Option<ChangeDataRequest_oneof_request>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangeDataRequest {
    fn default() -> &'a ChangeDataRequest {
        <ChangeDataRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq)]
pub enum ChangeDataRequest_oneof_request {
    Register(ChangeDataRequestRegister),
    NotifyTxnStatus(ChangeDataRequestNotifyTxnStatus),
}

impl ::protobuf::PbPrint for ChangeDataRequest_oneof_request {
    fn fmt(&self, name: &str, buf: &mut String) {
        match self {
            ChangeDataRequest_oneof_request::Register(v) => ::protobuf::PbPrint::fmt(v, name, buf),
            ChangeDataRequest_oneof_request::NotifyTxnStatus(v) => ::protobuf::PbPrint::fmt(v, name, buf),
        }
    }
}

impl ChangeDataRequest {
    pub fn new() -> ChangeDataRequest {
        ::std::default::Default::default()
    }

    // .cdcpb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // uint64 region_id = 2;


    pub fn get_region_id(&self) -> u64 {
        self.region_id
    }
    pub fn clear_region_id(&mut self) {
        self.region_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_region_id(&mut self, v: u64) {
        self.region_id = v;
    }

    // .metapb.RegionEpoch region_epoch = 3;


    pub fn get_region_epoch(&self) -> &super::metapb::RegionEpoch {
        self.region_epoch.as_ref().unwrap_or_else(|| super::metapb::RegionEpoch::default_instance())
    }
    pub fn clear_region_epoch(&mut self) {
        self.region_epoch.clear();
    }

    pub fn has_region_epoch(&self) -> bool {
        self.region_epoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_epoch(&mut self, v: super::metapb::RegionEpoch) {
        self.region_epoch = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_epoch(&mut self) -> &mut super::metapb::RegionEpoch {
        if self.region_epoch.is_none() {
            self.region_epoch.set_default();
        }
        self.region_epoch.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_epoch(&mut self) -> super::metapb::RegionEpoch {
        self.region_epoch.take().unwrap_or_else(|| super::metapb::RegionEpoch::new())
    }

    // uint64 checkpoint_ts = 4;


    pub fn get_checkpoint_ts(&self) -> u64 {
        self.checkpoint_ts
    }
    pub fn clear_checkpoint_ts(&mut self) {
        self.checkpoint_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_checkpoint_ts(&mut self, v: u64) {
        self.checkpoint_ts = v;
    }

    // bytes start_key = 5;


    pub fn get_start_key(&self) -> &[u8] {
        &self.start_key
    }
    pub fn clear_start_key(&mut self) {
        self.start_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.start_key
    }

    // Take field
    pub fn take_start_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.start_key, ::std::vec::Vec::new())
    }

    // bytes end_key = 6;


    pub fn get_end_key(&self) -> &[u8] {
        &self.end_key
    }
    pub fn clear_end_key(&mut self) {
        self.end_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_end_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.end_key
    }

    // Take field
    pub fn take_end_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.end_key, ::std::vec::Vec::new())
    }

    // uint64 request_id = 7;


    pub fn get_request_id(&self) -> u64 {
        self.request_id
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = v;
    }

    // .kvrpcpb.ExtraOp extra_op = 8;


    pub fn get_extra_op(&self) -> super::kvrpcpb::ExtraOp {
        self.extra_op
    }
    pub fn clear_extra_op(&mut self) {
        self.extra_op = super::kvrpcpb::ExtraOp::Noop;
    }

    // Param is passed by value, moved
    pub fn set_extra_op(&mut self, v: super::kvrpcpb::ExtraOp) {
        self.extra_op = v;
    }

    // .cdcpb.ChangeDataRequest.Register register = 9;


    pub fn get_register(&self) -> &ChangeDataRequestRegister {
        match self.request {
            ::std::option::Option::Some(ChangeDataRequest_oneof_request::Register(ref v)) => v,
            _ => ChangeDataRequestRegister::default_instance(),
        }
    }
    pub fn clear_register(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_register(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(ChangeDataRequest_oneof_request::Register(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_register(&mut self, v: ChangeDataRequestRegister) {
        self.request = ::std::option::Option::Some(ChangeDataRequest_oneof_request::Register(v))
    }

    // Mutable pointer to the field.
    pub fn mut_register(&mut self) -> &mut ChangeDataRequestRegister {
        if let ::std::option::Option::Some(ChangeDataRequest_oneof_request::Register(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(ChangeDataRequest_oneof_request::Register(ChangeDataRequestRegister::new()));
        }
        match self.request {
            ::std::option::Option::Some(ChangeDataRequest_oneof_request::Register(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_register(&mut self) -> ChangeDataRequestRegister {
        if self.has_register() {
            match self.request.take() {
                ::std::option::Option::Some(ChangeDataRequest_oneof_request::Register(v)) => v,
                _ => panic!(),
            }
        } else {
            ChangeDataRequestRegister::new()
        }
    }

    // .cdcpb.ChangeDataRequest.NotifyTxnStatus notify_txn_status = 10;


    pub fn get_notify_txn_status(&self) -> &ChangeDataRequestNotifyTxnStatus {
        match self.request {
            ::std::option::Option::Some(ChangeDataRequest_oneof_request::NotifyTxnStatus(ref v)) => v,
            _ => ChangeDataRequestNotifyTxnStatus::default_instance(),
        }
    }
    pub fn clear_notify_txn_status(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_notify_txn_status(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(ChangeDataRequest_oneof_request::NotifyTxnStatus(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_notify_txn_status(&mut self, v: ChangeDataRequestNotifyTxnStatus) {
        self.request = ::std::option::Option::Some(ChangeDataRequest_oneof_request::NotifyTxnStatus(v))
    }

    // Mutable pointer to the field.
    pub fn mut_notify_txn_status(&mut self) -> &mut ChangeDataRequestNotifyTxnStatus {
        if let ::std::option::Option::Some(ChangeDataRequest_oneof_request::NotifyTxnStatus(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(ChangeDataRequest_oneof_request::NotifyTxnStatus(ChangeDataRequestNotifyTxnStatus::new()));
        }
        match self.request {
            ::std::option::Option::Some(ChangeDataRequest_oneof_request::NotifyTxnStatus(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_notify_txn_status(&mut self) -> ChangeDataRequestNotifyTxnStatus {
        if self.has_notify_txn_status() {
            match self.request.take() {
                ::std::option::Option::Some(ChangeDataRequest_oneof_request::NotifyTxnStatus(v)) => v,
                _ => panic!(),
            }
        } else {
            ChangeDataRequestNotifyTxnStatus::new()
        }
    }

    // .cdcpb.ChangeDataRequest.KvAPI kv_api = 11;


    pub fn get_kv_api(&self) -> ChangeDataRequestKvApi {
        self.kv_api
    }
    pub fn clear_kv_api(&mut self) {
        self.kv_api = ChangeDataRequestKvApi::TiDb;
    }

    // Param is passed by value, moved
    pub fn set_kv_api(&mut self, v: ChangeDataRequestKvApi) {
        self.kv_api = v;
    }
}

impl ::protobuf::Message for ChangeDataRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.region_epoch {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(ChangeDataRequest_oneof_request::Register(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ChangeDataRequest_oneof_request::NotifyTxnStatus(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.region_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_epoch)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.checkpoint_ts = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.start_key)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.end_key)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = tmp;
                },
                8 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.extra_op = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(ChangeDataRequest_oneof_request::Register(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(ChangeDataRequest_oneof_request::NotifyTxnStatus(is.read_message()?));
                },
                11 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.kv_api = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.region_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.region_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.region_epoch.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.checkpoint_ts != 0 {
            my_size += ::protobuf::rt::value_size(4, self.checkpoint_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.start_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.start_key);
        }
        if !self.end_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.end_key);
        }
        if self.request_id != 0 {
            my_size += ::protobuf::rt::value_size(7, self.request_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.extra_op != super::kvrpcpb::ExtraOp::Noop {
            my_size += ::protobuf::rt::enum_size(8, self.extra_op);
        }
        if self.kv_api != ChangeDataRequestKvApi::TiDb {
            my_size += ::protobuf::rt::enum_size(11, self.kv_api);
        }
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &ChangeDataRequest_oneof_request::Register(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ChangeDataRequest_oneof_request::NotifyTxnStatus(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.region_id != 0 {
            os.write_uint64(2, self.region_id)?;
        }
        if let Some(ref v) = self.region_epoch.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.checkpoint_ts != 0 {
            os.write_uint64(4, self.checkpoint_ts)?;
        }
        if !self.start_key.is_empty() {
            os.write_bytes(5, &self.start_key)?;
        }
        if !self.end_key.is_empty() {
            os.write_bytes(6, &self.end_key)?;
        }
        if self.request_id != 0 {
            os.write_uint64(7, self.request_id)?;
        }
        if self.extra_op != super::kvrpcpb::ExtraOp::Noop {
            os.write_enum(8, self.extra_op.value())?;
        }
        if self.kv_api != ChangeDataRequestKvApi::TiDb {
            os.write_enum(11, self.kv_api.value())?;
        }
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &ChangeDataRequest_oneof_request::Register(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ChangeDataRequest_oneof_request::NotifyTxnStatus(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangeDataRequest {
        ChangeDataRequest::new()
    }

    fn default_instance() -> &'static ChangeDataRequest {
        static mut instance: ::protobuf::lazy::Lazy<ChangeDataRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChangeDataRequest,
        };
        unsafe {
            instance.get(ChangeDataRequest::new)
        }
    }
}

impl ::protobuf::Clear for ChangeDataRequest {
    fn clear(&mut self) {
        self.header.clear();
        self.region_id = 0;
        self.region_epoch.clear();
        self.checkpoint_ts = 0;
        self.start_key.clear();
        self.end_key.clear();
        self.request_id = 0;
        self.extra_op = super::kvrpcpb::ExtraOp::Noop;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.kv_api = ChangeDataRequestKvApi::TiDb;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ChangeDataRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.header, "header", buf);
        ::protobuf::PbPrint::fmt(&self.region_id, "region_id", buf);
        ::protobuf::PbPrint::fmt(&self.region_epoch, "region_epoch", buf);
        ::protobuf::PbPrint::fmt(&self.checkpoint_ts, "checkpoint_ts", buf);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", buf);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", buf);
        ::protobuf::PbPrint::fmt(&self.request_id, "request_id", buf);
        ::protobuf::PbPrint::fmt(&self.extra_op, "extra_op", buf);
        ::protobuf::PbPrint::fmt(&self.kv_api, "kv_api", buf);
        ::protobuf::PbPrint::fmt(&self.request, "request", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ChangeDataRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.header, "header", &mut s);
        ::protobuf::PbPrint::fmt(&self.region_id, "region_id", &mut s);
        ::protobuf::PbPrint::fmt(&self.region_epoch, "region_epoch", &mut s);
        ::protobuf::PbPrint::fmt(&self.checkpoint_ts, "checkpoint_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.request_id, "request_id", &mut s);
        ::protobuf::PbPrint::fmt(&self.extra_op, "extra_op", &mut s);
        ::protobuf::PbPrint::fmt(&self.kv_api, "kv_api", &mut s);
        ::protobuf::PbPrint::fmt(&self.request, "request", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeDataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangeDataRequestRegister {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangeDataRequestRegister {
    fn default() -> &'a ChangeDataRequestRegister {
        <ChangeDataRequestRegister as ::protobuf::Message>::default_instance()
    }
}

impl ChangeDataRequestRegister {
    pub fn new() -> ChangeDataRequestRegister {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChangeDataRequestRegister {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangeDataRequestRegister {
        ChangeDataRequestRegister::new()
    }

    fn default_instance() -> &'static ChangeDataRequestRegister {
        static mut instance: ::protobuf::lazy::Lazy<ChangeDataRequestRegister> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChangeDataRequestRegister,
        };
        unsafe {
            instance.get(ChangeDataRequestRegister::new)
        }
    }
}

impl ::protobuf::Clear for ChangeDataRequestRegister {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ChangeDataRequestRegister {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
    }
}
impl ::std::fmt::Debug for ChangeDataRequestRegister {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        Ok(())
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeDataRequestRegister {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangeDataRequestNotifyTxnStatus {
    // message fields
    pub txn_status: ::protobuf::RepeatedField<TxnStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangeDataRequestNotifyTxnStatus {
    fn default() -> &'a ChangeDataRequestNotifyTxnStatus {
        <ChangeDataRequestNotifyTxnStatus as ::protobuf::Message>::default_instance()
    }
}

impl ChangeDataRequestNotifyTxnStatus {
    pub fn new() -> ChangeDataRequestNotifyTxnStatus {
        ::std::default::Default::default()
    }

    // repeated .cdcpb.TxnStatus txn_status = 1;


    pub fn get_txn_status(&self) -> &[TxnStatus] {
        &self.txn_status
    }
    pub fn clear_txn_status(&mut self) {
        self.txn_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_txn_status(&mut self, v: ::protobuf::RepeatedField<TxnStatus>) {
        self.txn_status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_txn_status(&mut self) -> &mut ::protobuf::RepeatedField<TxnStatus> {
        &mut self.txn_status
    }

    // Take field
    pub fn take_txn_status(&mut self) -> ::protobuf::RepeatedField<TxnStatus> {
        ::std::mem::replace(&mut self.txn_status, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChangeDataRequestNotifyTxnStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.txn_status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.txn_status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.txn_status {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.txn_status {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangeDataRequestNotifyTxnStatus {
        ChangeDataRequestNotifyTxnStatus::new()
    }

    fn default_instance() -> &'static ChangeDataRequestNotifyTxnStatus {
        static mut instance: ::protobuf::lazy::Lazy<ChangeDataRequestNotifyTxnStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChangeDataRequestNotifyTxnStatus,
        };
        unsafe {
            instance.get(ChangeDataRequestNotifyTxnStatus::new)
        }
    }
}

impl ::protobuf::Clear for ChangeDataRequestNotifyTxnStatus {
    fn clear(&mut self) {
        self.txn_status.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ChangeDataRequestNotifyTxnStatus {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.txn_status, "txn_status", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ChangeDataRequestNotifyTxnStatus {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.txn_status, "txn_status", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeDataRequestNotifyTxnStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ChangeDataRequestKvApi {
    TiDb = 0,
    RawKv = 1,
    TxnKv = 2,
}

impl ::protobuf::ProtobufEnum for ChangeDataRequestKvApi {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChangeDataRequestKvApi> {
        match value {
            0 => ::std::option::Option::Some(ChangeDataRequestKvApi::TiDb),
            1 => ::std::option::Option::Some(ChangeDataRequestKvApi::RawKv),
            2 => ::std::option::Option::Some(ChangeDataRequestKvApi::TxnKv),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ChangeDataRequestKvApi] = &[
            ChangeDataRequestKvApi::TiDb,
            ChangeDataRequestKvApi::RawKv,
            ChangeDataRequestKvApi::TxnKv,
        ];
        values
    }
}

impl ::std::marker::Copy for ChangeDataRequestKvApi {
}

impl ::protobuf::PbPrint for ChangeDataRequestKvApi {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == ChangeDataRequestKvApi::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for ChangeDataRequestKvApi {
    fn default() -> Self {
        ChangeDataRequestKvApi::TiDb
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeDataRequestKvApi {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}
pub use super::cdcpb_grpc::*;
