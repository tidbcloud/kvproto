// This file is generated by rust-protobuf 2.8.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `kvrpcpb.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_0;

#[derive(PartialEq,Clone,Default)]
pub struct GetRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub key: ::std::vec::Vec<u8>,
    pub version: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetRequest {
    fn default() -> &'a GetRequest {
        <GetRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetRequest {
    pub fn new() -> GetRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // bytes key = 2;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // uint64 version = 3;


    pub fn get_version(&self) -> u64 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = v;
    }
}

impl ::protobuf::Message for GetRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.version = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.key);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(3, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(2, &self.key)?;
        }
        if self.version != 0 {
            os.write_uint64(3, self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRequest {
        GetRequest::new()
    }

    fn default_instance() -> &'static GetRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetRequest,
        };
        unsafe {
            instance.get(GetRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.key.clear();
        self.version = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for GetRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        ::protobuf::PbPrint::fmt(&self.version, "version", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for GetRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        ::protobuf::PbPrint::fmt(&self.version, "version", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::protobuf::SingularPtrField<KeyError>,
    pub value: ::std::vec::Vec<u8>,
    pub not_found: bool,
    pub exec_details_v2: ::protobuf::SingularPtrField<ExecDetailsV2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetResponse {
    fn default() -> &'a GetResponse {
        <GetResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetResponse {
    pub fn new() -> GetResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // .kvrpcpb.KeyError error = 2;


    pub fn get_error(&self) -> &KeyError {
        self.error.as_ref().unwrap_or_else(|| KeyError::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: KeyError) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut KeyError {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> KeyError {
        self.error.take().unwrap_or_else(|| KeyError::new())
    }

    // bytes value = 3;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // bool not_found = 4;


    pub fn get_not_found(&self) -> bool {
        self.not_found
    }
    pub fn clear_not_found(&mut self) {
        self.not_found = false;
    }

    // Param is passed by value, moved
    pub fn set_not_found(&mut self, v: bool) {
        self.not_found = v;
    }

    // .kvrpcpb.ExecDetailsV2 exec_details_v2 = 6;


    pub fn get_exec_details_v2(&self) -> &ExecDetailsV2 {
        self.exec_details_v2.as_ref().unwrap_or_else(|| ExecDetailsV2::default_instance())
    }
    pub fn clear_exec_details_v2(&mut self) {
        self.exec_details_v2.clear();
    }

    pub fn has_exec_details_v2(&self) -> bool {
        self.exec_details_v2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exec_details_v2(&mut self, v: ExecDetailsV2) {
        self.exec_details_v2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_details_v2(&mut self) -> &mut ExecDetailsV2 {
        if self.exec_details_v2.is_none() {
            self.exec_details_v2.set_default();
        }
        self.exec_details_v2.as_mut().unwrap()
    }

    // Take field
    pub fn take_exec_details_v2(&mut self) -> ExecDetailsV2 {
        self.exec_details_v2.take().unwrap_or_else(|| ExecDetailsV2::new())
    }
}

impl ::protobuf::Message for GetResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exec_details_v2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.not_found = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exec_details_v2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.value);
        }
        if self.not_found != false {
            my_size += 2;
        }
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(3, &self.value)?;
        }
        if self.not_found != false {
            os.write_bool(4, self.not_found)?;
        }
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetResponse {
        GetResponse::new()
    }

    fn default_instance() -> &'static GetResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetResponse,
        };
        unsafe {
            instance.get(GetResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.value.clear();
        self.not_found = false;
        self.exec_details_v2.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for GetResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.value, "value", buf);
        ::protobuf::PbPrint::fmt(&self.not_found, "not_found", buf);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for GetResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.value, "value", &mut s);
        ::protobuf::PbPrint::fmt(&self.not_found, "not_found", &mut s);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScanRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub start_key: ::std::vec::Vec<u8>,
    pub limit: u32,
    pub version: u64,
    pub key_only: bool,
    pub reverse: bool,
    pub end_key: ::std::vec::Vec<u8>,
    pub sample_step: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScanRequest {
    fn default() -> &'a ScanRequest {
        <ScanRequest as ::protobuf::Message>::default_instance()
    }
}

impl ScanRequest {
    pub fn new() -> ScanRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // bytes start_key = 2;


    pub fn get_start_key(&self) -> &[u8] {
        &self.start_key
    }
    pub fn clear_start_key(&mut self) {
        self.start_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.start_key
    }

    // Take field
    pub fn take_start_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.start_key, ::std::vec::Vec::new())
    }

    // uint32 limit = 3;


    pub fn get_limit(&self) -> u32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u32) {
        self.limit = v;
    }

    // uint64 version = 4;


    pub fn get_version(&self) -> u64 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = v;
    }

    // bool key_only = 5;


    pub fn get_key_only(&self) -> bool {
        self.key_only
    }
    pub fn clear_key_only(&mut self) {
        self.key_only = false;
    }

    // Param is passed by value, moved
    pub fn set_key_only(&mut self, v: bool) {
        self.key_only = v;
    }

    // bool reverse = 6;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }

    // bytes end_key = 7;


    pub fn get_end_key(&self) -> &[u8] {
        &self.end_key
    }
    pub fn clear_end_key(&mut self) {
        self.end_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_end_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.end_key
    }

    // Take field
    pub fn take_end_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.end_key, ::std::vec::Vec::new())
    }

    // uint32 sample_step = 8;


    pub fn get_sample_step(&self) -> u32 {
        self.sample_step
    }
    pub fn clear_sample_step(&mut self) {
        self.sample_step = 0;
    }

    // Param is passed by value, moved
    pub fn set_sample_step(&mut self, v: u32) {
        self.sample_step = v;
    }
}

impl ::protobuf::Message for ScanRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.start_key)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.limit = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.version = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.key_only = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.end_key)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sample_step = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.start_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.start_key);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(4, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.key_only != false {
            my_size += 2;
        }
        if self.reverse != false {
            my_size += 2;
        }
        if !self.end_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.end_key);
        }
        if self.sample_step != 0 {
            my_size += ::protobuf::rt::value_size(8, self.sample_step, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.start_key.is_empty() {
            os.write_bytes(2, &self.start_key)?;
        }
        if self.limit != 0 {
            os.write_uint32(3, self.limit)?;
        }
        if self.version != 0 {
            os.write_uint64(4, self.version)?;
        }
        if self.key_only != false {
            os.write_bool(5, self.key_only)?;
        }
        if self.reverse != false {
            os.write_bool(6, self.reverse)?;
        }
        if !self.end_key.is_empty() {
            os.write_bytes(7, &self.end_key)?;
        }
        if self.sample_step != 0 {
            os.write_uint32(8, self.sample_step)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScanRequest {
        ScanRequest::new()
    }

    fn default_instance() -> &'static ScanRequest {
        static mut instance: ::protobuf::lazy::Lazy<ScanRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScanRequest,
        };
        unsafe {
            instance.get(ScanRequest::new)
        }
    }
}

impl ::protobuf::Clear for ScanRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.start_key.clear();
        self.limit = 0;
        self.version = 0;
        self.key_only = false;
        self.reverse = false;
        self.end_key.clear();
        self.sample_step = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ScanRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", buf);
        ::protobuf::PbPrint::fmt(&self.limit, "limit", buf);
        ::protobuf::PbPrint::fmt(&self.version, "version", buf);
        ::protobuf::PbPrint::fmt(&self.key_only, "key_only", buf);
        ::protobuf::PbPrint::fmt(&self.reverse, "reverse", buf);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", buf);
        ::protobuf::PbPrint::fmt(&self.sample_step, "sample_step", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ScanRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.limit, "limit", &mut s);
        ::protobuf::PbPrint::fmt(&self.version, "version", &mut s);
        ::protobuf::PbPrint::fmt(&self.key_only, "key_only", &mut s);
        ::protobuf::PbPrint::fmt(&self.reverse, "reverse", &mut s);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.sample_step, "sample_step", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScanRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScanResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub pairs: ::protobuf::RepeatedField<KvPair>,
    pub error: ::protobuf::SingularPtrField<KeyError>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScanResponse {
    fn default() -> &'a ScanResponse {
        <ScanResponse as ::protobuf::Message>::default_instance()
    }
}

impl ScanResponse {
    pub fn new() -> ScanResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // repeated .kvrpcpb.KvPair pairs = 2;


    pub fn get_pairs(&self) -> &[KvPair] {
        &self.pairs
    }
    pub fn clear_pairs(&mut self) {
        self.pairs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pairs(&mut self, v: ::protobuf::RepeatedField<KvPair>) {
        self.pairs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pairs(&mut self) -> &mut ::protobuf::RepeatedField<KvPair> {
        &mut self.pairs
    }

    // Take field
    pub fn take_pairs(&mut self) -> ::protobuf::RepeatedField<KvPair> {
        ::std::mem::replace(&mut self.pairs, ::protobuf::RepeatedField::new())
    }

    // .kvrpcpb.KeyError error = 3;


    pub fn get_error(&self) -> &KeyError {
        self.error.as_ref().unwrap_or_else(|| KeyError::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: KeyError) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut KeyError {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> KeyError {
        self.error.take().unwrap_or_else(|| KeyError::new())
    }
}

impl ::protobuf::Message for ScanResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pairs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pairs)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.pairs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScanResponse {
        ScanResponse::new()
    }

    fn default_instance() -> &'static ScanResponse {
        static mut instance: ::protobuf::lazy::Lazy<ScanResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScanResponse,
        };
        unsafe {
            instance.get(ScanResponse::new)
        }
    }
}

impl ::protobuf::Clear for ScanResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.pairs.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ScanResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.pairs, "pairs", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ScanResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.pairs, "pairs", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScanResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PrewriteRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub mutations: ::protobuf::RepeatedField<Mutation>,
    pub primary_lock: ::std::vec::Vec<u8>,
    pub start_version: u64,
    pub lock_ttl: u64,
    pub skip_constraint_check: bool,
    pub pessimistic_actions: ::std::vec::Vec<PrewriteRequestPessimisticAction>,
    pub txn_size: u64,
    pub for_update_ts: u64,
    pub min_commit_ts: u64,
    pub use_async_commit: bool,
    pub secondaries: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub try_one_pc: bool,
    pub max_commit_ts: u64,
    pub assertion_level: AssertionLevel,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrewriteRequest {
    fn default() -> &'a PrewriteRequest {
        <PrewriteRequest as ::protobuf::Message>::default_instance()
    }
}

impl PrewriteRequest {
    pub fn new() -> PrewriteRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // repeated .kvrpcpb.Mutation mutations = 2;


    pub fn get_mutations(&self) -> &[Mutation] {
        &self.mutations
    }
    pub fn clear_mutations(&mut self) {
        self.mutations.clear();
    }

    // Param is passed by value, moved
    pub fn set_mutations(&mut self, v: ::protobuf::RepeatedField<Mutation>) {
        self.mutations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mutations(&mut self) -> &mut ::protobuf::RepeatedField<Mutation> {
        &mut self.mutations
    }

    // Take field
    pub fn take_mutations(&mut self) -> ::protobuf::RepeatedField<Mutation> {
        ::std::mem::replace(&mut self.mutations, ::protobuf::RepeatedField::new())
    }

    // bytes primary_lock = 3;


    pub fn get_primary_lock(&self) -> &[u8] {
        &self.primary_lock
    }
    pub fn clear_primary_lock(&mut self) {
        self.primary_lock.clear();
    }

    // Param is passed by value, moved
    pub fn set_primary_lock(&mut self, v: ::std::vec::Vec<u8>) {
        self.primary_lock = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary_lock(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.primary_lock
    }

    // Take field
    pub fn take_primary_lock(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.primary_lock, ::std::vec::Vec::new())
    }

    // uint64 start_version = 4;


    pub fn get_start_version(&self) -> u64 {
        self.start_version
    }
    pub fn clear_start_version(&mut self) {
        self.start_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_version(&mut self, v: u64) {
        self.start_version = v;
    }

    // uint64 lock_ttl = 5;


    pub fn get_lock_ttl(&self) -> u64 {
        self.lock_ttl
    }
    pub fn clear_lock_ttl(&mut self) {
        self.lock_ttl = 0;
    }

    // Param is passed by value, moved
    pub fn set_lock_ttl(&mut self, v: u64) {
        self.lock_ttl = v;
    }

    // bool skip_constraint_check = 6;


    pub fn get_skip_constraint_check(&self) -> bool {
        self.skip_constraint_check
    }
    pub fn clear_skip_constraint_check(&mut self) {
        self.skip_constraint_check = false;
    }

    // Param is passed by value, moved
    pub fn set_skip_constraint_check(&mut self, v: bool) {
        self.skip_constraint_check = v;
    }

    // repeated .kvrpcpb.PrewriteRequest.PessimisticAction pessimistic_actions = 7;


    pub fn get_pessimistic_actions(&self) -> &[PrewriteRequestPessimisticAction] {
        &self.pessimistic_actions
    }
    pub fn clear_pessimistic_actions(&mut self) {
        self.pessimistic_actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_pessimistic_actions(&mut self, v: ::std::vec::Vec<PrewriteRequestPessimisticAction>) {
        self.pessimistic_actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pessimistic_actions(&mut self) -> &mut ::std::vec::Vec<PrewriteRequestPessimisticAction> {
        &mut self.pessimistic_actions
    }

    // Take field
    pub fn take_pessimistic_actions(&mut self) -> ::std::vec::Vec<PrewriteRequestPessimisticAction> {
        ::std::mem::replace(&mut self.pessimistic_actions, ::std::vec::Vec::new())
    }

    // uint64 txn_size = 8;


    pub fn get_txn_size(&self) -> u64 {
        self.txn_size
    }
    pub fn clear_txn_size(&mut self) {
        self.txn_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_txn_size(&mut self, v: u64) {
        self.txn_size = v;
    }

    // uint64 for_update_ts = 9;


    pub fn get_for_update_ts(&self) -> u64 {
        self.for_update_ts
    }
    pub fn clear_for_update_ts(&mut self) {
        self.for_update_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_for_update_ts(&mut self, v: u64) {
        self.for_update_ts = v;
    }

    // uint64 min_commit_ts = 10;


    pub fn get_min_commit_ts(&self) -> u64 {
        self.min_commit_ts
    }
    pub fn clear_min_commit_ts(&mut self) {
        self.min_commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_commit_ts(&mut self, v: u64) {
        self.min_commit_ts = v;
    }

    // bool use_async_commit = 11;


    pub fn get_use_async_commit(&self) -> bool {
        self.use_async_commit
    }
    pub fn clear_use_async_commit(&mut self) {
        self.use_async_commit = false;
    }

    // Param is passed by value, moved
    pub fn set_use_async_commit(&mut self, v: bool) {
        self.use_async_commit = v;
    }

    // repeated bytes secondaries = 12;


    pub fn get_secondaries(&self) -> &[::std::vec::Vec<u8>] {
        &self.secondaries
    }
    pub fn clear_secondaries(&mut self) {
        self.secondaries.clear();
    }

    // Param is passed by value, moved
    pub fn set_secondaries(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.secondaries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_secondaries(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.secondaries
    }

    // Take field
    pub fn take_secondaries(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.secondaries, ::protobuf::RepeatedField::new())
    }

    // bool try_one_pc = 13;


    pub fn get_try_one_pc(&self) -> bool {
        self.try_one_pc
    }
    pub fn clear_try_one_pc(&mut self) {
        self.try_one_pc = false;
    }

    // Param is passed by value, moved
    pub fn set_try_one_pc(&mut self, v: bool) {
        self.try_one_pc = v;
    }

    // uint64 max_commit_ts = 14;


    pub fn get_max_commit_ts(&self) -> u64 {
        self.max_commit_ts
    }
    pub fn clear_max_commit_ts(&mut self) {
        self.max_commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_commit_ts(&mut self, v: u64) {
        self.max_commit_ts = v;
    }

    // .kvrpcpb.AssertionLevel assertion_level = 15;


    pub fn get_assertion_level(&self) -> AssertionLevel {
        self.assertion_level
    }
    pub fn clear_assertion_level(&mut self) {
        self.assertion_level = AssertionLevel::Off;
    }

    // Param is passed by value, moved
    pub fn set_assertion_level(&mut self, v: AssertionLevel) {
        self.assertion_level = v;
    }
}

impl ::protobuf::Message for PrewriteRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mutations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mutations)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.primary_lock)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_version = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lock_ttl = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.skip_constraint_check = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.pessimistic_actions, 7, &mut self.unknown_fields)?
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txn_size = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.for_update_ts = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.min_commit_ts = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_async_commit = tmp;
                },
                12 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.secondaries)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.try_one_pc = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_commit_ts = tmp;
                },
                15 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.assertion_level = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.mutations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.primary_lock.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.primary_lock);
        }
        if self.start_version != 0 {
            my_size += ::protobuf::rt::value_size(4, self.start_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.lock_ttl != 0 {
            my_size += ::protobuf::rt::value_size(5, self.lock_ttl, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.skip_constraint_check != false {
            my_size += 2;
        }
        for value in &self.pessimistic_actions {
            my_size += ::protobuf::rt::enum_size(7, *value);
        };
        if self.txn_size != 0 {
            my_size += ::protobuf::rt::value_size(8, self.txn_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.for_update_ts != 0 {
            my_size += ::protobuf::rt::value_size(9, self.for_update_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(10, self.min_commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.use_async_commit != false {
            my_size += 2;
        }
        for value in &self.secondaries {
            my_size += ::protobuf::rt::bytes_size(12, &value);
        };
        if self.try_one_pc != false {
            my_size += 2;
        }
        if self.max_commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(14, self.max_commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.assertion_level != AssertionLevel::Off {
            my_size += ::protobuf::rt::enum_size(15, self.assertion_level);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.mutations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.primary_lock.is_empty() {
            os.write_bytes(3, &self.primary_lock)?;
        }
        if self.start_version != 0 {
            os.write_uint64(4, self.start_version)?;
        }
        if self.lock_ttl != 0 {
            os.write_uint64(5, self.lock_ttl)?;
        }
        if self.skip_constraint_check != false {
            os.write_bool(6, self.skip_constraint_check)?;
        }
        for v in &self.pessimistic_actions {
            os.write_enum(7, v.value())?;
        };
        if self.txn_size != 0 {
            os.write_uint64(8, self.txn_size)?;
        }
        if self.for_update_ts != 0 {
            os.write_uint64(9, self.for_update_ts)?;
        }
        if self.min_commit_ts != 0 {
            os.write_uint64(10, self.min_commit_ts)?;
        }
        if self.use_async_commit != false {
            os.write_bool(11, self.use_async_commit)?;
        }
        for v in &self.secondaries {
            os.write_bytes(12, &v)?;
        };
        if self.try_one_pc != false {
            os.write_bool(13, self.try_one_pc)?;
        }
        if self.max_commit_ts != 0 {
            os.write_uint64(14, self.max_commit_ts)?;
        }
        if self.assertion_level != AssertionLevel::Off {
            os.write_enum(15, self.assertion_level.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrewriteRequest {
        PrewriteRequest::new()
    }

    fn default_instance() -> &'static PrewriteRequest {
        static mut instance: ::protobuf::lazy::Lazy<PrewriteRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PrewriteRequest,
        };
        unsafe {
            instance.get(PrewriteRequest::new)
        }
    }
}

impl ::protobuf::Clear for PrewriteRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.mutations.clear();
        self.primary_lock.clear();
        self.start_version = 0;
        self.lock_ttl = 0;
        self.skip_constraint_check = false;
        self.pessimistic_actions.clear();
        self.txn_size = 0;
        self.for_update_ts = 0;
        self.min_commit_ts = 0;
        self.use_async_commit = false;
        self.secondaries.clear();
        self.try_one_pc = false;
        self.max_commit_ts = 0;
        self.assertion_level = AssertionLevel::Off;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for PrewriteRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.mutations, "mutations", buf);
        ::protobuf::PbPrint::fmt(&self.primary_lock, "primary_lock", buf);
        ::protobuf::PbPrint::fmt(&self.start_version, "start_version", buf);
        ::protobuf::PbPrint::fmt(&self.lock_ttl, "lock_ttl", buf);
        ::protobuf::PbPrint::fmt(&self.skip_constraint_check, "skip_constraint_check", buf);
        ::protobuf::PbPrint::fmt(&self.pessimistic_actions, "pessimistic_actions", buf);
        ::protobuf::PbPrint::fmt(&self.txn_size, "txn_size", buf);
        ::protobuf::PbPrint::fmt(&self.for_update_ts, "for_update_ts", buf);
        ::protobuf::PbPrint::fmt(&self.min_commit_ts, "min_commit_ts", buf);
        ::protobuf::PbPrint::fmt(&self.use_async_commit, "use_async_commit", buf);
        ::protobuf::PbPrint::fmt(&self.secondaries, "secondaries", buf);
        ::protobuf::PbPrint::fmt(&self.try_one_pc, "try_one_pc", buf);
        ::protobuf::PbPrint::fmt(&self.max_commit_ts, "max_commit_ts", buf);
        ::protobuf::PbPrint::fmt(&self.assertion_level, "assertion_level", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for PrewriteRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.mutations, "mutations", &mut s);
        ::protobuf::PbPrint::fmt(&self.primary_lock, "primary_lock", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_version, "start_version", &mut s);
        ::protobuf::PbPrint::fmt(&self.lock_ttl, "lock_ttl", &mut s);
        ::protobuf::PbPrint::fmt(&self.skip_constraint_check, "skip_constraint_check", &mut s);
        ::protobuf::PbPrint::fmt(&self.pessimistic_actions, "pessimistic_actions", &mut s);
        ::protobuf::PbPrint::fmt(&self.txn_size, "txn_size", &mut s);
        ::protobuf::PbPrint::fmt(&self.for_update_ts, "for_update_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.min_commit_ts, "min_commit_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.use_async_commit, "use_async_commit", &mut s);
        ::protobuf::PbPrint::fmt(&self.secondaries, "secondaries", &mut s);
        ::protobuf::PbPrint::fmt(&self.try_one_pc, "try_one_pc", &mut s);
        ::protobuf::PbPrint::fmt(&self.max_commit_ts, "max_commit_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.assertion_level, "assertion_level", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrewriteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PrewriteRequestPessimisticAction {
    SkipPessimisticCheck = 0,
    DoPessimisticCheck = 1,
    DoConstraintCheck = 2,
}

impl ::protobuf::ProtobufEnum for PrewriteRequestPessimisticAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PrewriteRequestPessimisticAction> {
        match value {
            0 => ::std::option::Option::Some(PrewriteRequestPessimisticAction::SkipPessimisticCheck),
            1 => ::std::option::Option::Some(PrewriteRequestPessimisticAction::DoPessimisticCheck),
            2 => ::std::option::Option::Some(PrewriteRequestPessimisticAction::DoConstraintCheck),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PrewriteRequestPessimisticAction] = &[
            PrewriteRequestPessimisticAction::SkipPessimisticCheck,
            PrewriteRequestPessimisticAction::DoPessimisticCheck,
            PrewriteRequestPessimisticAction::DoConstraintCheck,
        ];
        values
    }
}

impl ::std::marker::Copy for PrewriteRequestPessimisticAction {
}

impl ::protobuf::PbPrint for PrewriteRequestPessimisticAction {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == PrewriteRequestPessimisticAction::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for PrewriteRequestPessimisticAction {
    fn default() -> Self {
        PrewriteRequestPessimisticAction::SkipPessimisticCheck
    }
}

impl ::protobuf::reflect::ProtobufValue for PrewriteRequestPessimisticAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PrewriteResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub errors: ::protobuf::RepeatedField<KeyError>,
    pub min_commit_ts: u64,
    pub one_pc_commit_ts: u64,
    pub exec_details_v2: ::protobuf::SingularPtrField<ExecDetailsV2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrewriteResponse {
    fn default() -> &'a PrewriteResponse {
        <PrewriteResponse as ::protobuf::Message>::default_instance()
    }
}

impl PrewriteResponse {
    pub fn new() -> PrewriteResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // repeated .kvrpcpb.KeyError errors = 2;


    pub fn get_errors(&self) -> &[KeyError] {
        &self.errors
    }
    pub fn clear_errors(&mut self) {
        self.errors.clear();
    }

    // Param is passed by value, moved
    pub fn set_errors(&mut self, v: ::protobuf::RepeatedField<KeyError>) {
        self.errors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_errors(&mut self) -> &mut ::protobuf::RepeatedField<KeyError> {
        &mut self.errors
    }

    // Take field
    pub fn take_errors(&mut self) -> ::protobuf::RepeatedField<KeyError> {
        ::std::mem::replace(&mut self.errors, ::protobuf::RepeatedField::new())
    }

    // uint64 min_commit_ts = 3;


    pub fn get_min_commit_ts(&self) -> u64 {
        self.min_commit_ts
    }
    pub fn clear_min_commit_ts(&mut self) {
        self.min_commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_commit_ts(&mut self, v: u64) {
        self.min_commit_ts = v;
    }

    // uint64 one_pc_commit_ts = 4;


    pub fn get_one_pc_commit_ts(&self) -> u64 {
        self.one_pc_commit_ts
    }
    pub fn clear_one_pc_commit_ts(&mut self) {
        self.one_pc_commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_one_pc_commit_ts(&mut self, v: u64) {
        self.one_pc_commit_ts = v;
    }

    // .kvrpcpb.ExecDetailsV2 exec_details_v2 = 5;


    pub fn get_exec_details_v2(&self) -> &ExecDetailsV2 {
        self.exec_details_v2.as_ref().unwrap_or_else(|| ExecDetailsV2::default_instance())
    }
    pub fn clear_exec_details_v2(&mut self) {
        self.exec_details_v2.clear();
    }

    pub fn has_exec_details_v2(&self) -> bool {
        self.exec_details_v2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exec_details_v2(&mut self, v: ExecDetailsV2) {
        self.exec_details_v2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_details_v2(&mut self) -> &mut ExecDetailsV2 {
        if self.exec_details_v2.is_none() {
            self.exec_details_v2.set_default();
        }
        self.exec_details_v2.as_mut().unwrap()
    }

    // Take field
    pub fn take_exec_details_v2(&mut self) -> ExecDetailsV2 {
        self.exec_details_v2.take().unwrap_or_else(|| ExecDetailsV2::new())
    }
}

impl ::protobuf::Message for PrewriteResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.errors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exec_details_v2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.errors)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.min_commit_ts = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.one_pc_commit_ts = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exec_details_v2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.errors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.min_commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(3, self.min_commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.one_pc_commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(4, self.one_pc_commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.errors {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.min_commit_ts != 0 {
            os.write_uint64(3, self.min_commit_ts)?;
        }
        if self.one_pc_commit_ts != 0 {
            os.write_uint64(4, self.one_pc_commit_ts)?;
        }
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrewriteResponse {
        PrewriteResponse::new()
    }

    fn default_instance() -> &'static PrewriteResponse {
        static mut instance: ::protobuf::lazy::Lazy<PrewriteResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PrewriteResponse,
        };
        unsafe {
            instance.get(PrewriteResponse::new)
        }
    }
}

impl ::protobuf::Clear for PrewriteResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.errors.clear();
        self.min_commit_ts = 0;
        self.one_pc_commit_ts = 0;
        self.exec_details_v2.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for PrewriteResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.errors, "errors", buf);
        ::protobuf::PbPrint::fmt(&self.min_commit_ts, "min_commit_ts", buf);
        ::protobuf::PbPrint::fmt(&self.one_pc_commit_ts, "one_pc_commit_ts", buf);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for PrewriteResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.errors, "errors", &mut s);
        ::protobuf::PbPrint::fmt(&self.min_commit_ts, "min_commit_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.one_pc_commit_ts, "one_pc_commit_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrewriteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PessimisticLockRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub mutations: ::protobuf::RepeatedField<Mutation>,
    pub primary_lock: ::std::vec::Vec<u8>,
    pub start_version: u64,
    pub lock_ttl: u64,
    pub for_update_ts: u64,
    pub is_first_lock: bool,
    pub wait_timeout: i64,
    pub force: bool,
    pub return_values: bool,
    pub min_commit_ts: u64,
    pub check_existence: bool,
    pub lock_only_if_exists: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PessimisticLockRequest {
    fn default() -> &'a PessimisticLockRequest {
        <PessimisticLockRequest as ::protobuf::Message>::default_instance()
    }
}

impl PessimisticLockRequest {
    pub fn new() -> PessimisticLockRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // repeated .kvrpcpb.Mutation mutations = 2;


    pub fn get_mutations(&self) -> &[Mutation] {
        &self.mutations
    }
    pub fn clear_mutations(&mut self) {
        self.mutations.clear();
    }

    // Param is passed by value, moved
    pub fn set_mutations(&mut self, v: ::protobuf::RepeatedField<Mutation>) {
        self.mutations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mutations(&mut self) -> &mut ::protobuf::RepeatedField<Mutation> {
        &mut self.mutations
    }

    // Take field
    pub fn take_mutations(&mut self) -> ::protobuf::RepeatedField<Mutation> {
        ::std::mem::replace(&mut self.mutations, ::protobuf::RepeatedField::new())
    }

    // bytes primary_lock = 3;


    pub fn get_primary_lock(&self) -> &[u8] {
        &self.primary_lock
    }
    pub fn clear_primary_lock(&mut self) {
        self.primary_lock.clear();
    }

    // Param is passed by value, moved
    pub fn set_primary_lock(&mut self, v: ::std::vec::Vec<u8>) {
        self.primary_lock = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary_lock(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.primary_lock
    }

    // Take field
    pub fn take_primary_lock(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.primary_lock, ::std::vec::Vec::new())
    }

    // uint64 start_version = 4;


    pub fn get_start_version(&self) -> u64 {
        self.start_version
    }
    pub fn clear_start_version(&mut self) {
        self.start_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_version(&mut self, v: u64) {
        self.start_version = v;
    }

    // uint64 lock_ttl = 5;


    pub fn get_lock_ttl(&self) -> u64 {
        self.lock_ttl
    }
    pub fn clear_lock_ttl(&mut self) {
        self.lock_ttl = 0;
    }

    // Param is passed by value, moved
    pub fn set_lock_ttl(&mut self, v: u64) {
        self.lock_ttl = v;
    }

    // uint64 for_update_ts = 6;


    pub fn get_for_update_ts(&self) -> u64 {
        self.for_update_ts
    }
    pub fn clear_for_update_ts(&mut self) {
        self.for_update_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_for_update_ts(&mut self, v: u64) {
        self.for_update_ts = v;
    }

    // bool is_first_lock = 7;


    pub fn get_is_first_lock(&self) -> bool {
        self.is_first_lock
    }
    pub fn clear_is_first_lock(&mut self) {
        self.is_first_lock = false;
    }

    // Param is passed by value, moved
    pub fn set_is_first_lock(&mut self, v: bool) {
        self.is_first_lock = v;
    }

    // int64 wait_timeout = 8;


    pub fn get_wait_timeout(&self) -> i64 {
        self.wait_timeout
    }
    pub fn clear_wait_timeout(&mut self) {
        self.wait_timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_wait_timeout(&mut self, v: i64) {
        self.wait_timeout = v;
    }

    // bool force = 9;


    pub fn get_force(&self) -> bool {
        self.force
    }
    pub fn clear_force(&mut self) {
        self.force = false;
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = v;
    }

    // bool return_values = 10;


    pub fn get_return_values(&self) -> bool {
        self.return_values
    }
    pub fn clear_return_values(&mut self) {
        self.return_values = false;
    }

    // Param is passed by value, moved
    pub fn set_return_values(&mut self, v: bool) {
        self.return_values = v;
    }

    // uint64 min_commit_ts = 11;


    pub fn get_min_commit_ts(&self) -> u64 {
        self.min_commit_ts
    }
    pub fn clear_min_commit_ts(&mut self) {
        self.min_commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_commit_ts(&mut self, v: u64) {
        self.min_commit_ts = v;
    }

    // bool check_existence = 12;


    pub fn get_check_existence(&self) -> bool {
        self.check_existence
    }
    pub fn clear_check_existence(&mut self) {
        self.check_existence = false;
    }

    // Param is passed by value, moved
    pub fn set_check_existence(&mut self, v: bool) {
        self.check_existence = v;
    }

    // bool lock_only_if_exists = 13;


    pub fn get_lock_only_if_exists(&self) -> bool {
        self.lock_only_if_exists
    }
    pub fn clear_lock_only_if_exists(&mut self) {
        self.lock_only_if_exists = false;
    }

    // Param is passed by value, moved
    pub fn set_lock_only_if_exists(&mut self, v: bool) {
        self.lock_only_if_exists = v;
    }
}

impl ::protobuf::Message for PessimisticLockRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mutations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mutations)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.primary_lock)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_version = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lock_ttl = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.for_update_ts = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_first_lock = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.wait_timeout = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_values = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.min_commit_ts = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.check_existence = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.lock_only_if_exists = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.mutations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.primary_lock.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.primary_lock);
        }
        if self.start_version != 0 {
            my_size += ::protobuf::rt::value_size(4, self.start_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.lock_ttl != 0 {
            my_size += ::protobuf::rt::value_size(5, self.lock_ttl, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.for_update_ts != 0 {
            my_size += ::protobuf::rt::value_size(6, self.for_update_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_first_lock != false {
            my_size += 2;
        }
        if self.wait_timeout != 0 {
            my_size += ::protobuf::rt::value_size(8, self.wait_timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.force != false {
            my_size += 2;
        }
        if self.return_values != false {
            my_size += 2;
        }
        if self.min_commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(11, self.min_commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.check_existence != false {
            my_size += 2;
        }
        if self.lock_only_if_exists != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.mutations {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.primary_lock.is_empty() {
            os.write_bytes(3, &self.primary_lock)?;
        }
        if self.start_version != 0 {
            os.write_uint64(4, self.start_version)?;
        }
        if self.lock_ttl != 0 {
            os.write_uint64(5, self.lock_ttl)?;
        }
        if self.for_update_ts != 0 {
            os.write_uint64(6, self.for_update_ts)?;
        }
        if self.is_first_lock != false {
            os.write_bool(7, self.is_first_lock)?;
        }
        if self.wait_timeout != 0 {
            os.write_int64(8, self.wait_timeout)?;
        }
        if self.force != false {
            os.write_bool(9, self.force)?;
        }
        if self.return_values != false {
            os.write_bool(10, self.return_values)?;
        }
        if self.min_commit_ts != 0 {
            os.write_uint64(11, self.min_commit_ts)?;
        }
        if self.check_existence != false {
            os.write_bool(12, self.check_existence)?;
        }
        if self.lock_only_if_exists != false {
            os.write_bool(13, self.lock_only_if_exists)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PessimisticLockRequest {
        PessimisticLockRequest::new()
    }

    fn default_instance() -> &'static PessimisticLockRequest {
        static mut instance: ::protobuf::lazy::Lazy<PessimisticLockRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PessimisticLockRequest,
        };
        unsafe {
            instance.get(PessimisticLockRequest::new)
        }
    }
}

impl ::protobuf::Clear for PessimisticLockRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.mutations.clear();
        self.primary_lock.clear();
        self.start_version = 0;
        self.lock_ttl = 0;
        self.for_update_ts = 0;
        self.is_first_lock = false;
        self.wait_timeout = 0;
        self.force = false;
        self.return_values = false;
        self.min_commit_ts = 0;
        self.check_existence = false;
        self.lock_only_if_exists = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for PessimisticLockRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.mutations, "mutations", buf);
        ::protobuf::PbPrint::fmt(&self.primary_lock, "primary_lock", buf);
        ::protobuf::PbPrint::fmt(&self.start_version, "start_version", buf);
        ::protobuf::PbPrint::fmt(&self.lock_ttl, "lock_ttl", buf);
        ::protobuf::PbPrint::fmt(&self.for_update_ts, "for_update_ts", buf);
        ::protobuf::PbPrint::fmt(&self.is_first_lock, "is_first_lock", buf);
        ::protobuf::PbPrint::fmt(&self.wait_timeout, "wait_timeout", buf);
        ::protobuf::PbPrint::fmt(&self.force, "force", buf);
        ::protobuf::PbPrint::fmt(&self.return_values, "return_values", buf);
        ::protobuf::PbPrint::fmt(&self.min_commit_ts, "min_commit_ts", buf);
        ::protobuf::PbPrint::fmt(&self.check_existence, "check_existence", buf);
        ::protobuf::PbPrint::fmt(&self.lock_only_if_exists, "lock_only_if_exists", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for PessimisticLockRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.mutations, "mutations", &mut s);
        ::protobuf::PbPrint::fmt(&self.primary_lock, "primary_lock", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_version, "start_version", &mut s);
        ::protobuf::PbPrint::fmt(&self.lock_ttl, "lock_ttl", &mut s);
        ::protobuf::PbPrint::fmt(&self.for_update_ts, "for_update_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.is_first_lock, "is_first_lock", &mut s);
        ::protobuf::PbPrint::fmt(&self.wait_timeout, "wait_timeout", &mut s);
        ::protobuf::PbPrint::fmt(&self.force, "force", &mut s);
        ::protobuf::PbPrint::fmt(&self.return_values, "return_values", &mut s);
        ::protobuf::PbPrint::fmt(&self.min_commit_ts, "min_commit_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.check_existence, "check_existence", &mut s);
        ::protobuf::PbPrint::fmt(&self.lock_only_if_exists, "lock_only_if_exists", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for PessimisticLockRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PessimisticLockResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub errors: ::protobuf::RepeatedField<KeyError>,
    pub commit_ts: u64,
    pub value: ::std::vec::Vec<u8>,
    pub values: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub not_founds: ::std::vec::Vec<bool>,
    pub exec_details_v2: ::protobuf::SingularPtrField<ExecDetailsV2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PessimisticLockResponse {
    fn default() -> &'a PessimisticLockResponse {
        <PessimisticLockResponse as ::protobuf::Message>::default_instance()
    }
}

impl PessimisticLockResponse {
    pub fn new() -> PessimisticLockResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // repeated .kvrpcpb.KeyError errors = 2;


    pub fn get_errors(&self) -> &[KeyError] {
        &self.errors
    }
    pub fn clear_errors(&mut self) {
        self.errors.clear();
    }

    // Param is passed by value, moved
    pub fn set_errors(&mut self, v: ::protobuf::RepeatedField<KeyError>) {
        self.errors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_errors(&mut self) -> &mut ::protobuf::RepeatedField<KeyError> {
        &mut self.errors
    }

    // Take field
    pub fn take_errors(&mut self) -> ::protobuf::RepeatedField<KeyError> {
        ::std::mem::replace(&mut self.errors, ::protobuf::RepeatedField::new())
    }

    // uint64 commit_ts = 3;


    pub fn get_commit_ts(&self) -> u64 {
        self.commit_ts
    }
    pub fn clear_commit_ts(&mut self) {
        self.commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_ts(&mut self, v: u64) {
        self.commit_ts = v;
    }

    // bytes value = 4;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // repeated bytes values = 5;


    pub fn get_values(&self) -> &[::std::vec::Vec<u8>] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }

    // repeated bool not_founds = 6;


    pub fn get_not_founds(&self) -> &[bool] {
        &self.not_founds
    }
    pub fn clear_not_founds(&mut self) {
        self.not_founds.clear();
    }

    // Param is passed by value, moved
    pub fn set_not_founds(&mut self, v: ::std::vec::Vec<bool>) {
        self.not_founds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_not_founds(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.not_founds
    }

    // Take field
    pub fn take_not_founds(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.not_founds, ::std::vec::Vec::new())
    }

    // .kvrpcpb.ExecDetailsV2 exec_details_v2 = 7;


    pub fn get_exec_details_v2(&self) -> &ExecDetailsV2 {
        self.exec_details_v2.as_ref().unwrap_or_else(|| ExecDetailsV2::default_instance())
    }
    pub fn clear_exec_details_v2(&mut self) {
        self.exec_details_v2.clear();
    }

    pub fn has_exec_details_v2(&self) -> bool {
        self.exec_details_v2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exec_details_v2(&mut self, v: ExecDetailsV2) {
        self.exec_details_v2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_details_v2(&mut self) -> &mut ExecDetailsV2 {
        if self.exec_details_v2.is_none() {
            self.exec_details_v2.set_default();
        }
        self.exec_details_v2.as_mut().unwrap()
    }

    // Take field
    pub fn take_exec_details_v2(&mut self) -> ExecDetailsV2 {
        self.exec_details_v2.take().unwrap_or_else(|| ExecDetailsV2::new())
    }
}

impl ::protobuf::Message for PessimisticLockResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.errors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exec_details_v2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.errors)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commit_ts = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.values)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.not_founds)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exec_details_v2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.errors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(3, self.commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.value);
        }
        for value in &self.values {
            my_size += ::protobuf::rt::bytes_size(5, &value);
        };
        my_size += 2 * self.not_founds.len() as u32;
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.errors {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.commit_ts != 0 {
            os.write_uint64(3, self.commit_ts)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(4, &self.value)?;
        }
        for v in &self.values {
            os.write_bytes(5, &v)?;
        };
        for v in &self.not_founds {
            os.write_bool(6, *v)?;
        };
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PessimisticLockResponse {
        PessimisticLockResponse::new()
    }

    fn default_instance() -> &'static PessimisticLockResponse {
        static mut instance: ::protobuf::lazy::Lazy<PessimisticLockResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PessimisticLockResponse,
        };
        unsafe {
            instance.get(PessimisticLockResponse::new)
        }
    }
}

impl ::protobuf::Clear for PessimisticLockResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.errors.clear();
        self.commit_ts = 0;
        self.value.clear();
        self.values.clear();
        self.not_founds.clear();
        self.exec_details_v2.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for PessimisticLockResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.errors, "errors", buf);
        ::protobuf::PbPrint::fmt(&self.commit_ts, "commit_ts", buf);
        ::protobuf::PbPrint::fmt(&self.value, "value", buf);
        ::protobuf::PbPrint::fmt(&self.values, "values", buf);
        ::protobuf::PbPrint::fmt(&self.not_founds, "not_founds", buf);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for PessimisticLockResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.errors, "errors", &mut s);
        ::protobuf::PbPrint::fmt(&self.commit_ts, "commit_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.value, "value", &mut s);
        ::protobuf::PbPrint::fmt(&self.values, "values", &mut s);
        ::protobuf::PbPrint::fmt(&self.not_founds, "not_founds", &mut s);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for PessimisticLockResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PessimisticRollbackRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub start_version: u64,
    pub for_update_ts: u64,
    pub keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PessimisticRollbackRequest {
    fn default() -> &'a PessimisticRollbackRequest {
        <PessimisticRollbackRequest as ::protobuf::Message>::default_instance()
    }
}

impl PessimisticRollbackRequest {
    pub fn new() -> PessimisticRollbackRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // uint64 start_version = 2;


    pub fn get_start_version(&self) -> u64 {
        self.start_version
    }
    pub fn clear_start_version(&mut self) {
        self.start_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_version(&mut self, v: u64) {
        self.start_version = v;
    }

    // uint64 for_update_ts = 3;


    pub fn get_for_update_ts(&self) -> u64 {
        self.for_update_ts
    }
    pub fn clear_for_update_ts(&mut self) {
        self.for_update_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_for_update_ts(&mut self, v: u64) {
        self.for_update_ts = v;
    }

    // repeated bytes keys = 4;


    pub fn get_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PessimisticRollbackRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_version = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.for_update_ts = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.start_version != 0 {
            my_size += ::protobuf::rt::value_size(2, self.start_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.for_update_ts != 0 {
            my_size += ::protobuf::rt::value_size(3, self.for_update_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.keys {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.start_version != 0 {
            os.write_uint64(2, self.start_version)?;
        }
        if self.for_update_ts != 0 {
            os.write_uint64(3, self.for_update_ts)?;
        }
        for v in &self.keys {
            os.write_bytes(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PessimisticRollbackRequest {
        PessimisticRollbackRequest::new()
    }

    fn default_instance() -> &'static PessimisticRollbackRequest {
        static mut instance: ::protobuf::lazy::Lazy<PessimisticRollbackRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PessimisticRollbackRequest,
        };
        unsafe {
            instance.get(PessimisticRollbackRequest::new)
        }
    }
}

impl ::protobuf::Clear for PessimisticRollbackRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.start_version = 0;
        self.for_update_ts = 0;
        self.keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for PessimisticRollbackRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.start_version, "start_version", buf);
        ::protobuf::PbPrint::fmt(&self.for_update_ts, "for_update_ts", buf);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for PessimisticRollbackRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_version, "start_version", &mut s);
        ::protobuf::PbPrint::fmt(&self.for_update_ts, "for_update_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for PessimisticRollbackRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PessimisticRollbackResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub errors: ::protobuf::RepeatedField<KeyError>,
    pub exec_details_v2: ::protobuf::SingularPtrField<ExecDetailsV2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PessimisticRollbackResponse {
    fn default() -> &'a PessimisticRollbackResponse {
        <PessimisticRollbackResponse as ::protobuf::Message>::default_instance()
    }
}

impl PessimisticRollbackResponse {
    pub fn new() -> PessimisticRollbackResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // repeated .kvrpcpb.KeyError errors = 2;


    pub fn get_errors(&self) -> &[KeyError] {
        &self.errors
    }
    pub fn clear_errors(&mut self) {
        self.errors.clear();
    }

    // Param is passed by value, moved
    pub fn set_errors(&mut self, v: ::protobuf::RepeatedField<KeyError>) {
        self.errors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_errors(&mut self) -> &mut ::protobuf::RepeatedField<KeyError> {
        &mut self.errors
    }

    // Take field
    pub fn take_errors(&mut self) -> ::protobuf::RepeatedField<KeyError> {
        ::std::mem::replace(&mut self.errors, ::protobuf::RepeatedField::new())
    }

    // .kvrpcpb.ExecDetailsV2 exec_details_v2 = 3;


    pub fn get_exec_details_v2(&self) -> &ExecDetailsV2 {
        self.exec_details_v2.as_ref().unwrap_or_else(|| ExecDetailsV2::default_instance())
    }
    pub fn clear_exec_details_v2(&mut self) {
        self.exec_details_v2.clear();
    }

    pub fn has_exec_details_v2(&self) -> bool {
        self.exec_details_v2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exec_details_v2(&mut self, v: ExecDetailsV2) {
        self.exec_details_v2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_details_v2(&mut self) -> &mut ExecDetailsV2 {
        if self.exec_details_v2.is_none() {
            self.exec_details_v2.set_default();
        }
        self.exec_details_v2.as_mut().unwrap()
    }

    // Take field
    pub fn take_exec_details_v2(&mut self) -> ExecDetailsV2 {
        self.exec_details_v2.take().unwrap_or_else(|| ExecDetailsV2::new())
    }
}

impl ::protobuf::Message for PessimisticRollbackResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.errors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exec_details_v2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.errors)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exec_details_v2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.errors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.errors {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PessimisticRollbackResponse {
        PessimisticRollbackResponse::new()
    }

    fn default_instance() -> &'static PessimisticRollbackResponse {
        static mut instance: ::protobuf::lazy::Lazy<PessimisticRollbackResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PessimisticRollbackResponse,
        };
        unsafe {
            instance.get(PessimisticRollbackResponse::new)
        }
    }
}

impl ::protobuf::Clear for PessimisticRollbackResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.errors.clear();
        self.exec_details_v2.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for PessimisticRollbackResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.errors, "errors", buf);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for PessimisticRollbackResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.errors, "errors", &mut s);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for PessimisticRollbackResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TxnHeartBeatRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub primary_lock: ::std::vec::Vec<u8>,
    pub start_version: u64,
    pub advise_lock_ttl: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxnHeartBeatRequest {
    fn default() -> &'a TxnHeartBeatRequest {
        <TxnHeartBeatRequest as ::protobuf::Message>::default_instance()
    }
}

impl TxnHeartBeatRequest {
    pub fn new() -> TxnHeartBeatRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // bytes primary_lock = 2;


    pub fn get_primary_lock(&self) -> &[u8] {
        &self.primary_lock
    }
    pub fn clear_primary_lock(&mut self) {
        self.primary_lock.clear();
    }

    // Param is passed by value, moved
    pub fn set_primary_lock(&mut self, v: ::std::vec::Vec<u8>) {
        self.primary_lock = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary_lock(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.primary_lock
    }

    // Take field
    pub fn take_primary_lock(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.primary_lock, ::std::vec::Vec::new())
    }

    // uint64 start_version = 3;


    pub fn get_start_version(&self) -> u64 {
        self.start_version
    }
    pub fn clear_start_version(&mut self) {
        self.start_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_version(&mut self, v: u64) {
        self.start_version = v;
    }

    // uint64 advise_lock_ttl = 4;


    pub fn get_advise_lock_ttl(&self) -> u64 {
        self.advise_lock_ttl
    }
    pub fn clear_advise_lock_ttl(&mut self) {
        self.advise_lock_ttl = 0;
    }

    // Param is passed by value, moved
    pub fn set_advise_lock_ttl(&mut self, v: u64) {
        self.advise_lock_ttl = v;
    }
}

impl ::protobuf::Message for TxnHeartBeatRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.primary_lock)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_version = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.advise_lock_ttl = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.primary_lock.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.primary_lock);
        }
        if self.start_version != 0 {
            my_size += ::protobuf::rt::value_size(3, self.start_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.advise_lock_ttl != 0 {
            my_size += ::protobuf::rt::value_size(4, self.advise_lock_ttl, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.primary_lock.is_empty() {
            os.write_bytes(2, &self.primary_lock)?;
        }
        if self.start_version != 0 {
            os.write_uint64(3, self.start_version)?;
        }
        if self.advise_lock_ttl != 0 {
            os.write_uint64(4, self.advise_lock_ttl)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxnHeartBeatRequest {
        TxnHeartBeatRequest::new()
    }

    fn default_instance() -> &'static TxnHeartBeatRequest {
        static mut instance: ::protobuf::lazy::Lazy<TxnHeartBeatRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TxnHeartBeatRequest,
        };
        unsafe {
            instance.get(TxnHeartBeatRequest::new)
        }
    }
}

impl ::protobuf::Clear for TxnHeartBeatRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.primary_lock.clear();
        self.start_version = 0;
        self.advise_lock_ttl = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for TxnHeartBeatRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.primary_lock, "primary_lock", buf);
        ::protobuf::PbPrint::fmt(&self.start_version, "start_version", buf);
        ::protobuf::PbPrint::fmt(&self.advise_lock_ttl, "advise_lock_ttl", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for TxnHeartBeatRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.primary_lock, "primary_lock", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_version, "start_version", &mut s);
        ::protobuf::PbPrint::fmt(&self.advise_lock_ttl, "advise_lock_ttl", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxnHeartBeatRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TxnHeartBeatResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::protobuf::SingularPtrField<KeyError>,
    pub lock_ttl: u64,
    pub exec_details_v2: ::protobuf::SingularPtrField<ExecDetailsV2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxnHeartBeatResponse {
    fn default() -> &'a TxnHeartBeatResponse {
        <TxnHeartBeatResponse as ::protobuf::Message>::default_instance()
    }
}

impl TxnHeartBeatResponse {
    pub fn new() -> TxnHeartBeatResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // .kvrpcpb.KeyError error = 2;


    pub fn get_error(&self) -> &KeyError {
        self.error.as_ref().unwrap_or_else(|| KeyError::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: KeyError) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut KeyError {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> KeyError {
        self.error.take().unwrap_or_else(|| KeyError::new())
    }

    // uint64 lock_ttl = 3;


    pub fn get_lock_ttl(&self) -> u64 {
        self.lock_ttl
    }
    pub fn clear_lock_ttl(&mut self) {
        self.lock_ttl = 0;
    }

    // Param is passed by value, moved
    pub fn set_lock_ttl(&mut self, v: u64) {
        self.lock_ttl = v;
    }

    // .kvrpcpb.ExecDetailsV2 exec_details_v2 = 4;


    pub fn get_exec_details_v2(&self) -> &ExecDetailsV2 {
        self.exec_details_v2.as_ref().unwrap_or_else(|| ExecDetailsV2::default_instance())
    }
    pub fn clear_exec_details_v2(&mut self) {
        self.exec_details_v2.clear();
    }

    pub fn has_exec_details_v2(&self) -> bool {
        self.exec_details_v2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exec_details_v2(&mut self, v: ExecDetailsV2) {
        self.exec_details_v2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_details_v2(&mut self) -> &mut ExecDetailsV2 {
        if self.exec_details_v2.is_none() {
            self.exec_details_v2.set_default();
        }
        self.exec_details_v2.as_mut().unwrap()
    }

    // Take field
    pub fn take_exec_details_v2(&mut self) -> ExecDetailsV2 {
        self.exec_details_v2.take().unwrap_or_else(|| ExecDetailsV2::new())
    }
}

impl ::protobuf::Message for TxnHeartBeatResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exec_details_v2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lock_ttl = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exec_details_v2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.lock_ttl != 0 {
            my_size += ::protobuf::rt::value_size(3, self.lock_ttl, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.lock_ttl != 0 {
            os.write_uint64(3, self.lock_ttl)?;
        }
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxnHeartBeatResponse {
        TxnHeartBeatResponse::new()
    }

    fn default_instance() -> &'static TxnHeartBeatResponse {
        static mut instance: ::protobuf::lazy::Lazy<TxnHeartBeatResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TxnHeartBeatResponse,
        };
        unsafe {
            instance.get(TxnHeartBeatResponse::new)
        }
    }
}

impl ::protobuf::Clear for TxnHeartBeatResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.lock_ttl = 0;
        self.exec_details_v2.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for TxnHeartBeatResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.lock_ttl, "lock_ttl", buf);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for TxnHeartBeatResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.lock_ttl, "lock_ttl", &mut s);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxnHeartBeatResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckTxnStatusRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub primary_key: ::std::vec::Vec<u8>,
    pub lock_ts: u64,
    pub caller_start_ts: u64,
    pub current_ts: u64,
    pub rollback_if_not_exist: bool,
    pub force_sync_commit: bool,
    pub resolving_pessimistic_lock: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckTxnStatusRequest {
    fn default() -> &'a CheckTxnStatusRequest {
        <CheckTxnStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl CheckTxnStatusRequest {
    pub fn new() -> CheckTxnStatusRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // bytes primary_key = 2;


    pub fn get_primary_key(&self) -> &[u8] {
        &self.primary_key
    }
    pub fn clear_primary_key(&mut self) {
        self.primary_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_primary_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.primary_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.primary_key
    }

    // Take field
    pub fn take_primary_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.primary_key, ::std::vec::Vec::new())
    }

    // uint64 lock_ts = 3;


    pub fn get_lock_ts(&self) -> u64 {
        self.lock_ts
    }
    pub fn clear_lock_ts(&mut self) {
        self.lock_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_lock_ts(&mut self, v: u64) {
        self.lock_ts = v;
    }

    // uint64 caller_start_ts = 4;


    pub fn get_caller_start_ts(&self) -> u64 {
        self.caller_start_ts
    }
    pub fn clear_caller_start_ts(&mut self) {
        self.caller_start_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_caller_start_ts(&mut self, v: u64) {
        self.caller_start_ts = v;
    }

    // uint64 current_ts = 5;


    pub fn get_current_ts(&self) -> u64 {
        self.current_ts
    }
    pub fn clear_current_ts(&mut self) {
        self.current_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_current_ts(&mut self, v: u64) {
        self.current_ts = v;
    }

    // bool rollback_if_not_exist = 6;


    pub fn get_rollback_if_not_exist(&self) -> bool {
        self.rollback_if_not_exist
    }
    pub fn clear_rollback_if_not_exist(&mut self) {
        self.rollback_if_not_exist = false;
    }

    // Param is passed by value, moved
    pub fn set_rollback_if_not_exist(&mut self, v: bool) {
        self.rollback_if_not_exist = v;
    }

    // bool force_sync_commit = 7;


    pub fn get_force_sync_commit(&self) -> bool {
        self.force_sync_commit
    }
    pub fn clear_force_sync_commit(&mut self) {
        self.force_sync_commit = false;
    }

    // Param is passed by value, moved
    pub fn set_force_sync_commit(&mut self, v: bool) {
        self.force_sync_commit = v;
    }

    // bool resolving_pessimistic_lock = 8;


    pub fn get_resolving_pessimistic_lock(&self) -> bool {
        self.resolving_pessimistic_lock
    }
    pub fn clear_resolving_pessimistic_lock(&mut self) {
        self.resolving_pessimistic_lock = false;
    }

    // Param is passed by value, moved
    pub fn set_resolving_pessimistic_lock(&mut self, v: bool) {
        self.resolving_pessimistic_lock = v;
    }
}

impl ::protobuf::Message for CheckTxnStatusRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.primary_key)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lock_ts = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.caller_start_ts = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.current_ts = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.rollback_if_not_exist = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_sync_commit = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.resolving_pessimistic_lock = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.primary_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.primary_key);
        }
        if self.lock_ts != 0 {
            my_size += ::protobuf::rt::value_size(3, self.lock_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.caller_start_ts != 0 {
            my_size += ::protobuf::rt::value_size(4, self.caller_start_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.current_ts != 0 {
            my_size += ::protobuf::rt::value_size(5, self.current_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rollback_if_not_exist != false {
            my_size += 2;
        }
        if self.force_sync_commit != false {
            my_size += 2;
        }
        if self.resolving_pessimistic_lock != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.primary_key.is_empty() {
            os.write_bytes(2, &self.primary_key)?;
        }
        if self.lock_ts != 0 {
            os.write_uint64(3, self.lock_ts)?;
        }
        if self.caller_start_ts != 0 {
            os.write_uint64(4, self.caller_start_ts)?;
        }
        if self.current_ts != 0 {
            os.write_uint64(5, self.current_ts)?;
        }
        if self.rollback_if_not_exist != false {
            os.write_bool(6, self.rollback_if_not_exist)?;
        }
        if self.force_sync_commit != false {
            os.write_bool(7, self.force_sync_commit)?;
        }
        if self.resolving_pessimistic_lock != false {
            os.write_bool(8, self.resolving_pessimistic_lock)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckTxnStatusRequest {
        CheckTxnStatusRequest::new()
    }

    fn default_instance() -> &'static CheckTxnStatusRequest {
        static mut instance: ::protobuf::lazy::Lazy<CheckTxnStatusRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckTxnStatusRequest,
        };
        unsafe {
            instance.get(CheckTxnStatusRequest::new)
        }
    }
}

impl ::protobuf::Clear for CheckTxnStatusRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.primary_key.clear();
        self.lock_ts = 0;
        self.caller_start_ts = 0;
        self.current_ts = 0;
        self.rollback_if_not_exist = false;
        self.force_sync_commit = false;
        self.resolving_pessimistic_lock = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CheckTxnStatusRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.primary_key, "primary_key", buf);
        ::protobuf::PbPrint::fmt(&self.lock_ts, "lock_ts", buf);
        ::protobuf::PbPrint::fmt(&self.caller_start_ts, "caller_start_ts", buf);
        ::protobuf::PbPrint::fmt(&self.current_ts, "current_ts", buf);
        ::protobuf::PbPrint::fmt(&self.rollback_if_not_exist, "rollback_if_not_exist", buf);
        ::protobuf::PbPrint::fmt(&self.force_sync_commit, "force_sync_commit", buf);
        ::protobuf::PbPrint::fmt(&self.resolving_pessimistic_lock, "resolving_pessimistic_lock", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for CheckTxnStatusRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.primary_key, "primary_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.lock_ts, "lock_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.caller_start_ts, "caller_start_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.current_ts, "current_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.rollback_if_not_exist, "rollback_if_not_exist", &mut s);
        ::protobuf::PbPrint::fmt(&self.force_sync_commit, "force_sync_commit", &mut s);
        ::protobuf::PbPrint::fmt(&self.resolving_pessimistic_lock, "resolving_pessimistic_lock", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckTxnStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckTxnStatusResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::protobuf::SingularPtrField<KeyError>,
    pub lock_ttl: u64,
    pub commit_version: u64,
    pub action: Action,
    pub lock_info: ::protobuf::SingularPtrField<LockInfo>,
    pub exec_details_v2: ::protobuf::SingularPtrField<ExecDetailsV2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckTxnStatusResponse {
    fn default() -> &'a CheckTxnStatusResponse {
        <CheckTxnStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl CheckTxnStatusResponse {
    pub fn new() -> CheckTxnStatusResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // .kvrpcpb.KeyError error = 2;


    pub fn get_error(&self) -> &KeyError {
        self.error.as_ref().unwrap_or_else(|| KeyError::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: KeyError) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut KeyError {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> KeyError {
        self.error.take().unwrap_or_else(|| KeyError::new())
    }

    // uint64 lock_ttl = 3;


    pub fn get_lock_ttl(&self) -> u64 {
        self.lock_ttl
    }
    pub fn clear_lock_ttl(&mut self) {
        self.lock_ttl = 0;
    }

    // Param is passed by value, moved
    pub fn set_lock_ttl(&mut self, v: u64) {
        self.lock_ttl = v;
    }

    // uint64 commit_version = 4;


    pub fn get_commit_version(&self) -> u64 {
        self.commit_version
    }
    pub fn clear_commit_version(&mut self) {
        self.commit_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_version(&mut self, v: u64) {
        self.commit_version = v;
    }

    // .kvrpcpb.Action action = 5;


    pub fn get_action(&self) -> Action {
        self.action
    }
    pub fn clear_action(&mut self) {
        self.action = Action::NoAction;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: Action) {
        self.action = v;
    }

    // .kvrpcpb.LockInfo lock_info = 6;


    pub fn get_lock_info(&self) -> &LockInfo {
        self.lock_info.as_ref().unwrap_or_else(|| LockInfo::default_instance())
    }
    pub fn clear_lock_info(&mut self) {
        self.lock_info.clear();
    }

    pub fn has_lock_info(&self) -> bool {
        self.lock_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lock_info(&mut self, v: LockInfo) {
        self.lock_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lock_info(&mut self) -> &mut LockInfo {
        if self.lock_info.is_none() {
            self.lock_info.set_default();
        }
        self.lock_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_lock_info(&mut self) -> LockInfo {
        self.lock_info.take().unwrap_or_else(|| LockInfo::new())
    }

    // .kvrpcpb.ExecDetailsV2 exec_details_v2 = 7;


    pub fn get_exec_details_v2(&self) -> &ExecDetailsV2 {
        self.exec_details_v2.as_ref().unwrap_or_else(|| ExecDetailsV2::default_instance())
    }
    pub fn clear_exec_details_v2(&mut self) {
        self.exec_details_v2.clear();
    }

    pub fn has_exec_details_v2(&self) -> bool {
        self.exec_details_v2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exec_details_v2(&mut self, v: ExecDetailsV2) {
        self.exec_details_v2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_details_v2(&mut self) -> &mut ExecDetailsV2 {
        if self.exec_details_v2.is_none() {
            self.exec_details_v2.set_default();
        }
        self.exec_details_v2.as_mut().unwrap()
    }

    // Take field
    pub fn take_exec_details_v2(&mut self) -> ExecDetailsV2 {
        self.exec_details_v2.take().unwrap_or_else(|| ExecDetailsV2::new())
    }
}

impl ::protobuf::Message for CheckTxnStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lock_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exec_details_v2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lock_ttl = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commit_version = tmp;
                },
                5 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.action = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lock_info)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exec_details_v2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.lock_ttl != 0 {
            my_size += ::protobuf::rt::value_size(3, self.lock_ttl, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_version != 0 {
            my_size += ::protobuf::rt::value_size(4, self.commit_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.action != Action::NoAction {
            my_size += ::protobuf::rt::enum_size(5, self.action);
        }
        if let Some(ref v) = self.lock_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.lock_ttl != 0 {
            os.write_uint64(3, self.lock_ttl)?;
        }
        if self.commit_version != 0 {
            os.write_uint64(4, self.commit_version)?;
        }
        if self.action != Action::NoAction {
            os.write_enum(5, self.action.value())?;
        }
        if let Some(ref v) = self.lock_info.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckTxnStatusResponse {
        CheckTxnStatusResponse::new()
    }

    fn default_instance() -> &'static CheckTxnStatusResponse {
        static mut instance: ::protobuf::lazy::Lazy<CheckTxnStatusResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckTxnStatusResponse,
        };
        unsafe {
            instance.get(CheckTxnStatusResponse::new)
        }
    }
}

impl ::protobuf::Clear for CheckTxnStatusResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.lock_ttl = 0;
        self.commit_version = 0;
        self.action = Action::NoAction;
        self.lock_info.clear();
        self.exec_details_v2.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CheckTxnStatusResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.lock_ttl, "lock_ttl", buf);
        ::protobuf::PbPrint::fmt(&self.commit_version, "commit_version", buf);
        ::protobuf::PbPrint::fmt(&self.action, "action", buf);
        ::protobuf::PbPrint::fmt(&self.lock_info, "lock_info", buf);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for CheckTxnStatusResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.lock_ttl, "lock_ttl", &mut s);
        ::protobuf::PbPrint::fmt(&self.commit_version, "commit_version", &mut s);
        ::protobuf::PbPrint::fmt(&self.action, "action", &mut s);
        ::protobuf::PbPrint::fmt(&self.lock_info, "lock_info", &mut s);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckTxnStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckSecondaryLocksRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub start_version: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckSecondaryLocksRequest {
    fn default() -> &'a CheckSecondaryLocksRequest {
        <CheckSecondaryLocksRequest as ::protobuf::Message>::default_instance()
    }
}

impl CheckSecondaryLocksRequest {
    pub fn new() -> CheckSecondaryLocksRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // repeated bytes keys = 2;


    pub fn get_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }

    // uint64 start_version = 3;


    pub fn get_start_version(&self) -> u64 {
        self.start_version
    }
    pub fn clear_start_version(&mut self) {
        self.start_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_version(&mut self, v: u64) {
        self.start_version = v;
    }
}

impl ::protobuf::Message for CheckSecondaryLocksRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.keys)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_version = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.keys {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if self.start_version != 0 {
            my_size += ::protobuf::rt::value_size(3, self.start_version, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.keys {
            os.write_bytes(2, &v)?;
        };
        if self.start_version != 0 {
            os.write_uint64(3, self.start_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckSecondaryLocksRequest {
        CheckSecondaryLocksRequest::new()
    }

    fn default_instance() -> &'static CheckSecondaryLocksRequest {
        static mut instance: ::protobuf::lazy::Lazy<CheckSecondaryLocksRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckSecondaryLocksRequest,
        };
        unsafe {
            instance.get(CheckSecondaryLocksRequest::new)
        }
    }
}

impl ::protobuf::Clear for CheckSecondaryLocksRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.keys.clear();
        self.start_version = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CheckSecondaryLocksRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", buf);
        ::protobuf::PbPrint::fmt(&self.start_version, "start_version", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for CheckSecondaryLocksRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_version, "start_version", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckSecondaryLocksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckSecondaryLocksResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::protobuf::SingularPtrField<KeyError>,
    pub locks: ::protobuf::RepeatedField<LockInfo>,
    pub commit_ts: u64,
    pub exec_details_v2: ::protobuf::SingularPtrField<ExecDetailsV2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckSecondaryLocksResponse {
    fn default() -> &'a CheckSecondaryLocksResponse {
        <CheckSecondaryLocksResponse as ::protobuf::Message>::default_instance()
    }
}

impl CheckSecondaryLocksResponse {
    pub fn new() -> CheckSecondaryLocksResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // .kvrpcpb.KeyError error = 2;


    pub fn get_error(&self) -> &KeyError {
        self.error.as_ref().unwrap_or_else(|| KeyError::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: KeyError) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut KeyError {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> KeyError {
        self.error.take().unwrap_or_else(|| KeyError::new())
    }

    // repeated .kvrpcpb.LockInfo locks = 3;


    pub fn get_locks(&self) -> &[LockInfo] {
        &self.locks
    }
    pub fn clear_locks(&mut self) {
        self.locks.clear();
    }

    // Param is passed by value, moved
    pub fn set_locks(&mut self, v: ::protobuf::RepeatedField<LockInfo>) {
        self.locks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_locks(&mut self) -> &mut ::protobuf::RepeatedField<LockInfo> {
        &mut self.locks
    }

    // Take field
    pub fn take_locks(&mut self) -> ::protobuf::RepeatedField<LockInfo> {
        ::std::mem::replace(&mut self.locks, ::protobuf::RepeatedField::new())
    }

    // uint64 commit_ts = 4;


    pub fn get_commit_ts(&self) -> u64 {
        self.commit_ts
    }
    pub fn clear_commit_ts(&mut self) {
        self.commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_ts(&mut self, v: u64) {
        self.commit_ts = v;
    }

    // .kvrpcpb.ExecDetailsV2 exec_details_v2 = 5;


    pub fn get_exec_details_v2(&self) -> &ExecDetailsV2 {
        self.exec_details_v2.as_ref().unwrap_or_else(|| ExecDetailsV2::default_instance())
    }
    pub fn clear_exec_details_v2(&mut self) {
        self.exec_details_v2.clear();
    }

    pub fn has_exec_details_v2(&self) -> bool {
        self.exec_details_v2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exec_details_v2(&mut self, v: ExecDetailsV2) {
        self.exec_details_v2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_details_v2(&mut self) -> &mut ExecDetailsV2 {
        if self.exec_details_v2.is_none() {
            self.exec_details_v2.set_default();
        }
        self.exec_details_v2.as_mut().unwrap()
    }

    // Take field
    pub fn take_exec_details_v2(&mut self) -> ExecDetailsV2 {
        self.exec_details_v2.take().unwrap_or_else(|| ExecDetailsV2::new())
    }
}

impl ::protobuf::Message for CheckSecondaryLocksResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.locks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exec_details_v2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.locks)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commit_ts = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exec_details_v2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.locks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(4, self.commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.locks {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.commit_ts != 0 {
            os.write_uint64(4, self.commit_ts)?;
        }
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckSecondaryLocksResponse {
        CheckSecondaryLocksResponse::new()
    }

    fn default_instance() -> &'static CheckSecondaryLocksResponse {
        static mut instance: ::protobuf::lazy::Lazy<CheckSecondaryLocksResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckSecondaryLocksResponse,
        };
        unsafe {
            instance.get(CheckSecondaryLocksResponse::new)
        }
    }
}

impl ::protobuf::Clear for CheckSecondaryLocksResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.locks.clear();
        self.commit_ts = 0;
        self.exec_details_v2.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CheckSecondaryLocksResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.locks, "locks", buf);
        ::protobuf::PbPrint::fmt(&self.commit_ts, "commit_ts", buf);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for CheckSecondaryLocksResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.locks, "locks", &mut s);
        ::protobuf::PbPrint::fmt(&self.commit_ts, "commit_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckSecondaryLocksResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommitRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub start_version: u64,
    pub keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub commit_version: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommitRequest {
    fn default() -> &'a CommitRequest {
        <CommitRequest as ::protobuf::Message>::default_instance()
    }
}

impl CommitRequest {
    pub fn new() -> CommitRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // uint64 start_version = 2;


    pub fn get_start_version(&self) -> u64 {
        self.start_version
    }
    pub fn clear_start_version(&mut self) {
        self.start_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_version(&mut self, v: u64) {
        self.start_version = v;
    }

    // repeated bytes keys = 3;


    pub fn get_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }

    // uint64 commit_version = 4;


    pub fn get_commit_version(&self) -> u64 {
        self.commit_version
    }
    pub fn clear_commit_version(&mut self) {
        self.commit_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_version(&mut self, v: u64) {
        self.commit_version = v;
    }
}

impl ::protobuf::Message for CommitRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_version = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.keys)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commit_version = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.start_version != 0 {
            my_size += ::protobuf::rt::value_size(2, self.start_version, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.keys {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        if self.commit_version != 0 {
            my_size += ::protobuf::rt::value_size(4, self.commit_version, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.start_version != 0 {
            os.write_uint64(2, self.start_version)?;
        }
        for v in &self.keys {
            os.write_bytes(3, &v)?;
        };
        if self.commit_version != 0 {
            os.write_uint64(4, self.commit_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitRequest {
        CommitRequest::new()
    }

    fn default_instance() -> &'static CommitRequest {
        static mut instance: ::protobuf::lazy::Lazy<CommitRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommitRequest,
        };
        unsafe {
            instance.get(CommitRequest::new)
        }
    }
}

impl ::protobuf::Clear for CommitRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.start_version = 0;
        self.keys.clear();
        self.commit_version = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CommitRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.start_version, "start_version", buf);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", buf);
        ::protobuf::PbPrint::fmt(&self.commit_version, "commit_version", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for CommitRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_version, "start_version", &mut s);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", &mut s);
        ::protobuf::PbPrint::fmt(&self.commit_version, "commit_version", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommitResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::protobuf::SingularPtrField<KeyError>,
    pub commit_version: u64,
    pub exec_details_v2: ::protobuf::SingularPtrField<ExecDetailsV2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommitResponse {
    fn default() -> &'a CommitResponse {
        <CommitResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommitResponse {
    pub fn new() -> CommitResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // .kvrpcpb.KeyError error = 2;


    pub fn get_error(&self) -> &KeyError {
        self.error.as_ref().unwrap_or_else(|| KeyError::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: KeyError) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut KeyError {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> KeyError {
        self.error.take().unwrap_or_else(|| KeyError::new())
    }

    // uint64 commit_version = 3;


    pub fn get_commit_version(&self) -> u64 {
        self.commit_version
    }
    pub fn clear_commit_version(&mut self) {
        self.commit_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_version(&mut self, v: u64) {
        self.commit_version = v;
    }

    // .kvrpcpb.ExecDetailsV2 exec_details_v2 = 4;


    pub fn get_exec_details_v2(&self) -> &ExecDetailsV2 {
        self.exec_details_v2.as_ref().unwrap_or_else(|| ExecDetailsV2::default_instance())
    }
    pub fn clear_exec_details_v2(&mut self) {
        self.exec_details_v2.clear();
    }

    pub fn has_exec_details_v2(&self) -> bool {
        self.exec_details_v2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exec_details_v2(&mut self, v: ExecDetailsV2) {
        self.exec_details_v2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_details_v2(&mut self) -> &mut ExecDetailsV2 {
        if self.exec_details_v2.is_none() {
            self.exec_details_v2.set_default();
        }
        self.exec_details_v2.as_mut().unwrap()
    }

    // Take field
    pub fn take_exec_details_v2(&mut self) -> ExecDetailsV2 {
        self.exec_details_v2.take().unwrap_or_else(|| ExecDetailsV2::new())
    }
}

impl ::protobuf::Message for CommitResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exec_details_v2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commit_version = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exec_details_v2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.commit_version != 0 {
            my_size += ::protobuf::rt::value_size(3, self.commit_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.commit_version != 0 {
            os.write_uint64(3, self.commit_version)?;
        }
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitResponse {
        CommitResponse::new()
    }

    fn default_instance() -> &'static CommitResponse {
        static mut instance: ::protobuf::lazy::Lazy<CommitResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommitResponse,
        };
        unsafe {
            instance.get(CommitResponse::new)
        }
    }
}

impl ::protobuf::Clear for CommitResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.commit_version = 0;
        self.exec_details_v2.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CommitResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.commit_version, "commit_version", buf);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for CommitResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.commit_version, "commit_version", &mut s);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImportRequest {
    // message fields
    pub mutations: ::protobuf::RepeatedField<Mutation>,
    pub commit_version: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImportRequest {
    fn default() -> &'a ImportRequest {
        <ImportRequest as ::protobuf::Message>::default_instance()
    }
}

impl ImportRequest {
    pub fn new() -> ImportRequest {
        ::std::default::Default::default()
    }

    // repeated .kvrpcpb.Mutation mutations = 1;


    pub fn get_mutations(&self) -> &[Mutation] {
        &self.mutations
    }
    pub fn clear_mutations(&mut self) {
        self.mutations.clear();
    }

    // Param is passed by value, moved
    pub fn set_mutations(&mut self, v: ::protobuf::RepeatedField<Mutation>) {
        self.mutations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mutations(&mut self) -> &mut ::protobuf::RepeatedField<Mutation> {
        &mut self.mutations
    }

    // Take field
    pub fn take_mutations(&mut self) -> ::protobuf::RepeatedField<Mutation> {
        ::std::mem::replace(&mut self.mutations, ::protobuf::RepeatedField::new())
    }

    // uint64 commit_version = 2;


    pub fn get_commit_version(&self) -> u64 {
        self.commit_version
    }
    pub fn clear_commit_version(&mut self) {
        self.commit_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_version(&mut self, v: u64) {
        self.commit_version = v;
    }
}

impl ::protobuf::Message for ImportRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.mutations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mutations)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commit_version = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.mutations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.commit_version != 0 {
            my_size += ::protobuf::rt::value_size(2, self.commit_version, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.mutations {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.commit_version != 0 {
            os.write_uint64(2, self.commit_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImportRequest {
        ImportRequest::new()
    }

    fn default_instance() -> &'static ImportRequest {
        static mut instance: ::protobuf::lazy::Lazy<ImportRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ImportRequest,
        };
        unsafe {
            instance.get(ImportRequest::new)
        }
    }
}

impl ::protobuf::Clear for ImportRequest {
    fn clear(&mut self) {
        self.mutations.clear();
        self.commit_version = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ImportRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.mutations, "mutations", buf);
        ::protobuf::PbPrint::fmt(&self.commit_version, "commit_version", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ImportRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.mutations, "mutations", &mut s);
        ::protobuf::PbPrint::fmt(&self.commit_version, "commit_version", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImportRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImportResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImportResponse {
    fn default() -> &'a ImportResponse {
        <ImportResponse as ::protobuf::Message>::default_instance()
    }
}

impl ImportResponse {
    pub fn new() -> ImportResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ImportResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImportResponse {
        ImportResponse::new()
    }

    fn default_instance() -> &'static ImportResponse {
        static mut instance: ::protobuf::lazy::Lazy<ImportResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ImportResponse,
        };
        unsafe {
            instance.get(ImportResponse::new)
        }
    }
}

impl ::protobuf::Clear for ImportResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ImportResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ImportResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImportResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CleanupRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub key: ::std::vec::Vec<u8>,
    pub start_version: u64,
    pub current_ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CleanupRequest {
    fn default() -> &'a CleanupRequest {
        <CleanupRequest as ::protobuf::Message>::default_instance()
    }
}

impl CleanupRequest {
    pub fn new() -> CleanupRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // bytes key = 2;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // uint64 start_version = 3;


    pub fn get_start_version(&self) -> u64 {
        self.start_version
    }
    pub fn clear_start_version(&mut self) {
        self.start_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_version(&mut self, v: u64) {
        self.start_version = v;
    }

    // uint64 current_ts = 4;


    pub fn get_current_ts(&self) -> u64 {
        self.current_ts
    }
    pub fn clear_current_ts(&mut self) {
        self.current_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_current_ts(&mut self, v: u64) {
        self.current_ts = v;
    }
}

impl ::protobuf::Message for CleanupRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_version = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.current_ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.key);
        }
        if self.start_version != 0 {
            my_size += ::protobuf::rt::value_size(3, self.start_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.current_ts != 0 {
            my_size += ::protobuf::rt::value_size(4, self.current_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(2, &self.key)?;
        }
        if self.start_version != 0 {
            os.write_uint64(3, self.start_version)?;
        }
        if self.current_ts != 0 {
            os.write_uint64(4, self.current_ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CleanupRequest {
        CleanupRequest::new()
    }

    fn default_instance() -> &'static CleanupRequest {
        static mut instance: ::protobuf::lazy::Lazy<CleanupRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CleanupRequest,
        };
        unsafe {
            instance.get(CleanupRequest::new)
        }
    }
}

impl ::protobuf::Clear for CleanupRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.key.clear();
        self.start_version = 0;
        self.current_ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CleanupRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        ::protobuf::PbPrint::fmt(&self.start_version, "start_version", buf);
        ::protobuf::PbPrint::fmt(&self.current_ts, "current_ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for CleanupRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_version, "start_version", &mut s);
        ::protobuf::PbPrint::fmt(&self.current_ts, "current_ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for CleanupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CleanupResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::protobuf::SingularPtrField<KeyError>,
    pub commit_version: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CleanupResponse {
    fn default() -> &'a CleanupResponse {
        <CleanupResponse as ::protobuf::Message>::default_instance()
    }
}

impl CleanupResponse {
    pub fn new() -> CleanupResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // .kvrpcpb.KeyError error = 2;


    pub fn get_error(&self) -> &KeyError {
        self.error.as_ref().unwrap_or_else(|| KeyError::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: KeyError) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut KeyError {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> KeyError {
        self.error.take().unwrap_or_else(|| KeyError::new())
    }

    // uint64 commit_version = 3;


    pub fn get_commit_version(&self) -> u64 {
        self.commit_version
    }
    pub fn clear_commit_version(&mut self) {
        self.commit_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_version(&mut self, v: u64) {
        self.commit_version = v;
    }
}

impl ::protobuf::Message for CleanupResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commit_version = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.commit_version != 0 {
            my_size += ::protobuf::rt::value_size(3, self.commit_version, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.commit_version != 0 {
            os.write_uint64(3, self.commit_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CleanupResponse {
        CleanupResponse::new()
    }

    fn default_instance() -> &'static CleanupResponse {
        static mut instance: ::protobuf::lazy::Lazy<CleanupResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CleanupResponse,
        };
        unsafe {
            instance.get(CleanupResponse::new)
        }
    }
}

impl ::protobuf::Clear for CleanupResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.commit_version = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CleanupResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.commit_version, "commit_version", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for CleanupResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.commit_version, "commit_version", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for CleanupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchGetRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub version: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchGetRequest {
    fn default() -> &'a BatchGetRequest {
        <BatchGetRequest as ::protobuf::Message>::default_instance()
    }
}

impl BatchGetRequest {
    pub fn new() -> BatchGetRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // repeated bytes keys = 2;


    pub fn get_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }

    // uint64 version = 3;


    pub fn get_version(&self) -> u64 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = v;
    }
}

impl ::protobuf::Message for BatchGetRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.keys)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.version = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.keys {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(3, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.keys {
            os.write_bytes(2, &v)?;
        };
        if self.version != 0 {
            os.write_uint64(3, self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchGetRequest {
        BatchGetRequest::new()
    }

    fn default_instance() -> &'static BatchGetRequest {
        static mut instance: ::protobuf::lazy::Lazy<BatchGetRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BatchGetRequest,
        };
        unsafe {
            instance.get(BatchGetRequest::new)
        }
    }
}

impl ::protobuf::Clear for BatchGetRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.keys.clear();
        self.version = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for BatchGetRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", buf);
        ::protobuf::PbPrint::fmt(&self.version, "version", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for BatchGetRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", &mut s);
        ::protobuf::PbPrint::fmt(&self.version, "version", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchGetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchGetResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub pairs: ::protobuf::RepeatedField<KvPair>,
    pub exec_details_v2: ::protobuf::SingularPtrField<ExecDetailsV2>,
    pub error: ::protobuf::SingularPtrField<KeyError>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchGetResponse {
    fn default() -> &'a BatchGetResponse {
        <BatchGetResponse as ::protobuf::Message>::default_instance()
    }
}

impl BatchGetResponse {
    pub fn new() -> BatchGetResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // repeated .kvrpcpb.KvPair pairs = 2;


    pub fn get_pairs(&self) -> &[KvPair] {
        &self.pairs
    }
    pub fn clear_pairs(&mut self) {
        self.pairs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pairs(&mut self, v: ::protobuf::RepeatedField<KvPair>) {
        self.pairs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pairs(&mut self) -> &mut ::protobuf::RepeatedField<KvPair> {
        &mut self.pairs
    }

    // Take field
    pub fn take_pairs(&mut self) -> ::protobuf::RepeatedField<KvPair> {
        ::std::mem::replace(&mut self.pairs, ::protobuf::RepeatedField::new())
    }

    // .kvrpcpb.ExecDetailsV2 exec_details_v2 = 4;


    pub fn get_exec_details_v2(&self) -> &ExecDetailsV2 {
        self.exec_details_v2.as_ref().unwrap_or_else(|| ExecDetailsV2::default_instance())
    }
    pub fn clear_exec_details_v2(&mut self) {
        self.exec_details_v2.clear();
    }

    pub fn has_exec_details_v2(&self) -> bool {
        self.exec_details_v2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exec_details_v2(&mut self, v: ExecDetailsV2) {
        self.exec_details_v2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_details_v2(&mut self) -> &mut ExecDetailsV2 {
        if self.exec_details_v2.is_none() {
            self.exec_details_v2.set_default();
        }
        self.exec_details_v2.as_mut().unwrap()
    }

    // Take field
    pub fn take_exec_details_v2(&mut self) -> ExecDetailsV2 {
        self.exec_details_v2.take().unwrap_or_else(|| ExecDetailsV2::new())
    }

    // .kvrpcpb.KeyError error = 5;


    pub fn get_error(&self) -> &KeyError {
        self.error.as_ref().unwrap_or_else(|| KeyError::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: KeyError) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut KeyError {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> KeyError {
        self.error.take().unwrap_or_else(|| KeyError::new())
    }
}

impl ::protobuf::Message for BatchGetResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pairs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exec_details_v2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pairs)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exec_details_v2)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.pairs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchGetResponse {
        BatchGetResponse::new()
    }

    fn default_instance() -> &'static BatchGetResponse {
        static mut instance: ::protobuf::lazy::Lazy<BatchGetResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BatchGetResponse,
        };
        unsafe {
            instance.get(BatchGetResponse::new)
        }
    }
}

impl ::protobuf::Clear for BatchGetResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.pairs.clear();
        self.exec_details_v2.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for BatchGetResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.pairs, "pairs", buf);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for BatchGetResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.pairs, "pairs", &mut s);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchGetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchRollbackRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub start_version: u64,
    pub keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchRollbackRequest {
    fn default() -> &'a BatchRollbackRequest {
        <BatchRollbackRequest as ::protobuf::Message>::default_instance()
    }
}

impl BatchRollbackRequest {
    pub fn new() -> BatchRollbackRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // uint64 start_version = 2;


    pub fn get_start_version(&self) -> u64 {
        self.start_version
    }
    pub fn clear_start_version(&mut self) {
        self.start_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_version(&mut self, v: u64) {
        self.start_version = v;
    }

    // repeated bytes keys = 3;


    pub fn get_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BatchRollbackRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_version = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.start_version != 0 {
            my_size += ::protobuf::rt::value_size(2, self.start_version, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.keys {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.start_version != 0 {
            os.write_uint64(2, self.start_version)?;
        }
        for v in &self.keys {
            os.write_bytes(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchRollbackRequest {
        BatchRollbackRequest::new()
    }

    fn default_instance() -> &'static BatchRollbackRequest {
        static mut instance: ::protobuf::lazy::Lazy<BatchRollbackRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BatchRollbackRequest,
        };
        unsafe {
            instance.get(BatchRollbackRequest::new)
        }
    }
}

impl ::protobuf::Clear for BatchRollbackRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.start_version = 0;
        self.keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for BatchRollbackRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.start_version, "start_version", buf);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for BatchRollbackRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_version, "start_version", &mut s);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchRollbackRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchRollbackResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::protobuf::SingularPtrField<KeyError>,
    pub exec_details_v2: ::protobuf::SingularPtrField<ExecDetailsV2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchRollbackResponse {
    fn default() -> &'a BatchRollbackResponse {
        <BatchRollbackResponse as ::protobuf::Message>::default_instance()
    }
}

impl BatchRollbackResponse {
    pub fn new() -> BatchRollbackResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // .kvrpcpb.KeyError error = 2;


    pub fn get_error(&self) -> &KeyError {
        self.error.as_ref().unwrap_or_else(|| KeyError::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: KeyError) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut KeyError {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> KeyError {
        self.error.take().unwrap_or_else(|| KeyError::new())
    }

    // .kvrpcpb.ExecDetailsV2 exec_details_v2 = 3;


    pub fn get_exec_details_v2(&self) -> &ExecDetailsV2 {
        self.exec_details_v2.as_ref().unwrap_or_else(|| ExecDetailsV2::default_instance())
    }
    pub fn clear_exec_details_v2(&mut self) {
        self.exec_details_v2.clear();
    }

    pub fn has_exec_details_v2(&self) -> bool {
        self.exec_details_v2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exec_details_v2(&mut self, v: ExecDetailsV2) {
        self.exec_details_v2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_details_v2(&mut self) -> &mut ExecDetailsV2 {
        if self.exec_details_v2.is_none() {
            self.exec_details_v2.set_default();
        }
        self.exec_details_v2.as_mut().unwrap()
    }

    // Take field
    pub fn take_exec_details_v2(&mut self) -> ExecDetailsV2 {
        self.exec_details_v2.take().unwrap_or_else(|| ExecDetailsV2::new())
    }
}

impl ::protobuf::Message for BatchRollbackResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exec_details_v2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exec_details_v2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchRollbackResponse {
        BatchRollbackResponse::new()
    }

    fn default_instance() -> &'static BatchRollbackResponse {
        static mut instance: ::protobuf::lazy::Lazy<BatchRollbackResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BatchRollbackResponse,
        };
        unsafe {
            instance.get(BatchRollbackResponse::new)
        }
    }
}

impl ::protobuf::Clear for BatchRollbackResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.exec_details_v2.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for BatchRollbackResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for BatchRollbackResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchRollbackResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScanLockRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub max_version: u64,
    pub start_key: ::std::vec::Vec<u8>,
    pub limit: u32,
    pub end_key: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScanLockRequest {
    fn default() -> &'a ScanLockRequest {
        <ScanLockRequest as ::protobuf::Message>::default_instance()
    }
}

impl ScanLockRequest {
    pub fn new() -> ScanLockRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // uint64 max_version = 2;


    pub fn get_max_version(&self) -> u64 {
        self.max_version
    }
    pub fn clear_max_version(&mut self) {
        self.max_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_version(&mut self, v: u64) {
        self.max_version = v;
    }

    // bytes start_key = 3;


    pub fn get_start_key(&self) -> &[u8] {
        &self.start_key
    }
    pub fn clear_start_key(&mut self) {
        self.start_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.start_key
    }

    // Take field
    pub fn take_start_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.start_key, ::std::vec::Vec::new())
    }

    // uint32 limit = 4;


    pub fn get_limit(&self) -> u32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u32) {
        self.limit = v;
    }

    // bytes end_key = 5;


    pub fn get_end_key(&self) -> &[u8] {
        &self.end_key
    }
    pub fn clear_end_key(&mut self) {
        self.end_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_end_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.end_key
    }

    // Take field
    pub fn take_end_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.end_key, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ScanLockRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_version = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.start_key)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.limit = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.end_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.max_version != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.start_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.start_key);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.end_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.end_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.max_version != 0 {
            os.write_uint64(2, self.max_version)?;
        }
        if !self.start_key.is_empty() {
            os.write_bytes(3, &self.start_key)?;
        }
        if self.limit != 0 {
            os.write_uint32(4, self.limit)?;
        }
        if !self.end_key.is_empty() {
            os.write_bytes(5, &self.end_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScanLockRequest {
        ScanLockRequest::new()
    }

    fn default_instance() -> &'static ScanLockRequest {
        static mut instance: ::protobuf::lazy::Lazy<ScanLockRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScanLockRequest,
        };
        unsafe {
            instance.get(ScanLockRequest::new)
        }
    }
}

impl ::protobuf::Clear for ScanLockRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.max_version = 0;
        self.start_key.clear();
        self.limit = 0;
        self.end_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ScanLockRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.max_version, "max_version", buf);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", buf);
        ::protobuf::PbPrint::fmt(&self.limit, "limit", buf);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ScanLockRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.max_version, "max_version", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.limit, "limit", &mut s);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScanLockRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScanLockResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::protobuf::SingularPtrField<KeyError>,
    pub locks: ::protobuf::RepeatedField<LockInfo>,
    pub exec_details_v2: ::protobuf::SingularPtrField<ExecDetailsV2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScanLockResponse {
    fn default() -> &'a ScanLockResponse {
        <ScanLockResponse as ::protobuf::Message>::default_instance()
    }
}

impl ScanLockResponse {
    pub fn new() -> ScanLockResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // .kvrpcpb.KeyError error = 2;


    pub fn get_error(&self) -> &KeyError {
        self.error.as_ref().unwrap_or_else(|| KeyError::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: KeyError) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut KeyError {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> KeyError {
        self.error.take().unwrap_or_else(|| KeyError::new())
    }

    // repeated .kvrpcpb.LockInfo locks = 3;


    pub fn get_locks(&self) -> &[LockInfo] {
        &self.locks
    }
    pub fn clear_locks(&mut self) {
        self.locks.clear();
    }

    // Param is passed by value, moved
    pub fn set_locks(&mut self, v: ::protobuf::RepeatedField<LockInfo>) {
        self.locks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_locks(&mut self) -> &mut ::protobuf::RepeatedField<LockInfo> {
        &mut self.locks
    }

    // Take field
    pub fn take_locks(&mut self) -> ::protobuf::RepeatedField<LockInfo> {
        ::std::mem::replace(&mut self.locks, ::protobuf::RepeatedField::new())
    }

    // .kvrpcpb.ExecDetailsV2 exec_details_v2 = 4;


    pub fn get_exec_details_v2(&self) -> &ExecDetailsV2 {
        self.exec_details_v2.as_ref().unwrap_or_else(|| ExecDetailsV2::default_instance())
    }
    pub fn clear_exec_details_v2(&mut self) {
        self.exec_details_v2.clear();
    }

    pub fn has_exec_details_v2(&self) -> bool {
        self.exec_details_v2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exec_details_v2(&mut self, v: ExecDetailsV2) {
        self.exec_details_v2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_details_v2(&mut self) -> &mut ExecDetailsV2 {
        if self.exec_details_v2.is_none() {
            self.exec_details_v2.set_default();
        }
        self.exec_details_v2.as_mut().unwrap()
    }

    // Take field
    pub fn take_exec_details_v2(&mut self) -> ExecDetailsV2 {
        self.exec_details_v2.take().unwrap_or_else(|| ExecDetailsV2::new())
    }
}

impl ::protobuf::Message for ScanLockResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.locks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exec_details_v2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.locks)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exec_details_v2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.locks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.locks {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScanLockResponse {
        ScanLockResponse::new()
    }

    fn default_instance() -> &'static ScanLockResponse {
        static mut instance: ::protobuf::lazy::Lazy<ScanLockResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScanLockResponse,
        };
        unsafe {
            instance.get(ScanLockResponse::new)
        }
    }
}

impl ::protobuf::Clear for ScanLockResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.locks.clear();
        self.exec_details_v2.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ScanLockResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.locks, "locks", buf);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ScanLockResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.locks, "locks", &mut s);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScanLockResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResolveLockRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub start_version: u64,
    pub commit_version: u64,
    pub txn_infos: ::protobuf::RepeatedField<TxnInfo>,
    pub keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResolveLockRequest {
    fn default() -> &'a ResolveLockRequest {
        <ResolveLockRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResolveLockRequest {
    pub fn new() -> ResolveLockRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // uint64 start_version = 2;


    pub fn get_start_version(&self) -> u64 {
        self.start_version
    }
    pub fn clear_start_version(&mut self) {
        self.start_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_version(&mut self, v: u64) {
        self.start_version = v;
    }

    // uint64 commit_version = 3;


    pub fn get_commit_version(&self) -> u64 {
        self.commit_version
    }
    pub fn clear_commit_version(&mut self) {
        self.commit_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_version(&mut self, v: u64) {
        self.commit_version = v;
    }

    // repeated .kvrpcpb.TxnInfo txn_infos = 4;


    pub fn get_txn_infos(&self) -> &[TxnInfo] {
        &self.txn_infos
    }
    pub fn clear_txn_infos(&mut self) {
        self.txn_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_txn_infos(&mut self, v: ::protobuf::RepeatedField<TxnInfo>) {
        self.txn_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_txn_infos(&mut self) -> &mut ::protobuf::RepeatedField<TxnInfo> {
        &mut self.txn_infos
    }

    // Take field
    pub fn take_txn_infos(&mut self) -> ::protobuf::RepeatedField<TxnInfo> {
        ::std::mem::replace(&mut self.txn_infos, ::protobuf::RepeatedField::new())
    }

    // repeated bytes keys = 5;


    pub fn get_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ResolveLockRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.txn_infos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_version = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commit_version = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.txn_infos)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.start_version != 0 {
            my_size += ::protobuf::rt::value_size(2, self.start_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_version != 0 {
            my_size += ::protobuf::rt::value_size(3, self.commit_version, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.txn_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.keys {
            my_size += ::protobuf::rt::bytes_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.start_version != 0 {
            os.write_uint64(2, self.start_version)?;
        }
        if self.commit_version != 0 {
            os.write_uint64(3, self.commit_version)?;
        }
        for v in &self.txn_infos {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.keys {
            os.write_bytes(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResolveLockRequest {
        ResolveLockRequest::new()
    }

    fn default_instance() -> &'static ResolveLockRequest {
        static mut instance: ::protobuf::lazy::Lazy<ResolveLockRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResolveLockRequest,
        };
        unsafe {
            instance.get(ResolveLockRequest::new)
        }
    }
}

impl ::protobuf::Clear for ResolveLockRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.start_version = 0;
        self.commit_version = 0;
        self.txn_infos.clear();
        self.keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ResolveLockRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.start_version, "start_version", buf);
        ::protobuf::PbPrint::fmt(&self.commit_version, "commit_version", buf);
        ::protobuf::PbPrint::fmt(&self.txn_infos, "txn_infos", buf);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ResolveLockRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_version, "start_version", &mut s);
        ::protobuf::PbPrint::fmt(&self.commit_version, "commit_version", &mut s);
        ::protobuf::PbPrint::fmt(&self.txn_infos, "txn_infos", &mut s);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResolveLockRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResolveLockResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::protobuf::SingularPtrField<KeyError>,
    pub exec_details_v2: ::protobuf::SingularPtrField<ExecDetailsV2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResolveLockResponse {
    fn default() -> &'a ResolveLockResponse {
        <ResolveLockResponse as ::protobuf::Message>::default_instance()
    }
}

impl ResolveLockResponse {
    pub fn new() -> ResolveLockResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // .kvrpcpb.KeyError error = 2;


    pub fn get_error(&self) -> &KeyError {
        self.error.as_ref().unwrap_or_else(|| KeyError::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: KeyError) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut KeyError {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> KeyError {
        self.error.take().unwrap_or_else(|| KeyError::new())
    }

    // .kvrpcpb.ExecDetailsV2 exec_details_v2 = 3;


    pub fn get_exec_details_v2(&self) -> &ExecDetailsV2 {
        self.exec_details_v2.as_ref().unwrap_or_else(|| ExecDetailsV2::default_instance())
    }
    pub fn clear_exec_details_v2(&mut self) {
        self.exec_details_v2.clear();
    }

    pub fn has_exec_details_v2(&self) -> bool {
        self.exec_details_v2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exec_details_v2(&mut self, v: ExecDetailsV2) {
        self.exec_details_v2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_details_v2(&mut self) -> &mut ExecDetailsV2 {
        if self.exec_details_v2.is_none() {
            self.exec_details_v2.set_default();
        }
        self.exec_details_v2.as_mut().unwrap()
    }

    // Take field
    pub fn take_exec_details_v2(&mut self) -> ExecDetailsV2 {
        self.exec_details_v2.take().unwrap_or_else(|| ExecDetailsV2::new())
    }
}

impl ::protobuf::Message for ResolveLockResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exec_details_v2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exec_details_v2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.exec_details_v2.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResolveLockResponse {
        ResolveLockResponse::new()
    }

    fn default_instance() -> &'static ResolveLockResponse {
        static mut instance: ::protobuf::lazy::Lazy<ResolveLockResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResolveLockResponse,
        };
        unsafe {
            instance.get(ResolveLockResponse::new)
        }
    }
}

impl ::protobuf::Clear for ResolveLockResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.exec_details_v2.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ResolveLockResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ResolveLockResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.exec_details_v2, "exec_details_v2", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResolveLockResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GcRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub safe_point: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GcRequest {
    fn default() -> &'a GcRequest {
        <GcRequest as ::protobuf::Message>::default_instance()
    }
}

impl GcRequest {
    pub fn new() -> GcRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // uint64 safe_point = 2;


    pub fn get_safe_point(&self) -> u64 {
        self.safe_point
    }
    pub fn clear_safe_point(&mut self) {
        self.safe_point = 0;
    }

    // Param is passed by value, moved
    pub fn set_safe_point(&mut self, v: u64) {
        self.safe_point = v;
    }
}

impl ::protobuf::Message for GcRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.safe_point = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.safe_point != 0 {
            my_size += ::protobuf::rt::value_size(2, self.safe_point, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.safe_point != 0 {
            os.write_uint64(2, self.safe_point)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GcRequest {
        GcRequest::new()
    }

    fn default_instance() -> &'static GcRequest {
        static mut instance: ::protobuf::lazy::Lazy<GcRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GcRequest,
        };
        unsafe {
            instance.get(GcRequest::new)
        }
    }
}

impl ::protobuf::Clear for GcRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.safe_point = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for GcRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.safe_point, "safe_point", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for GcRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.safe_point, "safe_point", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for GcRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GcResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::protobuf::SingularPtrField<KeyError>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GcResponse {
    fn default() -> &'a GcResponse {
        <GcResponse as ::protobuf::Message>::default_instance()
    }
}

impl GcResponse {
    pub fn new() -> GcResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // .kvrpcpb.KeyError error = 2;


    pub fn get_error(&self) -> &KeyError {
        self.error.as_ref().unwrap_or_else(|| KeyError::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: KeyError) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut KeyError {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> KeyError {
        self.error.take().unwrap_or_else(|| KeyError::new())
    }
}

impl ::protobuf::Message for GcResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GcResponse {
        GcResponse::new()
    }

    fn default_instance() -> &'static GcResponse {
        static mut instance: ::protobuf::lazy::Lazy<GcResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GcResponse,
        };
        unsafe {
            instance.get(GcResponse::new)
        }
    }
}

impl ::protobuf::Clear for GcResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for GcResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for GcResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for GcResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteRangeRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub start_key: ::std::vec::Vec<u8>,
    pub end_key: ::std::vec::Vec<u8>,
    pub notify_only: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteRangeRequest {
    fn default() -> &'a DeleteRangeRequest {
        <DeleteRangeRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRangeRequest {
    pub fn new() -> DeleteRangeRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // bytes start_key = 2;


    pub fn get_start_key(&self) -> &[u8] {
        &self.start_key
    }
    pub fn clear_start_key(&mut self) {
        self.start_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.start_key
    }

    // Take field
    pub fn take_start_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.start_key, ::std::vec::Vec::new())
    }

    // bytes end_key = 3;


    pub fn get_end_key(&self) -> &[u8] {
        &self.end_key
    }
    pub fn clear_end_key(&mut self) {
        self.end_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_end_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.end_key
    }

    // Take field
    pub fn take_end_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.end_key, ::std::vec::Vec::new())
    }

    // bool notify_only = 4;


    pub fn get_notify_only(&self) -> bool {
        self.notify_only
    }
    pub fn clear_notify_only(&mut self) {
        self.notify_only = false;
    }

    // Param is passed by value, moved
    pub fn set_notify_only(&mut self, v: bool) {
        self.notify_only = v;
    }
}

impl ::protobuf::Message for DeleteRangeRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.start_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.end_key)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.notify_only = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.start_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.start_key);
        }
        if !self.end_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.end_key);
        }
        if self.notify_only != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.start_key.is_empty() {
            os.write_bytes(2, &self.start_key)?;
        }
        if !self.end_key.is_empty() {
            os.write_bytes(3, &self.end_key)?;
        }
        if self.notify_only != false {
            os.write_bool(4, self.notify_only)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteRangeRequest {
        DeleteRangeRequest::new()
    }

    fn default_instance() -> &'static DeleteRangeRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteRangeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteRangeRequest,
        };
        unsafe {
            instance.get(DeleteRangeRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteRangeRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.start_key.clear();
        self.end_key.clear();
        self.notify_only = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for DeleteRangeRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", buf);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", buf);
        ::protobuf::PbPrint::fmt(&self.notify_only, "notify_only", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for DeleteRangeRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.notify_only, "notify_only", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRangeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteRangeResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteRangeResponse {
    fn default() -> &'a DeleteRangeResponse {
        <DeleteRangeResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRangeResponse {
    pub fn new() -> DeleteRangeResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteRangeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteRangeResponse {
        DeleteRangeResponse::new()
    }

    fn default_instance() -> &'static DeleteRangeResponse {
        static mut instance: ::protobuf::lazy::Lazy<DeleteRangeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteRangeResponse,
        };
        unsafe {
            instance.get(DeleteRangeResponse::new)
        }
    }
}

impl ::protobuf::Clear for DeleteRangeResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for DeleteRangeResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for DeleteRangeResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRangeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FlashbackToVersionRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub version: u64,
    pub start_key: ::std::vec::Vec<u8>,
    pub end_key: ::std::vec::Vec<u8>,
    pub start_ts: u64,
    pub commit_ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FlashbackToVersionRequest {
    fn default() -> &'a FlashbackToVersionRequest {
        <FlashbackToVersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl FlashbackToVersionRequest {
    pub fn new() -> FlashbackToVersionRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // uint64 version = 2;


    pub fn get_version(&self) -> u64 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = v;
    }

    // bytes start_key = 3;


    pub fn get_start_key(&self) -> &[u8] {
        &self.start_key
    }
    pub fn clear_start_key(&mut self) {
        self.start_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.start_key
    }

    // Take field
    pub fn take_start_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.start_key, ::std::vec::Vec::new())
    }

    // bytes end_key = 4;


    pub fn get_end_key(&self) -> &[u8] {
        &self.end_key
    }
    pub fn clear_end_key(&mut self) {
        self.end_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_end_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.end_key
    }

    // Take field
    pub fn take_end_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.end_key, ::std::vec::Vec::new())
    }

    // uint64 start_ts = 5;


    pub fn get_start_ts(&self) -> u64 {
        self.start_ts
    }
    pub fn clear_start_ts(&mut self) {
        self.start_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_ts(&mut self, v: u64) {
        self.start_ts = v;
    }

    // uint64 commit_ts = 6;


    pub fn get_commit_ts(&self) -> u64 {
        self.commit_ts
    }
    pub fn clear_commit_ts(&mut self) {
        self.commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_ts(&mut self, v: u64) {
        self.commit_ts = v;
    }
}

impl ::protobuf::Message for FlashbackToVersionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.version = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.start_key)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.end_key)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_ts = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commit_ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(2, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.start_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.start_key);
        }
        if !self.end_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.end_key);
        }
        if self.start_ts != 0 {
            my_size += ::protobuf::rt::value_size(5, self.start_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(6, self.commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.version != 0 {
            os.write_uint64(2, self.version)?;
        }
        if !self.start_key.is_empty() {
            os.write_bytes(3, &self.start_key)?;
        }
        if !self.end_key.is_empty() {
            os.write_bytes(4, &self.end_key)?;
        }
        if self.start_ts != 0 {
            os.write_uint64(5, self.start_ts)?;
        }
        if self.commit_ts != 0 {
            os.write_uint64(6, self.commit_ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlashbackToVersionRequest {
        FlashbackToVersionRequest::new()
    }

    fn default_instance() -> &'static FlashbackToVersionRequest {
        static mut instance: ::protobuf::lazy::Lazy<FlashbackToVersionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FlashbackToVersionRequest,
        };
        unsafe {
            instance.get(FlashbackToVersionRequest::new)
        }
    }
}

impl ::protobuf::Clear for FlashbackToVersionRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.version = 0;
        self.start_key.clear();
        self.end_key.clear();
        self.start_ts = 0;
        self.commit_ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for FlashbackToVersionRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.version, "version", buf);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", buf);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", buf);
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", buf);
        ::protobuf::PbPrint::fmt(&self.commit_ts, "commit_ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for FlashbackToVersionRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.version, "version", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.commit_ts, "commit_ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlashbackToVersionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FlashbackToVersionResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FlashbackToVersionResponse {
    fn default() -> &'a FlashbackToVersionResponse {
        <FlashbackToVersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl FlashbackToVersionResponse {
    pub fn new() -> FlashbackToVersionResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FlashbackToVersionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlashbackToVersionResponse {
        FlashbackToVersionResponse::new()
    }

    fn default_instance() -> &'static FlashbackToVersionResponse {
        static mut instance: ::protobuf::lazy::Lazy<FlashbackToVersionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FlashbackToVersionResponse,
        };
        unsafe {
            instance.get(FlashbackToVersionResponse::new)
        }
    }
}

impl ::protobuf::Clear for FlashbackToVersionResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for FlashbackToVersionResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for FlashbackToVersionResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlashbackToVersionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawGetRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub key: ::std::vec::Vec<u8>,
    pub cf: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawGetRequest {
    fn default() -> &'a RawGetRequest {
        <RawGetRequest as ::protobuf::Message>::default_instance()
    }
}

impl RawGetRequest {
    pub fn new() -> RawGetRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // bytes key = 2;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // string cf = 3;


    pub fn get_cf(&self) -> &str {
        &self.cf
    }
    pub fn clear_cf(&mut self) {
        self.cf.clear();
    }

    // Param is passed by value, moved
    pub fn set_cf(&mut self, v: ::std::string::String) {
        self.cf = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cf(&mut self) -> &mut ::std::string::String {
        &mut self.cf
    }

    // Take field
    pub fn take_cf(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cf, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RawGetRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cf)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.key);
        }
        if !self.cf.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cf);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(2, &self.key)?;
        }
        if !self.cf.is_empty() {
            os.write_string(3, &self.cf)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawGetRequest {
        RawGetRequest::new()
    }

    fn default_instance() -> &'static RawGetRequest {
        static mut instance: ::protobuf::lazy::Lazy<RawGetRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawGetRequest,
        };
        unsafe {
            instance.get(RawGetRequest::new)
        }
    }
}

impl ::protobuf::Clear for RawGetRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.key.clear();
        self.cf.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawGetRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawGetRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawGetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawGetResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::std::string::String,
    pub value: ::std::vec::Vec<u8>,
    pub not_found: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawGetResponse {
    fn default() -> &'a RawGetResponse {
        <RawGetResponse as ::protobuf::Message>::default_instance()
    }
}

impl RawGetResponse {
    pub fn new() -> RawGetResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // bytes value = 3;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // bool not_found = 4;


    pub fn get_not_found(&self) -> bool {
        self.not_found
    }
    pub fn clear_not_found(&mut self) {
        self.not_found = false;
    }

    // Param is passed by value, moved
    pub fn set_not_found(&mut self, v: bool) {
        self.not_found = v;
    }
}

impl ::protobuf::Message for RawGetResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.not_found = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.value);
        }
        if self.not_found != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(3, &self.value)?;
        }
        if self.not_found != false {
            os.write_bool(4, self.not_found)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawGetResponse {
        RawGetResponse::new()
    }

    fn default_instance() -> &'static RawGetResponse {
        static mut instance: ::protobuf::lazy::Lazy<RawGetResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawGetResponse,
        };
        unsafe {
            instance.get(RawGetResponse::new)
        }
    }
}

impl ::protobuf::Clear for RawGetResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.value.clear();
        self.not_found = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawGetResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.value, "value", buf);
        ::protobuf::PbPrint::fmt(&self.not_found, "not_found", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawGetResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.value, "value", &mut s);
        ::protobuf::PbPrint::fmt(&self.not_found, "not_found", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawGetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawBatchGetRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub cf: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawBatchGetRequest {
    fn default() -> &'a RawBatchGetRequest {
        <RawBatchGetRequest as ::protobuf::Message>::default_instance()
    }
}

impl RawBatchGetRequest {
    pub fn new() -> RawBatchGetRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // repeated bytes keys = 2;


    pub fn get_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }

    // string cf = 3;


    pub fn get_cf(&self) -> &str {
        &self.cf
    }
    pub fn clear_cf(&mut self) {
        self.cf.clear();
    }

    // Param is passed by value, moved
    pub fn set_cf(&mut self, v: ::std::string::String) {
        self.cf = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cf(&mut self) -> &mut ::std::string::String {
        &mut self.cf
    }

    // Take field
    pub fn take_cf(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cf, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RawBatchGetRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.keys)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cf)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.keys {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if !self.cf.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cf);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.keys {
            os.write_bytes(2, &v)?;
        };
        if !self.cf.is_empty() {
            os.write_string(3, &self.cf)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawBatchGetRequest {
        RawBatchGetRequest::new()
    }

    fn default_instance() -> &'static RawBatchGetRequest {
        static mut instance: ::protobuf::lazy::Lazy<RawBatchGetRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawBatchGetRequest,
        };
        unsafe {
            instance.get(RawBatchGetRequest::new)
        }
    }
}

impl ::protobuf::Clear for RawBatchGetRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.keys.clear();
        self.cf.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawBatchGetRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", buf);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawBatchGetRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", &mut s);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawBatchGetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawBatchGetResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub pairs: ::protobuf::RepeatedField<KvPair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawBatchGetResponse {
    fn default() -> &'a RawBatchGetResponse {
        <RawBatchGetResponse as ::protobuf::Message>::default_instance()
    }
}

impl RawBatchGetResponse {
    pub fn new() -> RawBatchGetResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // repeated .kvrpcpb.KvPair pairs = 2;


    pub fn get_pairs(&self) -> &[KvPair] {
        &self.pairs
    }
    pub fn clear_pairs(&mut self) {
        self.pairs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pairs(&mut self, v: ::protobuf::RepeatedField<KvPair>) {
        self.pairs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pairs(&mut self) -> &mut ::protobuf::RepeatedField<KvPair> {
        &mut self.pairs
    }

    // Take field
    pub fn take_pairs(&mut self) -> ::protobuf::RepeatedField<KvPair> {
        ::std::mem::replace(&mut self.pairs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RawBatchGetResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pairs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pairs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.pairs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawBatchGetResponse {
        RawBatchGetResponse::new()
    }

    fn default_instance() -> &'static RawBatchGetResponse {
        static mut instance: ::protobuf::lazy::Lazy<RawBatchGetResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawBatchGetResponse,
        };
        unsafe {
            instance.get(RawBatchGetResponse::new)
        }
    }
}

impl ::protobuf::Clear for RawBatchGetResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.pairs.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawBatchGetResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.pairs, "pairs", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawBatchGetResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.pairs, "pairs", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawBatchGetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawPutRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub key: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub cf: ::std::string::String,
    pub ttl: u64,
    pub for_cas: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawPutRequest {
    fn default() -> &'a RawPutRequest {
        <RawPutRequest as ::protobuf::Message>::default_instance()
    }
}

impl RawPutRequest {
    pub fn new() -> RawPutRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // bytes key = 2;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes value = 3;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // string cf = 4;


    pub fn get_cf(&self) -> &str {
        &self.cf
    }
    pub fn clear_cf(&mut self) {
        self.cf.clear();
    }

    // Param is passed by value, moved
    pub fn set_cf(&mut self, v: ::std::string::String) {
        self.cf = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cf(&mut self) -> &mut ::std::string::String {
        &mut self.cf
    }

    // Take field
    pub fn take_cf(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cf, ::std::string::String::new())
    }

    // uint64 ttl = 5;


    pub fn get_ttl(&self) -> u64 {
        self.ttl
    }
    pub fn clear_ttl(&mut self) {
        self.ttl = 0;
    }

    // Param is passed by value, moved
    pub fn set_ttl(&mut self, v: u64) {
        self.ttl = v;
    }

    // bool for_cas = 6;


    pub fn get_for_cas(&self) -> bool {
        self.for_cas
    }
    pub fn clear_for_cas(&mut self) {
        self.for_cas = false;
    }

    // Param is passed by value, moved
    pub fn set_for_cas(&mut self, v: bool) {
        self.for_cas = v;
    }
}

impl ::protobuf::Message for RawPutRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cf)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ttl = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.for_cas = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.value);
        }
        if !self.cf.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.cf);
        }
        if self.ttl != 0 {
            my_size += ::protobuf::rt::value_size(5, self.ttl, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.for_cas != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(2, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(3, &self.value)?;
        }
        if !self.cf.is_empty() {
            os.write_string(4, &self.cf)?;
        }
        if self.ttl != 0 {
            os.write_uint64(5, self.ttl)?;
        }
        if self.for_cas != false {
            os.write_bool(6, self.for_cas)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawPutRequest {
        RawPutRequest::new()
    }

    fn default_instance() -> &'static RawPutRequest {
        static mut instance: ::protobuf::lazy::Lazy<RawPutRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawPutRequest,
        };
        unsafe {
            instance.get(RawPutRequest::new)
        }
    }
}

impl ::protobuf::Clear for RawPutRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.key.clear();
        self.value.clear();
        self.cf.clear();
        self.ttl = 0;
        self.for_cas = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawPutRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        ::protobuf::PbPrint::fmt(&self.value, "value", buf);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", buf);
        ::protobuf::PbPrint::fmt(&self.ttl, "ttl", buf);
        ::protobuf::PbPrint::fmt(&self.for_cas, "for_cas", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawPutRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        ::protobuf::PbPrint::fmt(&self.value, "value", &mut s);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", &mut s);
        ::protobuf::PbPrint::fmt(&self.ttl, "ttl", &mut s);
        ::protobuf::PbPrint::fmt(&self.for_cas, "for_cas", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawPutRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawPutResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawPutResponse {
    fn default() -> &'a RawPutResponse {
        <RawPutResponse as ::protobuf::Message>::default_instance()
    }
}

impl RawPutResponse {
    pub fn new() -> RawPutResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RawPutResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawPutResponse {
        RawPutResponse::new()
    }

    fn default_instance() -> &'static RawPutResponse {
        static mut instance: ::protobuf::lazy::Lazy<RawPutResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawPutResponse,
        };
        unsafe {
            instance.get(RawPutResponse::new)
        }
    }
}

impl ::protobuf::Clear for RawPutResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawPutResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawPutResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawPutResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawBatchPutRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub pairs: ::protobuf::RepeatedField<KvPair>,
    pub cf: ::std::string::String,
    pub ttl: u64,
    pub for_cas: bool,
    pub ttls: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawBatchPutRequest {
    fn default() -> &'a RawBatchPutRequest {
        <RawBatchPutRequest as ::protobuf::Message>::default_instance()
    }
}

impl RawBatchPutRequest {
    pub fn new() -> RawBatchPutRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // repeated .kvrpcpb.KvPair pairs = 2;


    pub fn get_pairs(&self) -> &[KvPair] {
        &self.pairs
    }
    pub fn clear_pairs(&mut self) {
        self.pairs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pairs(&mut self, v: ::protobuf::RepeatedField<KvPair>) {
        self.pairs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pairs(&mut self) -> &mut ::protobuf::RepeatedField<KvPair> {
        &mut self.pairs
    }

    // Take field
    pub fn take_pairs(&mut self) -> ::protobuf::RepeatedField<KvPair> {
        ::std::mem::replace(&mut self.pairs, ::protobuf::RepeatedField::new())
    }

    // string cf = 3;


    pub fn get_cf(&self) -> &str {
        &self.cf
    }
    pub fn clear_cf(&mut self) {
        self.cf.clear();
    }

    // Param is passed by value, moved
    pub fn set_cf(&mut self, v: ::std::string::String) {
        self.cf = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cf(&mut self) -> &mut ::std::string::String {
        &mut self.cf
    }

    // Take field
    pub fn take_cf(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cf, ::std::string::String::new())
    }

    // uint64 ttl = 4;


    pub fn get_ttl(&self) -> u64 {
        self.ttl
    }
    pub fn clear_ttl(&mut self) {
        self.ttl = 0;
    }

    // Param is passed by value, moved
    pub fn set_ttl(&mut self, v: u64) {
        self.ttl = v;
    }

    // bool for_cas = 5;


    pub fn get_for_cas(&self) -> bool {
        self.for_cas
    }
    pub fn clear_for_cas(&mut self) {
        self.for_cas = false;
    }

    // Param is passed by value, moved
    pub fn set_for_cas(&mut self, v: bool) {
        self.for_cas = v;
    }

    // repeated uint64 ttls = 6;


    pub fn get_ttls(&self) -> &[u64] {
        &self.ttls
    }
    pub fn clear_ttls(&mut self) {
        self.ttls.clear();
    }

    // Param is passed by value, moved
    pub fn set_ttls(&mut self, v: ::std::vec::Vec<u64>) {
        self.ttls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ttls(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.ttls
    }

    // Take field
    pub fn take_ttls(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.ttls, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RawBatchPutRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pairs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pairs)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cf)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ttl = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.for_cas = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.ttls)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.cf.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cf);
        }
        if self.ttl != 0 {
            my_size += ::protobuf::rt::value_size(4, self.ttl, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.for_cas != false {
            my_size += 2;
        }
        for value in &self.ttls {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.pairs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.cf.is_empty() {
            os.write_string(3, &self.cf)?;
        }
        if self.ttl != 0 {
            os.write_uint64(4, self.ttl)?;
        }
        if self.for_cas != false {
            os.write_bool(5, self.for_cas)?;
        }
        for v in &self.ttls {
            os.write_uint64(6, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawBatchPutRequest {
        RawBatchPutRequest::new()
    }

    fn default_instance() -> &'static RawBatchPutRequest {
        static mut instance: ::protobuf::lazy::Lazy<RawBatchPutRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawBatchPutRequest,
        };
        unsafe {
            instance.get(RawBatchPutRequest::new)
        }
    }
}

impl ::protobuf::Clear for RawBatchPutRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.pairs.clear();
        self.cf.clear();
        self.ttl = 0;
        self.for_cas = false;
        self.ttls.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawBatchPutRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.pairs, "pairs", buf);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", buf);
        ::protobuf::PbPrint::fmt(&self.ttl, "ttl", buf);
        ::protobuf::PbPrint::fmt(&self.for_cas, "for_cas", buf);
        ::protobuf::PbPrint::fmt(&self.ttls, "ttls", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawBatchPutRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.pairs, "pairs", &mut s);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", &mut s);
        ::protobuf::PbPrint::fmt(&self.ttl, "ttl", &mut s);
        ::protobuf::PbPrint::fmt(&self.for_cas, "for_cas", &mut s);
        ::protobuf::PbPrint::fmt(&self.ttls, "ttls", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawBatchPutRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawBatchPutResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawBatchPutResponse {
    fn default() -> &'a RawBatchPutResponse {
        <RawBatchPutResponse as ::protobuf::Message>::default_instance()
    }
}

impl RawBatchPutResponse {
    pub fn new() -> RawBatchPutResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RawBatchPutResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawBatchPutResponse {
        RawBatchPutResponse::new()
    }

    fn default_instance() -> &'static RawBatchPutResponse {
        static mut instance: ::protobuf::lazy::Lazy<RawBatchPutResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawBatchPutResponse,
        };
        unsafe {
            instance.get(RawBatchPutResponse::new)
        }
    }
}

impl ::protobuf::Clear for RawBatchPutResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawBatchPutResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawBatchPutResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawBatchPutResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawDeleteRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub key: ::std::vec::Vec<u8>,
    pub cf: ::std::string::String,
    pub for_cas: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawDeleteRequest {
    fn default() -> &'a RawDeleteRequest {
        <RawDeleteRequest as ::protobuf::Message>::default_instance()
    }
}

impl RawDeleteRequest {
    pub fn new() -> RawDeleteRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // bytes key = 2;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // string cf = 3;


    pub fn get_cf(&self) -> &str {
        &self.cf
    }
    pub fn clear_cf(&mut self) {
        self.cf.clear();
    }

    // Param is passed by value, moved
    pub fn set_cf(&mut self, v: ::std::string::String) {
        self.cf = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cf(&mut self) -> &mut ::std::string::String {
        &mut self.cf
    }

    // Take field
    pub fn take_cf(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cf, ::std::string::String::new())
    }

    // bool for_cas = 4;


    pub fn get_for_cas(&self) -> bool {
        self.for_cas
    }
    pub fn clear_for_cas(&mut self) {
        self.for_cas = false;
    }

    // Param is passed by value, moved
    pub fn set_for_cas(&mut self, v: bool) {
        self.for_cas = v;
    }
}

impl ::protobuf::Message for RawDeleteRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cf)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.for_cas = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.key);
        }
        if !self.cf.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cf);
        }
        if self.for_cas != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(2, &self.key)?;
        }
        if !self.cf.is_empty() {
            os.write_string(3, &self.cf)?;
        }
        if self.for_cas != false {
            os.write_bool(4, self.for_cas)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawDeleteRequest {
        RawDeleteRequest::new()
    }

    fn default_instance() -> &'static RawDeleteRequest {
        static mut instance: ::protobuf::lazy::Lazy<RawDeleteRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawDeleteRequest,
        };
        unsafe {
            instance.get(RawDeleteRequest::new)
        }
    }
}

impl ::protobuf::Clear for RawDeleteRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.key.clear();
        self.cf.clear();
        self.for_cas = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawDeleteRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", buf);
        ::protobuf::PbPrint::fmt(&self.for_cas, "for_cas", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawDeleteRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", &mut s);
        ::protobuf::PbPrint::fmt(&self.for_cas, "for_cas", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawDeleteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawDeleteResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawDeleteResponse {
    fn default() -> &'a RawDeleteResponse {
        <RawDeleteResponse as ::protobuf::Message>::default_instance()
    }
}

impl RawDeleteResponse {
    pub fn new() -> RawDeleteResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RawDeleteResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawDeleteResponse {
        RawDeleteResponse::new()
    }

    fn default_instance() -> &'static RawDeleteResponse {
        static mut instance: ::protobuf::lazy::Lazy<RawDeleteResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawDeleteResponse,
        };
        unsafe {
            instance.get(RawDeleteResponse::new)
        }
    }
}

impl ::protobuf::Clear for RawDeleteResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawDeleteResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawDeleteResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawDeleteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawBatchDeleteRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub cf: ::std::string::String,
    pub for_cas: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawBatchDeleteRequest {
    fn default() -> &'a RawBatchDeleteRequest {
        <RawBatchDeleteRequest as ::protobuf::Message>::default_instance()
    }
}

impl RawBatchDeleteRequest {
    pub fn new() -> RawBatchDeleteRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // repeated bytes keys = 2;


    pub fn get_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }

    // string cf = 3;


    pub fn get_cf(&self) -> &str {
        &self.cf
    }
    pub fn clear_cf(&mut self) {
        self.cf.clear();
    }

    // Param is passed by value, moved
    pub fn set_cf(&mut self, v: ::std::string::String) {
        self.cf = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cf(&mut self) -> &mut ::std::string::String {
        &mut self.cf
    }

    // Take field
    pub fn take_cf(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cf, ::std::string::String::new())
    }

    // bool for_cas = 4;


    pub fn get_for_cas(&self) -> bool {
        self.for_cas
    }
    pub fn clear_for_cas(&mut self) {
        self.for_cas = false;
    }

    // Param is passed by value, moved
    pub fn set_for_cas(&mut self, v: bool) {
        self.for_cas = v;
    }
}

impl ::protobuf::Message for RawBatchDeleteRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.keys)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cf)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.for_cas = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.keys {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if !self.cf.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cf);
        }
        if self.for_cas != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.keys {
            os.write_bytes(2, &v)?;
        };
        if !self.cf.is_empty() {
            os.write_string(3, &self.cf)?;
        }
        if self.for_cas != false {
            os.write_bool(4, self.for_cas)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawBatchDeleteRequest {
        RawBatchDeleteRequest::new()
    }

    fn default_instance() -> &'static RawBatchDeleteRequest {
        static mut instance: ::protobuf::lazy::Lazy<RawBatchDeleteRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawBatchDeleteRequest,
        };
        unsafe {
            instance.get(RawBatchDeleteRequest::new)
        }
    }
}

impl ::protobuf::Clear for RawBatchDeleteRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.keys.clear();
        self.cf.clear();
        self.for_cas = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawBatchDeleteRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", buf);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", buf);
        ::protobuf::PbPrint::fmt(&self.for_cas, "for_cas", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawBatchDeleteRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", &mut s);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", &mut s);
        ::protobuf::PbPrint::fmt(&self.for_cas, "for_cas", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawBatchDeleteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawBatchDeleteResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawBatchDeleteResponse {
    fn default() -> &'a RawBatchDeleteResponse {
        <RawBatchDeleteResponse as ::protobuf::Message>::default_instance()
    }
}

impl RawBatchDeleteResponse {
    pub fn new() -> RawBatchDeleteResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RawBatchDeleteResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawBatchDeleteResponse {
        RawBatchDeleteResponse::new()
    }

    fn default_instance() -> &'static RawBatchDeleteResponse {
        static mut instance: ::protobuf::lazy::Lazy<RawBatchDeleteResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawBatchDeleteResponse,
        };
        unsafe {
            instance.get(RawBatchDeleteResponse::new)
        }
    }
}

impl ::protobuf::Clear for RawBatchDeleteResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawBatchDeleteResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawBatchDeleteResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawBatchDeleteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawScanRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub start_key: ::std::vec::Vec<u8>,
    pub limit: u32,
    pub key_only: bool,
    pub cf: ::std::string::String,
    pub reverse: bool,
    pub end_key: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawScanRequest {
    fn default() -> &'a RawScanRequest {
        <RawScanRequest as ::protobuf::Message>::default_instance()
    }
}

impl RawScanRequest {
    pub fn new() -> RawScanRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // bytes start_key = 2;


    pub fn get_start_key(&self) -> &[u8] {
        &self.start_key
    }
    pub fn clear_start_key(&mut self) {
        self.start_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.start_key
    }

    // Take field
    pub fn take_start_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.start_key, ::std::vec::Vec::new())
    }

    // uint32 limit = 3;


    pub fn get_limit(&self) -> u32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u32) {
        self.limit = v;
    }

    // bool key_only = 4;


    pub fn get_key_only(&self) -> bool {
        self.key_only
    }
    pub fn clear_key_only(&mut self) {
        self.key_only = false;
    }

    // Param is passed by value, moved
    pub fn set_key_only(&mut self, v: bool) {
        self.key_only = v;
    }

    // string cf = 5;


    pub fn get_cf(&self) -> &str {
        &self.cf
    }
    pub fn clear_cf(&mut self) {
        self.cf.clear();
    }

    // Param is passed by value, moved
    pub fn set_cf(&mut self, v: ::std::string::String) {
        self.cf = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cf(&mut self) -> &mut ::std::string::String {
        &mut self.cf
    }

    // Take field
    pub fn take_cf(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cf, ::std::string::String::new())
    }

    // bool reverse = 6;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }

    // bytes end_key = 7;


    pub fn get_end_key(&self) -> &[u8] {
        &self.end_key
    }
    pub fn clear_end_key(&mut self) {
        self.end_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_end_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.end_key
    }

    // Take field
    pub fn take_end_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.end_key, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RawScanRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.start_key)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.limit = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.key_only = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cf)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.end_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.start_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.start_key);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.key_only != false {
            my_size += 2;
        }
        if !self.cf.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.cf);
        }
        if self.reverse != false {
            my_size += 2;
        }
        if !self.end_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.end_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.start_key.is_empty() {
            os.write_bytes(2, &self.start_key)?;
        }
        if self.limit != 0 {
            os.write_uint32(3, self.limit)?;
        }
        if self.key_only != false {
            os.write_bool(4, self.key_only)?;
        }
        if !self.cf.is_empty() {
            os.write_string(5, &self.cf)?;
        }
        if self.reverse != false {
            os.write_bool(6, self.reverse)?;
        }
        if !self.end_key.is_empty() {
            os.write_bytes(7, &self.end_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawScanRequest {
        RawScanRequest::new()
    }

    fn default_instance() -> &'static RawScanRequest {
        static mut instance: ::protobuf::lazy::Lazy<RawScanRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawScanRequest,
        };
        unsafe {
            instance.get(RawScanRequest::new)
        }
    }
}

impl ::protobuf::Clear for RawScanRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.start_key.clear();
        self.limit = 0;
        self.key_only = false;
        self.cf.clear();
        self.reverse = false;
        self.end_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawScanRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", buf);
        ::protobuf::PbPrint::fmt(&self.limit, "limit", buf);
        ::protobuf::PbPrint::fmt(&self.key_only, "key_only", buf);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", buf);
        ::protobuf::PbPrint::fmt(&self.reverse, "reverse", buf);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawScanRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.limit, "limit", &mut s);
        ::protobuf::PbPrint::fmt(&self.key_only, "key_only", &mut s);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", &mut s);
        ::protobuf::PbPrint::fmt(&self.reverse, "reverse", &mut s);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawScanRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawScanResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub kvs: ::protobuf::RepeatedField<KvPair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawScanResponse {
    fn default() -> &'a RawScanResponse {
        <RawScanResponse as ::protobuf::Message>::default_instance()
    }
}

impl RawScanResponse {
    pub fn new() -> RawScanResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // repeated .kvrpcpb.KvPair kvs = 2;


    pub fn get_kvs(&self) -> &[KvPair] {
        &self.kvs
    }
    pub fn clear_kvs(&mut self) {
        self.kvs.clear();
    }

    // Param is passed by value, moved
    pub fn set_kvs(&mut self, v: ::protobuf::RepeatedField<KvPair>) {
        self.kvs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kvs(&mut self) -> &mut ::protobuf::RepeatedField<KvPair> {
        &mut self.kvs
    }

    // Take field
    pub fn take_kvs(&mut self) -> ::protobuf::RepeatedField<KvPair> {
        ::std::mem::replace(&mut self.kvs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RawScanResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.kvs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.kvs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.kvs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.kvs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawScanResponse {
        RawScanResponse::new()
    }

    fn default_instance() -> &'static RawScanResponse {
        static mut instance: ::protobuf::lazy::Lazy<RawScanResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawScanResponse,
        };
        unsafe {
            instance.get(RawScanResponse::new)
        }
    }
}

impl ::protobuf::Clear for RawScanResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.kvs.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawScanResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.kvs, "kvs", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawScanResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.kvs, "kvs", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawScanResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawDeleteRangeRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub start_key: ::std::vec::Vec<u8>,
    pub end_key: ::std::vec::Vec<u8>,
    pub cf: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawDeleteRangeRequest {
    fn default() -> &'a RawDeleteRangeRequest {
        <RawDeleteRangeRequest as ::protobuf::Message>::default_instance()
    }
}

impl RawDeleteRangeRequest {
    pub fn new() -> RawDeleteRangeRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // bytes start_key = 2;


    pub fn get_start_key(&self) -> &[u8] {
        &self.start_key
    }
    pub fn clear_start_key(&mut self) {
        self.start_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.start_key
    }

    // Take field
    pub fn take_start_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.start_key, ::std::vec::Vec::new())
    }

    // bytes end_key = 3;


    pub fn get_end_key(&self) -> &[u8] {
        &self.end_key
    }
    pub fn clear_end_key(&mut self) {
        self.end_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_end_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.end_key
    }

    // Take field
    pub fn take_end_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.end_key, ::std::vec::Vec::new())
    }

    // string cf = 4;


    pub fn get_cf(&self) -> &str {
        &self.cf
    }
    pub fn clear_cf(&mut self) {
        self.cf.clear();
    }

    // Param is passed by value, moved
    pub fn set_cf(&mut self, v: ::std::string::String) {
        self.cf = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cf(&mut self) -> &mut ::std::string::String {
        &mut self.cf
    }

    // Take field
    pub fn take_cf(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cf, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RawDeleteRangeRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.start_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.end_key)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cf)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.start_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.start_key);
        }
        if !self.end_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.end_key);
        }
        if !self.cf.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.cf);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.start_key.is_empty() {
            os.write_bytes(2, &self.start_key)?;
        }
        if !self.end_key.is_empty() {
            os.write_bytes(3, &self.end_key)?;
        }
        if !self.cf.is_empty() {
            os.write_string(4, &self.cf)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawDeleteRangeRequest {
        RawDeleteRangeRequest::new()
    }

    fn default_instance() -> &'static RawDeleteRangeRequest {
        static mut instance: ::protobuf::lazy::Lazy<RawDeleteRangeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawDeleteRangeRequest,
        };
        unsafe {
            instance.get(RawDeleteRangeRequest::new)
        }
    }
}

impl ::protobuf::Clear for RawDeleteRangeRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.start_key.clear();
        self.end_key.clear();
        self.cf.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawDeleteRangeRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", buf);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", buf);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawDeleteRangeRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawDeleteRangeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawDeleteRangeResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawDeleteRangeResponse {
    fn default() -> &'a RawDeleteRangeResponse {
        <RawDeleteRangeResponse as ::protobuf::Message>::default_instance()
    }
}

impl RawDeleteRangeResponse {
    pub fn new() -> RawDeleteRangeResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RawDeleteRangeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawDeleteRangeResponse {
        RawDeleteRangeResponse::new()
    }

    fn default_instance() -> &'static RawDeleteRangeResponse {
        static mut instance: ::protobuf::lazy::Lazy<RawDeleteRangeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawDeleteRangeResponse,
        };
        unsafe {
            instance.get(RawDeleteRangeResponse::new)
        }
    }
}

impl ::protobuf::Clear for RawDeleteRangeResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawDeleteRangeResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawDeleteRangeResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawDeleteRangeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawBatchScanRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub ranges: ::protobuf::RepeatedField<KeyRange>,
    pub each_limit: u32,
    pub key_only: bool,
    pub cf: ::std::string::String,
    pub reverse: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawBatchScanRequest {
    fn default() -> &'a RawBatchScanRequest {
        <RawBatchScanRequest as ::protobuf::Message>::default_instance()
    }
}

impl RawBatchScanRequest {
    pub fn new() -> RawBatchScanRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // repeated .kvrpcpb.KeyRange ranges = 2;


    pub fn get_ranges(&self) -> &[KeyRange] {
        &self.ranges
    }
    pub fn clear_ranges(&mut self) {
        self.ranges.clear();
    }

    // Param is passed by value, moved
    pub fn set_ranges(&mut self, v: ::protobuf::RepeatedField<KeyRange>) {
        self.ranges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ranges(&mut self) -> &mut ::protobuf::RepeatedField<KeyRange> {
        &mut self.ranges
    }

    // Take field
    pub fn take_ranges(&mut self) -> ::protobuf::RepeatedField<KeyRange> {
        ::std::mem::replace(&mut self.ranges, ::protobuf::RepeatedField::new())
    }

    // uint32 each_limit = 3;


    pub fn get_each_limit(&self) -> u32 {
        self.each_limit
    }
    pub fn clear_each_limit(&mut self) {
        self.each_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_each_limit(&mut self, v: u32) {
        self.each_limit = v;
    }

    // bool key_only = 4;


    pub fn get_key_only(&self) -> bool {
        self.key_only
    }
    pub fn clear_key_only(&mut self) {
        self.key_only = false;
    }

    // Param is passed by value, moved
    pub fn set_key_only(&mut self, v: bool) {
        self.key_only = v;
    }

    // string cf = 5;


    pub fn get_cf(&self) -> &str {
        &self.cf
    }
    pub fn clear_cf(&mut self) {
        self.cf.clear();
    }

    // Param is passed by value, moved
    pub fn set_cf(&mut self, v: ::std::string::String) {
        self.cf = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cf(&mut self) -> &mut ::std::string::String {
        &mut self.cf
    }

    // Take field
    pub fn take_cf(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cf, ::std::string::String::new())
    }

    // bool reverse = 6;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }
}

impl ::protobuf::Message for RawBatchScanRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ranges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ranges)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.each_limit = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.key_only = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cf)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ranges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.each_limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.each_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.key_only != false {
            my_size += 2;
        }
        if !self.cf.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.cf);
        }
        if self.reverse != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ranges {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.each_limit != 0 {
            os.write_uint32(3, self.each_limit)?;
        }
        if self.key_only != false {
            os.write_bool(4, self.key_only)?;
        }
        if !self.cf.is_empty() {
            os.write_string(5, &self.cf)?;
        }
        if self.reverse != false {
            os.write_bool(6, self.reverse)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawBatchScanRequest {
        RawBatchScanRequest::new()
    }

    fn default_instance() -> &'static RawBatchScanRequest {
        static mut instance: ::protobuf::lazy::Lazy<RawBatchScanRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawBatchScanRequest,
        };
        unsafe {
            instance.get(RawBatchScanRequest::new)
        }
    }
}

impl ::protobuf::Clear for RawBatchScanRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.ranges.clear();
        self.each_limit = 0;
        self.key_only = false;
        self.cf.clear();
        self.reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawBatchScanRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.ranges, "ranges", buf);
        ::protobuf::PbPrint::fmt(&self.each_limit, "each_limit", buf);
        ::protobuf::PbPrint::fmt(&self.key_only, "key_only", buf);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", buf);
        ::protobuf::PbPrint::fmt(&self.reverse, "reverse", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawBatchScanRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.ranges, "ranges", &mut s);
        ::protobuf::PbPrint::fmt(&self.each_limit, "each_limit", &mut s);
        ::protobuf::PbPrint::fmt(&self.key_only, "key_only", &mut s);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", &mut s);
        ::protobuf::PbPrint::fmt(&self.reverse, "reverse", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawBatchScanRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawBatchScanResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub kvs: ::protobuf::RepeatedField<KvPair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawBatchScanResponse {
    fn default() -> &'a RawBatchScanResponse {
        <RawBatchScanResponse as ::protobuf::Message>::default_instance()
    }
}

impl RawBatchScanResponse {
    pub fn new() -> RawBatchScanResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // repeated .kvrpcpb.KvPair kvs = 2;


    pub fn get_kvs(&self) -> &[KvPair] {
        &self.kvs
    }
    pub fn clear_kvs(&mut self) {
        self.kvs.clear();
    }

    // Param is passed by value, moved
    pub fn set_kvs(&mut self, v: ::protobuf::RepeatedField<KvPair>) {
        self.kvs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kvs(&mut self) -> &mut ::protobuf::RepeatedField<KvPair> {
        &mut self.kvs
    }

    // Take field
    pub fn take_kvs(&mut self) -> ::protobuf::RepeatedField<KvPair> {
        ::std::mem::replace(&mut self.kvs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RawBatchScanResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.kvs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.kvs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.kvs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.kvs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawBatchScanResponse {
        RawBatchScanResponse::new()
    }

    fn default_instance() -> &'static RawBatchScanResponse {
        static mut instance: ::protobuf::lazy::Lazy<RawBatchScanResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawBatchScanResponse,
        };
        unsafe {
            instance.get(RawBatchScanResponse::new)
        }
    }
}

impl ::protobuf::Clear for RawBatchScanResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.kvs.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawBatchScanResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.kvs, "kvs", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawBatchScanResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.kvs, "kvs", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawBatchScanResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnsafeDestroyRangeRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub start_key: ::std::vec::Vec<u8>,
    pub end_key: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnsafeDestroyRangeRequest {
    fn default() -> &'a UnsafeDestroyRangeRequest {
        <UnsafeDestroyRangeRequest as ::protobuf::Message>::default_instance()
    }
}

impl UnsafeDestroyRangeRequest {
    pub fn new() -> UnsafeDestroyRangeRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // bytes start_key = 2;


    pub fn get_start_key(&self) -> &[u8] {
        &self.start_key
    }
    pub fn clear_start_key(&mut self) {
        self.start_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.start_key
    }

    // Take field
    pub fn take_start_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.start_key, ::std::vec::Vec::new())
    }

    // bytes end_key = 3;


    pub fn get_end_key(&self) -> &[u8] {
        &self.end_key
    }
    pub fn clear_end_key(&mut self) {
        self.end_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_end_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.end_key
    }

    // Take field
    pub fn take_end_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.end_key, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UnsafeDestroyRangeRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.start_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.end_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.start_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.start_key);
        }
        if !self.end_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.end_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.start_key.is_empty() {
            os.write_bytes(2, &self.start_key)?;
        }
        if !self.end_key.is_empty() {
            os.write_bytes(3, &self.end_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnsafeDestroyRangeRequest {
        UnsafeDestroyRangeRequest::new()
    }

    fn default_instance() -> &'static UnsafeDestroyRangeRequest {
        static mut instance: ::protobuf::lazy::Lazy<UnsafeDestroyRangeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnsafeDestroyRangeRequest,
        };
        unsafe {
            instance.get(UnsafeDestroyRangeRequest::new)
        }
    }
}

impl ::protobuf::Clear for UnsafeDestroyRangeRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.start_key.clear();
        self.end_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for UnsafeDestroyRangeRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", buf);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for UnsafeDestroyRangeRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnsafeDestroyRangeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnsafeDestroyRangeResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnsafeDestroyRangeResponse {
    fn default() -> &'a UnsafeDestroyRangeResponse {
        <UnsafeDestroyRangeResponse as ::protobuf::Message>::default_instance()
    }
}

impl UnsafeDestroyRangeResponse {
    pub fn new() -> UnsafeDestroyRangeResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UnsafeDestroyRangeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnsafeDestroyRangeResponse {
        UnsafeDestroyRangeResponse::new()
    }

    fn default_instance() -> &'static UnsafeDestroyRangeResponse {
        static mut instance: ::protobuf::lazy::Lazy<UnsafeDestroyRangeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnsafeDestroyRangeResponse,
        };
        unsafe {
            instance.get(UnsafeDestroyRangeResponse::new)
        }
    }
}

impl ::protobuf::Clear for UnsafeDestroyRangeResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for UnsafeDestroyRangeResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for UnsafeDestroyRangeResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnsafeDestroyRangeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegisterLockObserverRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub max_ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisterLockObserverRequest {
    fn default() -> &'a RegisterLockObserverRequest {
        <RegisterLockObserverRequest as ::protobuf::Message>::default_instance()
    }
}

impl RegisterLockObserverRequest {
    pub fn new() -> RegisterLockObserverRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // uint64 max_ts = 2;


    pub fn get_max_ts(&self) -> u64 {
        self.max_ts
    }
    pub fn clear_max_ts(&mut self) {
        self.max_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_ts(&mut self, v: u64) {
        self.max_ts = v;
    }
}

impl ::protobuf::Message for RegisterLockObserverRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.max_ts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.max_ts != 0 {
            os.write_uint64(2, self.max_ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegisterLockObserverRequest {
        RegisterLockObserverRequest::new()
    }

    fn default_instance() -> &'static RegisterLockObserverRequest {
        static mut instance: ::protobuf::lazy::Lazy<RegisterLockObserverRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RegisterLockObserverRequest,
        };
        unsafe {
            instance.get(RegisterLockObserverRequest::new)
        }
    }
}

impl ::protobuf::Clear for RegisterLockObserverRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.max_ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RegisterLockObserverRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.max_ts, "max_ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RegisterLockObserverRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.max_ts, "max_ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterLockObserverRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegisterLockObserverResponse {
    // message fields
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisterLockObserverResponse {
    fn default() -> &'a RegisterLockObserverResponse {
        <RegisterLockObserverResponse as ::protobuf::Message>::default_instance()
    }
}

impl RegisterLockObserverResponse {
    pub fn new() -> RegisterLockObserverResponse {
        ::std::default::Default::default()
    }

    // string error = 1;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RegisterLockObserverResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegisterLockObserverResponse {
        RegisterLockObserverResponse::new()
    }

    fn default_instance() -> &'static RegisterLockObserverResponse {
        static mut instance: ::protobuf::lazy::Lazy<RegisterLockObserverResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RegisterLockObserverResponse,
        };
        unsafe {
            instance.get(RegisterLockObserverResponse::new)
        }
    }
}

impl ::protobuf::Clear for RegisterLockObserverResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RegisterLockObserverResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RegisterLockObserverResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterLockObserverResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckLockObserverRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub max_ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckLockObserverRequest {
    fn default() -> &'a CheckLockObserverRequest {
        <CheckLockObserverRequest as ::protobuf::Message>::default_instance()
    }
}

impl CheckLockObserverRequest {
    pub fn new() -> CheckLockObserverRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // uint64 max_ts = 2;


    pub fn get_max_ts(&self) -> u64 {
        self.max_ts
    }
    pub fn clear_max_ts(&mut self) {
        self.max_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_ts(&mut self, v: u64) {
        self.max_ts = v;
    }
}

impl ::protobuf::Message for CheckLockObserverRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.max_ts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.max_ts != 0 {
            os.write_uint64(2, self.max_ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckLockObserverRequest {
        CheckLockObserverRequest::new()
    }

    fn default_instance() -> &'static CheckLockObserverRequest {
        static mut instance: ::protobuf::lazy::Lazy<CheckLockObserverRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckLockObserverRequest,
        };
        unsafe {
            instance.get(CheckLockObserverRequest::new)
        }
    }
}

impl ::protobuf::Clear for CheckLockObserverRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.max_ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CheckLockObserverRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.max_ts, "max_ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for CheckLockObserverRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.max_ts, "max_ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckLockObserverRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckLockObserverResponse {
    // message fields
    pub error: ::std::string::String,
    pub is_clean: bool,
    pub locks: ::protobuf::RepeatedField<LockInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckLockObserverResponse {
    fn default() -> &'a CheckLockObserverResponse {
        <CheckLockObserverResponse as ::protobuf::Message>::default_instance()
    }
}

impl CheckLockObserverResponse {
    pub fn new() -> CheckLockObserverResponse {
        ::std::default::Default::default()
    }

    // string error = 1;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // bool is_clean = 2;


    pub fn get_is_clean(&self) -> bool {
        self.is_clean
    }
    pub fn clear_is_clean(&mut self) {
        self.is_clean = false;
    }

    // Param is passed by value, moved
    pub fn set_is_clean(&mut self, v: bool) {
        self.is_clean = v;
    }

    // repeated .kvrpcpb.LockInfo locks = 3;


    pub fn get_locks(&self) -> &[LockInfo] {
        &self.locks
    }
    pub fn clear_locks(&mut self) {
        self.locks.clear();
    }

    // Param is passed by value, moved
    pub fn set_locks(&mut self, v: ::protobuf::RepeatedField<LockInfo>) {
        self.locks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_locks(&mut self) -> &mut ::protobuf::RepeatedField<LockInfo> {
        &mut self.locks
    }

    // Take field
    pub fn take_locks(&mut self) -> ::protobuf::RepeatedField<LockInfo> {
        ::std::mem::replace(&mut self.locks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CheckLockObserverResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.locks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_clean = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.locks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        if self.is_clean != false {
            my_size += 2;
        }
        for value in &self.locks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        if self.is_clean != false {
            os.write_bool(2, self.is_clean)?;
        }
        for v in &self.locks {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckLockObserverResponse {
        CheckLockObserverResponse::new()
    }

    fn default_instance() -> &'static CheckLockObserverResponse {
        static mut instance: ::protobuf::lazy::Lazy<CheckLockObserverResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckLockObserverResponse,
        };
        unsafe {
            instance.get(CheckLockObserverResponse::new)
        }
    }
}

impl ::protobuf::Clear for CheckLockObserverResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.is_clean = false;
        self.locks.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CheckLockObserverResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.is_clean, "is_clean", buf);
        ::protobuf::PbPrint::fmt(&self.locks, "locks", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for CheckLockObserverResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.is_clean, "is_clean", &mut s);
        ::protobuf::PbPrint::fmt(&self.locks, "locks", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckLockObserverResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveLockObserverRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub max_ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveLockObserverRequest {
    fn default() -> &'a RemoveLockObserverRequest {
        <RemoveLockObserverRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveLockObserverRequest {
    pub fn new() -> RemoveLockObserverRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // uint64 max_ts = 2;


    pub fn get_max_ts(&self) -> u64 {
        self.max_ts
    }
    pub fn clear_max_ts(&mut self) {
        self.max_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_ts(&mut self, v: u64) {
        self.max_ts = v;
    }
}

impl ::protobuf::Message for RemoveLockObserverRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.max_ts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.max_ts != 0 {
            os.write_uint64(2, self.max_ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveLockObserverRequest {
        RemoveLockObserverRequest::new()
    }

    fn default_instance() -> &'static RemoveLockObserverRequest {
        static mut instance: ::protobuf::lazy::Lazy<RemoveLockObserverRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveLockObserverRequest,
        };
        unsafe {
            instance.get(RemoveLockObserverRequest::new)
        }
    }
}

impl ::protobuf::Clear for RemoveLockObserverRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.max_ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RemoveLockObserverRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.max_ts, "max_ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RemoveLockObserverRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.max_ts, "max_ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveLockObserverRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveLockObserverResponse {
    // message fields
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveLockObserverResponse {
    fn default() -> &'a RemoveLockObserverResponse {
        <RemoveLockObserverResponse as ::protobuf::Message>::default_instance()
    }
}

impl RemoveLockObserverResponse {
    pub fn new() -> RemoveLockObserverResponse {
        ::std::default::Default::default()
    }

    // string error = 1;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RemoveLockObserverResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveLockObserverResponse {
        RemoveLockObserverResponse::new()
    }

    fn default_instance() -> &'static RemoveLockObserverResponse {
        static mut instance: ::protobuf::lazy::Lazy<RemoveLockObserverResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveLockObserverResponse,
        };
        unsafe {
            instance.get(RemoveLockObserverResponse::new)
        }
    }
}

impl ::protobuf::Clear for RemoveLockObserverResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RemoveLockObserverResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RemoveLockObserverResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveLockObserverResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PhysicalScanLockRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub max_ts: u64,
    pub start_key: ::std::vec::Vec<u8>,
    pub limit: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PhysicalScanLockRequest {
    fn default() -> &'a PhysicalScanLockRequest {
        <PhysicalScanLockRequest as ::protobuf::Message>::default_instance()
    }
}

impl PhysicalScanLockRequest {
    pub fn new() -> PhysicalScanLockRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // uint64 max_ts = 2;


    pub fn get_max_ts(&self) -> u64 {
        self.max_ts
    }
    pub fn clear_max_ts(&mut self) {
        self.max_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_ts(&mut self, v: u64) {
        self.max_ts = v;
    }

    // bytes start_key = 3;


    pub fn get_start_key(&self) -> &[u8] {
        &self.start_key
    }
    pub fn clear_start_key(&mut self) {
        self.start_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.start_key
    }

    // Take field
    pub fn take_start_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.start_key, ::std::vec::Vec::new())
    }

    // uint32 limit = 4;


    pub fn get_limit(&self) -> u32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u32) {
        self.limit = v;
    }
}

impl ::protobuf::Message for PhysicalScanLockRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_ts = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.start_key)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.max_ts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.start_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.start_key);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.max_ts != 0 {
            os.write_uint64(2, self.max_ts)?;
        }
        if !self.start_key.is_empty() {
            os.write_bytes(3, &self.start_key)?;
        }
        if self.limit != 0 {
            os.write_uint32(4, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PhysicalScanLockRequest {
        PhysicalScanLockRequest::new()
    }

    fn default_instance() -> &'static PhysicalScanLockRequest {
        static mut instance: ::protobuf::lazy::Lazy<PhysicalScanLockRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PhysicalScanLockRequest,
        };
        unsafe {
            instance.get(PhysicalScanLockRequest::new)
        }
    }
}

impl ::protobuf::Clear for PhysicalScanLockRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.max_ts = 0;
        self.start_key.clear();
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for PhysicalScanLockRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.max_ts, "max_ts", buf);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", buf);
        ::protobuf::PbPrint::fmt(&self.limit, "limit", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for PhysicalScanLockRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.max_ts, "max_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.limit, "limit", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhysicalScanLockRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PhysicalScanLockResponse {
    // message fields
    pub error: ::std::string::String,
    pub locks: ::protobuf::RepeatedField<LockInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PhysicalScanLockResponse {
    fn default() -> &'a PhysicalScanLockResponse {
        <PhysicalScanLockResponse as ::protobuf::Message>::default_instance()
    }
}

impl PhysicalScanLockResponse {
    pub fn new() -> PhysicalScanLockResponse {
        ::std::default::Default::default()
    }

    // string error = 1;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // repeated .kvrpcpb.LockInfo locks = 2;


    pub fn get_locks(&self) -> &[LockInfo] {
        &self.locks
    }
    pub fn clear_locks(&mut self) {
        self.locks.clear();
    }

    // Param is passed by value, moved
    pub fn set_locks(&mut self, v: ::protobuf::RepeatedField<LockInfo>) {
        self.locks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_locks(&mut self) -> &mut ::protobuf::RepeatedField<LockInfo> {
        &mut self.locks
    }

    // Take field
    pub fn take_locks(&mut self) -> ::protobuf::RepeatedField<LockInfo> {
        ::std::mem::replace(&mut self.locks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PhysicalScanLockResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.locks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.locks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        for value in &self.locks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        for v in &self.locks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PhysicalScanLockResponse {
        PhysicalScanLockResponse::new()
    }

    fn default_instance() -> &'static PhysicalScanLockResponse {
        static mut instance: ::protobuf::lazy::Lazy<PhysicalScanLockResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PhysicalScanLockResponse,
        };
        unsafe {
            instance.get(PhysicalScanLockResponse::new)
        }
    }
}

impl ::protobuf::Clear for PhysicalScanLockResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.locks.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for PhysicalScanLockResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.locks, "locks", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for PhysicalScanLockResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.locks, "locks", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhysicalScanLockResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SplitRegionRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub split_key: ::std::vec::Vec<u8>,
    pub split_keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub is_raw_kv: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SplitRegionRequest {
    fn default() -> &'a SplitRegionRequest {
        <SplitRegionRequest as ::protobuf::Message>::default_instance()
    }
}

impl SplitRegionRequest {
    pub fn new() -> SplitRegionRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // bytes split_key = 2;


    pub fn get_split_key(&self) -> &[u8] {
        &self.split_key
    }
    pub fn clear_split_key(&mut self) {
        self.split_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_split_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.split_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_split_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.split_key
    }

    // Take field
    pub fn take_split_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.split_key, ::std::vec::Vec::new())
    }

    // repeated bytes split_keys = 3;


    pub fn get_split_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.split_keys
    }
    pub fn clear_split_keys(&mut self) {
        self.split_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_split_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.split_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_split_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.split_keys
    }

    // Take field
    pub fn take_split_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.split_keys, ::protobuf::RepeatedField::new())
    }

    // bool is_raw_kv = 4;


    pub fn get_is_raw_kv(&self) -> bool {
        self.is_raw_kv
    }
    pub fn clear_is_raw_kv(&mut self) {
        self.is_raw_kv = false;
    }

    // Param is passed by value, moved
    pub fn set_is_raw_kv(&mut self, v: bool) {
        self.is_raw_kv = v;
    }
}

impl ::protobuf::Message for SplitRegionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.split_key)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.split_keys)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_raw_kv = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.split_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.split_key);
        }
        for value in &self.split_keys {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        if self.is_raw_kv != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.split_key.is_empty() {
            os.write_bytes(2, &self.split_key)?;
        }
        for v in &self.split_keys {
            os.write_bytes(3, &v)?;
        };
        if self.is_raw_kv != false {
            os.write_bool(4, self.is_raw_kv)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SplitRegionRequest {
        SplitRegionRequest::new()
    }

    fn default_instance() -> &'static SplitRegionRequest {
        static mut instance: ::protobuf::lazy::Lazy<SplitRegionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SplitRegionRequest,
        };
        unsafe {
            instance.get(SplitRegionRequest::new)
        }
    }
}

impl ::protobuf::Clear for SplitRegionRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.split_key.clear();
        self.split_keys.clear();
        self.is_raw_kv = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for SplitRegionRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.split_key, "split_key", buf);
        ::protobuf::PbPrint::fmt(&self.split_keys, "split_keys", buf);
        ::protobuf::PbPrint::fmt(&self.is_raw_kv, "is_raw_kv", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for SplitRegionRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.split_key, "split_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.split_keys, "split_keys", &mut s);
        ::protobuf::PbPrint::fmt(&self.is_raw_kv, "is_raw_kv", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for SplitRegionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SplitRegionResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub left: ::protobuf::SingularPtrField<super::metapb::Region>,
    pub right: ::protobuf::SingularPtrField<super::metapb::Region>,
    pub regions: ::protobuf::RepeatedField<super::metapb::Region>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SplitRegionResponse {
    fn default() -> &'a SplitRegionResponse {
        <SplitRegionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SplitRegionResponse {
    pub fn new() -> SplitRegionResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // .metapb.Region left = 2;


    pub fn get_left(&self) -> &super::metapb::Region {
        self.left.as_ref().unwrap_or_else(|| super::metapb::Region::default_instance())
    }
    pub fn clear_left(&mut self) {
        self.left.clear();
    }

    pub fn has_left(&self) -> bool {
        self.left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left(&mut self, v: super::metapb::Region) {
        self.left = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_left(&mut self) -> &mut super::metapb::Region {
        if self.left.is_none() {
            self.left.set_default();
        }
        self.left.as_mut().unwrap()
    }

    // Take field
    pub fn take_left(&mut self) -> super::metapb::Region {
        self.left.take().unwrap_or_else(|| super::metapb::Region::new())
    }

    // .metapb.Region right = 3;


    pub fn get_right(&self) -> &super::metapb::Region {
        self.right.as_ref().unwrap_or_else(|| super::metapb::Region::default_instance())
    }
    pub fn clear_right(&mut self) {
        self.right.clear();
    }

    pub fn has_right(&self) -> bool {
        self.right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right(&mut self, v: super::metapb::Region) {
        self.right = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_right(&mut self) -> &mut super::metapb::Region {
        if self.right.is_none() {
            self.right.set_default();
        }
        self.right.as_mut().unwrap()
    }

    // Take field
    pub fn take_right(&mut self) -> super::metapb::Region {
        self.right.take().unwrap_or_else(|| super::metapb::Region::new())
    }

    // repeated .metapb.Region regions = 4;


    pub fn get_regions(&self) -> &[super::metapb::Region] {
        &self.regions
    }
    pub fn clear_regions(&mut self) {
        self.regions.clear();
    }

    // Param is passed by value, moved
    pub fn set_regions(&mut self, v: ::protobuf::RepeatedField<super::metapb::Region>) {
        self.regions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_regions(&mut self) -> &mut ::protobuf::RepeatedField<super::metapb::Region> {
        &mut self.regions
    }

    // Take field
    pub fn take_regions(&mut self) -> ::protobuf::RepeatedField<super::metapb::Region> {
        ::std::mem::replace(&mut self.regions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SplitRegionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.left {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.right {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.regions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.left)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.right)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.regions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.regions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.left.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.right.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.regions {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SplitRegionResponse {
        SplitRegionResponse::new()
    }

    fn default_instance() -> &'static SplitRegionResponse {
        static mut instance: ::protobuf::lazy::Lazy<SplitRegionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SplitRegionResponse,
        };
        unsafe {
            instance.get(SplitRegionResponse::new)
        }
    }
}

impl ::protobuf::Clear for SplitRegionResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.left.clear();
        self.right.clear();
        self.regions.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for SplitRegionResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.left, "left", buf);
        ::protobuf::PbPrint::fmt(&self.right, "right", buf);
        ::protobuf::PbPrint::fmt(&self.regions, "regions", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for SplitRegionResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.left, "left", &mut s);
        ::protobuf::PbPrint::fmt(&self.right, "right", &mut s);
        ::protobuf::PbPrint::fmt(&self.regions, "regions", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for SplitRegionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadIndexRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub start_ts: u64,
    pub ranges: ::protobuf::RepeatedField<KeyRange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadIndexRequest {
    fn default() -> &'a ReadIndexRequest {
        <ReadIndexRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReadIndexRequest {
    pub fn new() -> ReadIndexRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // uint64 start_ts = 2;


    pub fn get_start_ts(&self) -> u64 {
        self.start_ts
    }
    pub fn clear_start_ts(&mut self) {
        self.start_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_ts(&mut self, v: u64) {
        self.start_ts = v;
    }

    // repeated .kvrpcpb.KeyRange ranges = 3;


    pub fn get_ranges(&self) -> &[KeyRange] {
        &self.ranges
    }
    pub fn clear_ranges(&mut self) {
        self.ranges.clear();
    }

    // Param is passed by value, moved
    pub fn set_ranges(&mut self, v: ::protobuf::RepeatedField<KeyRange>) {
        self.ranges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ranges(&mut self) -> &mut ::protobuf::RepeatedField<KeyRange> {
        &mut self.ranges
    }

    // Take field
    pub fn take_ranges(&mut self) -> ::protobuf::RepeatedField<KeyRange> {
        ::std::mem::replace(&mut self.ranges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ReadIndexRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ranges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_ts = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ranges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.start_ts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.start_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ranges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.start_ts != 0 {
            os.write_uint64(2, self.start_ts)?;
        }
        for v in &self.ranges {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadIndexRequest {
        ReadIndexRequest::new()
    }

    fn default_instance() -> &'static ReadIndexRequest {
        static mut instance: ::protobuf::lazy::Lazy<ReadIndexRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadIndexRequest,
        };
        unsafe {
            instance.get(ReadIndexRequest::new)
        }
    }
}

impl ::protobuf::Clear for ReadIndexRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.start_ts = 0;
        self.ranges.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ReadIndexRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", buf);
        ::protobuf::PbPrint::fmt(&self.ranges, "ranges", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ReadIndexRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.ranges, "ranges", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadIndexRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadIndexResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub read_index: u64,
    pub locked: ::protobuf::SingularPtrField<LockInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadIndexResponse {
    fn default() -> &'a ReadIndexResponse {
        <ReadIndexResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReadIndexResponse {
    pub fn new() -> ReadIndexResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // uint64 read_index = 2;


    pub fn get_read_index(&self) -> u64 {
        self.read_index
    }
    pub fn clear_read_index(&mut self) {
        self.read_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_read_index(&mut self, v: u64) {
        self.read_index = v;
    }

    // .kvrpcpb.LockInfo locked = 3;


    pub fn get_locked(&self) -> &LockInfo {
        self.locked.as_ref().unwrap_or_else(|| LockInfo::default_instance())
    }
    pub fn clear_locked(&mut self) {
        self.locked.clear();
    }

    pub fn has_locked(&self) -> bool {
        self.locked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locked(&mut self, v: LockInfo) {
        self.locked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locked(&mut self) -> &mut LockInfo {
        if self.locked.is_none() {
            self.locked.set_default();
        }
        self.locked.as_mut().unwrap()
    }

    // Take field
    pub fn take_locked(&mut self) -> LockInfo {
        self.locked.take().unwrap_or_else(|| LockInfo::new())
    }
}

impl ::protobuf::Message for ReadIndexResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.locked {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.read_index = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.locked)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.read_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.read_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.locked.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.read_index != 0 {
            os.write_uint64(2, self.read_index)?;
        }
        if let Some(ref v) = self.locked.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadIndexResponse {
        ReadIndexResponse::new()
    }

    fn default_instance() -> &'static ReadIndexResponse {
        static mut instance: ::protobuf::lazy::Lazy<ReadIndexResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadIndexResponse,
        };
        unsafe {
            instance.get(ReadIndexResponse::new)
        }
    }
}

impl ::protobuf::Clear for ReadIndexResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.read_index = 0;
        self.locked.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ReadIndexResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.read_index, "read_index", buf);
        ::protobuf::PbPrint::fmt(&self.locked, "locked", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ReadIndexResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.read_index, "read_index", &mut s);
        ::protobuf::PbPrint::fmt(&self.locked, "locked", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadIndexResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MvccGetByKeyRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub key: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MvccGetByKeyRequest {
    fn default() -> &'a MvccGetByKeyRequest {
        <MvccGetByKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl MvccGetByKeyRequest {
    pub fn new() -> MvccGetByKeyRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // bytes key = 2;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MvccGetByKeyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(2, &self.key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MvccGetByKeyRequest {
        MvccGetByKeyRequest::new()
    }

    fn default_instance() -> &'static MvccGetByKeyRequest {
        static mut instance: ::protobuf::lazy::Lazy<MvccGetByKeyRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MvccGetByKeyRequest,
        };
        unsafe {
            instance.get(MvccGetByKeyRequest::new)
        }
    }
}

impl ::protobuf::Clear for MvccGetByKeyRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for MvccGetByKeyRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for MvccGetByKeyRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for MvccGetByKeyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MvccGetByKeyResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::std::string::String,
    pub info: ::protobuf::SingularPtrField<MvccInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MvccGetByKeyResponse {
    fn default() -> &'a MvccGetByKeyResponse {
        <MvccGetByKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl MvccGetByKeyResponse {
    pub fn new() -> MvccGetByKeyResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // .kvrpcpb.MvccInfo info = 3;


    pub fn get_info(&self) -> &MvccInfo {
        self.info.as_ref().unwrap_or_else(|| MvccInfo::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: MvccInfo) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut MvccInfo {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> MvccInfo {
        self.info.take().unwrap_or_else(|| MvccInfo::new())
    }
}

impl ::protobuf::Message for MvccGetByKeyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MvccGetByKeyResponse {
        MvccGetByKeyResponse::new()
    }

    fn default_instance() -> &'static MvccGetByKeyResponse {
        static mut instance: ::protobuf::lazy::Lazy<MvccGetByKeyResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MvccGetByKeyResponse,
        };
        unsafe {
            instance.get(MvccGetByKeyResponse::new)
        }
    }
}

impl ::protobuf::Clear for MvccGetByKeyResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for MvccGetByKeyResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.info, "info", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for MvccGetByKeyResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.info, "info", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for MvccGetByKeyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MvccGetByStartTsRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub start_ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MvccGetByStartTsRequest {
    fn default() -> &'a MvccGetByStartTsRequest {
        <MvccGetByStartTsRequest as ::protobuf::Message>::default_instance()
    }
}

impl MvccGetByStartTsRequest {
    pub fn new() -> MvccGetByStartTsRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // uint64 start_ts = 2;


    pub fn get_start_ts(&self) -> u64 {
        self.start_ts
    }
    pub fn clear_start_ts(&mut self) {
        self.start_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_ts(&mut self, v: u64) {
        self.start_ts = v;
    }
}

impl ::protobuf::Message for MvccGetByStartTsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.start_ts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.start_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.start_ts != 0 {
            os.write_uint64(2, self.start_ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MvccGetByStartTsRequest {
        MvccGetByStartTsRequest::new()
    }

    fn default_instance() -> &'static MvccGetByStartTsRequest {
        static mut instance: ::protobuf::lazy::Lazy<MvccGetByStartTsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MvccGetByStartTsRequest,
        };
        unsafe {
            instance.get(MvccGetByStartTsRequest::new)
        }
    }
}

impl ::protobuf::Clear for MvccGetByStartTsRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.start_ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for MvccGetByStartTsRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for MvccGetByStartTsRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for MvccGetByStartTsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MvccGetByStartTsResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::std::string::String,
    pub key: ::std::vec::Vec<u8>,
    pub info: ::protobuf::SingularPtrField<MvccInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MvccGetByStartTsResponse {
    fn default() -> &'a MvccGetByStartTsResponse {
        <MvccGetByStartTsResponse as ::protobuf::Message>::default_instance()
    }
}

impl MvccGetByStartTsResponse {
    pub fn new() -> MvccGetByStartTsResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // bytes key = 3;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // .kvrpcpb.MvccInfo info = 4;


    pub fn get_info(&self) -> &MvccInfo {
        self.info.as_ref().unwrap_or_else(|| MvccInfo::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: MvccInfo) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut MvccInfo {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> MvccInfo {
        self.info.take().unwrap_or_else(|| MvccInfo::new())
    }
}

impl ::protobuf::Message for MvccGetByStartTsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.key);
        }
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(3, &self.key)?;
        }
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MvccGetByStartTsResponse {
        MvccGetByStartTsResponse::new()
    }

    fn default_instance() -> &'static MvccGetByStartTsResponse {
        static mut instance: ::protobuf::lazy::Lazy<MvccGetByStartTsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MvccGetByStartTsResponse,
        };
        unsafe {
            instance.get(MvccGetByStartTsResponse::new)
        }
    }
}

impl ::protobuf::Clear for MvccGetByStartTsResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.key.clear();
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for MvccGetByStartTsResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        ::protobuf::PbPrint::fmt(&self.info, "info", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for MvccGetByStartTsResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        ::protobuf::PbPrint::fmt(&self.info, "info", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for MvccGetByStartTsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Context {
    // message fields
    pub region_id: u64,
    pub region_epoch: ::protobuf::SingularPtrField<super::metapb::RegionEpoch>,
    pub peer: ::protobuf::SingularPtrField<super::metapb::Peer>,
    pub term: u64,
    pub priority: CommandPri,
    pub isolation_level: IsolationLevel,
    pub not_fill_cache: bool,
    pub sync_log: bool,
    pub record_time_stat: bool,
    pub record_scan_stat: bool,
    pub replica_read: bool,
    pub resolved_locks: ::std::vec::Vec<u64>,
    pub max_execution_duration_ms: u64,
    pub applied_index: u64,
    pub task_id: u64,
    pub stale_read: bool,
    pub resource_group_tag: ::std::vec::Vec<u8>,
    pub disk_full_opt: DiskFullOpt,
    pub is_retry_request: bool,
    pub api_version: ApiVersion,
    pub committed_locks: ::std::vec::Vec<u64>,
    pub trace_context: ::protobuf::SingularPtrField<super::tracepb::TraceContext>,
    pub request_source: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Context {
    fn default() -> &'a Context {
        <Context as ::protobuf::Message>::default_instance()
    }
}

impl Context {
    pub fn new() -> Context {
        ::std::default::Default::default()
    }

    // uint64 region_id = 1;


    pub fn get_region_id(&self) -> u64 {
        self.region_id
    }
    pub fn clear_region_id(&mut self) {
        self.region_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_region_id(&mut self, v: u64) {
        self.region_id = v;
    }

    // .metapb.RegionEpoch region_epoch = 2;


    pub fn get_region_epoch(&self) -> &super::metapb::RegionEpoch {
        self.region_epoch.as_ref().unwrap_or_else(|| super::metapb::RegionEpoch::default_instance())
    }
    pub fn clear_region_epoch(&mut self) {
        self.region_epoch.clear();
    }

    pub fn has_region_epoch(&self) -> bool {
        self.region_epoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_epoch(&mut self, v: super::metapb::RegionEpoch) {
        self.region_epoch = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_epoch(&mut self) -> &mut super::metapb::RegionEpoch {
        if self.region_epoch.is_none() {
            self.region_epoch.set_default();
        }
        self.region_epoch.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_epoch(&mut self) -> super::metapb::RegionEpoch {
        self.region_epoch.take().unwrap_or_else(|| super::metapb::RegionEpoch::new())
    }

    // .metapb.Peer peer = 3;


    pub fn get_peer(&self) -> &super::metapb::Peer {
        self.peer.as_ref().unwrap_or_else(|| super::metapb::Peer::default_instance())
    }
    pub fn clear_peer(&mut self) {
        self.peer.clear();
    }

    pub fn has_peer(&self) -> bool {
        self.peer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer(&mut self, v: super::metapb::Peer) {
        self.peer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer(&mut self) -> &mut super::metapb::Peer {
        if self.peer.is_none() {
            self.peer.set_default();
        }
        self.peer.as_mut().unwrap()
    }

    // Take field
    pub fn take_peer(&mut self) -> super::metapb::Peer {
        self.peer.take().unwrap_or_else(|| super::metapb::Peer::new())
    }

    // uint64 term = 5;


    pub fn get_term(&self) -> u64 {
        self.term
    }
    pub fn clear_term(&mut self) {
        self.term = 0;
    }

    // Param is passed by value, moved
    pub fn set_term(&mut self, v: u64) {
        self.term = v;
    }

    // .kvrpcpb.CommandPri priority = 6;


    pub fn get_priority(&self) -> CommandPri {
        self.priority
    }
    pub fn clear_priority(&mut self) {
        self.priority = CommandPri::Normal;
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: CommandPri) {
        self.priority = v;
    }

    // .kvrpcpb.IsolationLevel isolation_level = 7;


    pub fn get_isolation_level(&self) -> IsolationLevel {
        self.isolation_level
    }
    pub fn clear_isolation_level(&mut self) {
        self.isolation_level = IsolationLevel::Si;
    }

    // Param is passed by value, moved
    pub fn set_isolation_level(&mut self, v: IsolationLevel) {
        self.isolation_level = v;
    }

    // bool not_fill_cache = 8;


    pub fn get_not_fill_cache(&self) -> bool {
        self.not_fill_cache
    }
    pub fn clear_not_fill_cache(&mut self) {
        self.not_fill_cache = false;
    }

    // Param is passed by value, moved
    pub fn set_not_fill_cache(&mut self, v: bool) {
        self.not_fill_cache = v;
    }

    // bool sync_log = 9;


    pub fn get_sync_log(&self) -> bool {
        self.sync_log
    }
    pub fn clear_sync_log(&mut self) {
        self.sync_log = false;
    }

    // Param is passed by value, moved
    pub fn set_sync_log(&mut self, v: bool) {
        self.sync_log = v;
    }

    // bool record_time_stat = 10;


    pub fn get_record_time_stat(&self) -> bool {
        self.record_time_stat
    }
    pub fn clear_record_time_stat(&mut self) {
        self.record_time_stat = false;
    }

    // Param is passed by value, moved
    pub fn set_record_time_stat(&mut self, v: bool) {
        self.record_time_stat = v;
    }

    // bool record_scan_stat = 11;


    pub fn get_record_scan_stat(&self) -> bool {
        self.record_scan_stat
    }
    pub fn clear_record_scan_stat(&mut self) {
        self.record_scan_stat = false;
    }

    // Param is passed by value, moved
    pub fn set_record_scan_stat(&mut self, v: bool) {
        self.record_scan_stat = v;
    }

    // bool replica_read = 12;


    pub fn get_replica_read(&self) -> bool {
        self.replica_read
    }
    pub fn clear_replica_read(&mut self) {
        self.replica_read = false;
    }

    // Param is passed by value, moved
    pub fn set_replica_read(&mut self, v: bool) {
        self.replica_read = v;
    }

    // repeated uint64 resolved_locks = 13;


    pub fn get_resolved_locks(&self) -> &[u64] {
        &self.resolved_locks
    }
    pub fn clear_resolved_locks(&mut self) {
        self.resolved_locks.clear();
    }

    // Param is passed by value, moved
    pub fn set_resolved_locks(&mut self, v: ::std::vec::Vec<u64>) {
        self.resolved_locks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resolved_locks(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.resolved_locks
    }

    // Take field
    pub fn take_resolved_locks(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.resolved_locks, ::std::vec::Vec::new())
    }

    // uint64 max_execution_duration_ms = 14;


    pub fn get_max_execution_duration_ms(&self) -> u64 {
        self.max_execution_duration_ms
    }
    pub fn clear_max_execution_duration_ms(&mut self) {
        self.max_execution_duration_ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_execution_duration_ms(&mut self, v: u64) {
        self.max_execution_duration_ms = v;
    }

    // uint64 applied_index = 15;


    pub fn get_applied_index(&self) -> u64 {
        self.applied_index
    }
    pub fn clear_applied_index(&mut self) {
        self.applied_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_applied_index(&mut self, v: u64) {
        self.applied_index = v;
    }

    // uint64 task_id = 16;


    pub fn get_task_id(&self) -> u64 {
        self.task_id
    }
    pub fn clear_task_id(&mut self) {
        self.task_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: u64) {
        self.task_id = v;
    }

    // bool stale_read = 17;


    pub fn get_stale_read(&self) -> bool {
        self.stale_read
    }
    pub fn clear_stale_read(&mut self) {
        self.stale_read = false;
    }

    // Param is passed by value, moved
    pub fn set_stale_read(&mut self, v: bool) {
        self.stale_read = v;
    }

    // bytes resource_group_tag = 18;


    pub fn get_resource_group_tag(&self) -> &[u8] {
        &self.resource_group_tag
    }
    pub fn clear_resource_group_tag(&mut self) {
        self.resource_group_tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_group_tag(&mut self, v: ::std::vec::Vec<u8>) {
        self.resource_group_tag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource_group_tag(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.resource_group_tag
    }

    // Take field
    pub fn take_resource_group_tag(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.resource_group_tag, ::std::vec::Vec::new())
    }

    // .kvrpcpb.DiskFullOpt disk_full_opt = 19;


    pub fn get_disk_full_opt(&self) -> DiskFullOpt {
        self.disk_full_opt
    }
    pub fn clear_disk_full_opt(&mut self) {
        self.disk_full_opt = DiskFullOpt::NotAllowedOnFull;
    }

    // Param is passed by value, moved
    pub fn set_disk_full_opt(&mut self, v: DiskFullOpt) {
        self.disk_full_opt = v;
    }

    // bool is_retry_request = 20;


    pub fn get_is_retry_request(&self) -> bool {
        self.is_retry_request
    }
    pub fn clear_is_retry_request(&mut self) {
        self.is_retry_request = false;
    }

    // Param is passed by value, moved
    pub fn set_is_retry_request(&mut self, v: bool) {
        self.is_retry_request = v;
    }

    // .kvrpcpb.APIVersion api_version = 21;


    pub fn get_api_version(&self) -> ApiVersion {
        self.api_version
    }
    pub fn clear_api_version(&mut self) {
        self.api_version = ApiVersion::V1;
    }

    // Param is passed by value, moved
    pub fn set_api_version(&mut self, v: ApiVersion) {
        self.api_version = v;
    }

    // repeated uint64 committed_locks = 22;


    pub fn get_committed_locks(&self) -> &[u64] {
        &self.committed_locks
    }
    pub fn clear_committed_locks(&mut self) {
        self.committed_locks.clear();
    }

    // Param is passed by value, moved
    pub fn set_committed_locks(&mut self, v: ::std::vec::Vec<u64>) {
        self.committed_locks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_committed_locks(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.committed_locks
    }

    // Take field
    pub fn take_committed_locks(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.committed_locks, ::std::vec::Vec::new())
    }

    // .tracepb.TraceContext trace_context = 23;


    pub fn get_trace_context(&self) -> &super::tracepb::TraceContext {
        self.trace_context.as_ref().unwrap_or_else(|| super::tracepb::TraceContext::default_instance())
    }
    pub fn clear_trace_context(&mut self) {
        self.trace_context.clear();
    }

    pub fn has_trace_context(&self) -> bool {
        self.trace_context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trace_context(&mut self, v: super::tracepb::TraceContext) {
        self.trace_context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_context(&mut self) -> &mut super::tracepb::TraceContext {
        if self.trace_context.is_none() {
            self.trace_context.set_default();
        }
        self.trace_context.as_mut().unwrap()
    }

    // Take field
    pub fn take_trace_context(&mut self) -> super::tracepb::TraceContext {
        self.trace_context.take().unwrap_or_else(|| super::tracepb::TraceContext::new())
    }

    // string request_source = 24;


    pub fn get_request_source(&self) -> &str {
        &self.request_source
    }
    pub fn clear_request_source(&mut self) {
        self.request_source.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_source(&mut self, v: ::std::string::String) {
        self.request_source = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request_source(&mut self) -> &mut ::std::string::String {
        &mut self.request_source
    }

    // Take field
    pub fn take_request_source(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.request_source, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Context {
    fn is_initialized(&self) -> bool {
        for v in &self.region_epoch {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.peer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trace_context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.region_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_epoch)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.peer)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.term = tmp;
                },
                6 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.priority = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                7 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.isolation_level = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.not_fill_cache = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sync_log = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.record_time_stat = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.record_scan_stat = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.replica_read = tmp;
                },
                13 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.resolved_locks)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_execution_duration_ms = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.applied_index = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.task_id = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stale_read = tmp;
                },
                18 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.resource_group_tag)?;
                },
                19 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.disk_full_opt = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_retry_request = tmp;
                },
                21 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.api_version = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                22 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.committed_locks)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trace_context)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.request_source)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.region_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.region_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.region_epoch.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.peer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.term != 0 {
            my_size += ::protobuf::rt::value_size(5, self.term, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.priority != CommandPri::Normal {
            my_size += ::protobuf::rt::enum_size(6, self.priority);
        }
        if self.isolation_level != IsolationLevel::Si {
            my_size += ::protobuf::rt::enum_size(7, self.isolation_level);
        }
        if self.not_fill_cache != false {
            my_size += 2;
        }
        if self.sync_log != false {
            my_size += 2;
        }
        if self.record_time_stat != false {
            my_size += 2;
        }
        if self.record_scan_stat != false {
            my_size += 2;
        }
        if self.replica_read != false {
            my_size += 2;
        }
        for value in &self.resolved_locks {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.max_execution_duration_ms != 0 {
            my_size += ::protobuf::rt::value_size(14, self.max_execution_duration_ms, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.applied_index != 0 {
            my_size += ::protobuf::rt::value_size(15, self.applied_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.task_id != 0 {
            my_size += ::protobuf::rt::value_size(16, self.task_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.stale_read != false {
            my_size += 3;
        }
        if !self.resource_group_tag.is_empty() {
            my_size += ::protobuf::rt::bytes_size(18, &self.resource_group_tag);
        }
        if self.disk_full_opt != DiskFullOpt::NotAllowedOnFull {
            my_size += ::protobuf::rt::enum_size(19, self.disk_full_opt);
        }
        if self.is_retry_request != false {
            my_size += 3;
        }
        if self.api_version != ApiVersion::V1 {
            my_size += ::protobuf::rt::enum_size(21, self.api_version);
        }
        for value in &self.committed_locks {
            my_size += ::protobuf::rt::value_size(22, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.trace_context.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.request_source.is_empty() {
            my_size += ::protobuf::rt::string_size(24, &self.request_source);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.region_id != 0 {
            os.write_uint64(1, self.region_id)?;
        }
        if let Some(ref v) = self.region_epoch.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.peer.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.term != 0 {
            os.write_uint64(5, self.term)?;
        }
        if self.priority != CommandPri::Normal {
            os.write_enum(6, self.priority.value())?;
        }
        if self.isolation_level != IsolationLevel::Si {
            os.write_enum(7, self.isolation_level.value())?;
        }
        if self.not_fill_cache != false {
            os.write_bool(8, self.not_fill_cache)?;
        }
        if self.sync_log != false {
            os.write_bool(9, self.sync_log)?;
        }
        if self.record_time_stat != false {
            os.write_bool(10, self.record_time_stat)?;
        }
        if self.record_scan_stat != false {
            os.write_bool(11, self.record_scan_stat)?;
        }
        if self.replica_read != false {
            os.write_bool(12, self.replica_read)?;
        }
        for v in &self.resolved_locks {
            os.write_uint64(13, *v)?;
        };
        if self.max_execution_duration_ms != 0 {
            os.write_uint64(14, self.max_execution_duration_ms)?;
        }
        if self.applied_index != 0 {
            os.write_uint64(15, self.applied_index)?;
        }
        if self.task_id != 0 {
            os.write_uint64(16, self.task_id)?;
        }
        if self.stale_read != false {
            os.write_bool(17, self.stale_read)?;
        }
        if !self.resource_group_tag.is_empty() {
            os.write_bytes(18, &self.resource_group_tag)?;
        }
        if self.disk_full_opt != DiskFullOpt::NotAllowedOnFull {
            os.write_enum(19, self.disk_full_opt.value())?;
        }
        if self.is_retry_request != false {
            os.write_bool(20, self.is_retry_request)?;
        }
        if self.api_version != ApiVersion::V1 {
            os.write_enum(21, self.api_version.value())?;
        }
        for v in &self.committed_locks {
            os.write_uint64(22, *v)?;
        };
        if let Some(ref v) = self.trace_context.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.request_source.is_empty() {
            os.write_string(24, &self.request_source)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Context {
        Context::new()
    }

    fn default_instance() -> &'static Context {
        static mut instance: ::protobuf::lazy::Lazy<Context> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Context,
        };
        unsafe {
            instance.get(Context::new)
        }
    }
}

impl ::protobuf::Clear for Context {
    fn clear(&mut self) {
        self.region_id = 0;
        self.region_epoch.clear();
        self.peer.clear();
        self.term = 0;
        self.priority = CommandPri::Normal;
        self.isolation_level = IsolationLevel::Si;
        self.not_fill_cache = false;
        self.sync_log = false;
        self.record_time_stat = false;
        self.record_scan_stat = false;
        self.replica_read = false;
        self.resolved_locks.clear();
        self.max_execution_duration_ms = 0;
        self.applied_index = 0;
        self.task_id = 0;
        self.stale_read = false;
        self.resource_group_tag.clear();
        self.disk_full_opt = DiskFullOpt::NotAllowedOnFull;
        self.is_retry_request = false;
        self.api_version = ApiVersion::V1;
        self.committed_locks.clear();
        self.trace_context.clear();
        self.request_source.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for Context {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_id, "region_id", buf);
        ::protobuf::PbPrint::fmt(&self.region_epoch, "region_epoch", buf);
        ::protobuf::PbPrint::fmt(&self.peer, "peer", buf);
        ::protobuf::PbPrint::fmt(&self.term, "term", buf);
        ::protobuf::PbPrint::fmt(&self.priority, "priority", buf);
        ::protobuf::PbPrint::fmt(&self.isolation_level, "isolation_level", buf);
        ::protobuf::PbPrint::fmt(&self.not_fill_cache, "not_fill_cache", buf);
        ::protobuf::PbPrint::fmt(&self.sync_log, "sync_log", buf);
        ::protobuf::PbPrint::fmt(&self.record_time_stat, "record_time_stat", buf);
        ::protobuf::PbPrint::fmt(&self.record_scan_stat, "record_scan_stat", buf);
        ::protobuf::PbPrint::fmt(&self.replica_read, "replica_read", buf);
        ::protobuf::PbPrint::fmt(&self.resolved_locks, "resolved_locks", buf);
        ::protobuf::PbPrint::fmt(&self.max_execution_duration_ms, "max_execution_duration_ms", buf);
        ::protobuf::PbPrint::fmt(&self.applied_index, "applied_index", buf);
        ::protobuf::PbPrint::fmt(&self.task_id, "task_id", buf);
        ::protobuf::PbPrint::fmt(&self.stale_read, "stale_read", buf);
        ::protobuf::PbPrint::fmt(&self.resource_group_tag, "resource_group_tag", buf);
        ::protobuf::PbPrint::fmt(&self.disk_full_opt, "disk_full_opt", buf);
        ::protobuf::PbPrint::fmt(&self.is_retry_request, "is_retry_request", buf);
        ::protobuf::PbPrint::fmt(&self.api_version, "api_version", buf);
        ::protobuf::PbPrint::fmt(&self.committed_locks, "committed_locks", buf);
        ::protobuf::PbPrint::fmt(&self.trace_context, "trace_context", buf);
        ::protobuf::PbPrint::fmt(&self.request_source, "request_source", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for Context {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_id, "region_id", &mut s);
        ::protobuf::PbPrint::fmt(&self.region_epoch, "region_epoch", &mut s);
        ::protobuf::PbPrint::fmt(&self.peer, "peer", &mut s);
        ::protobuf::PbPrint::fmt(&self.term, "term", &mut s);
        ::protobuf::PbPrint::fmt(&self.priority, "priority", &mut s);
        ::protobuf::PbPrint::fmt(&self.isolation_level, "isolation_level", &mut s);
        ::protobuf::PbPrint::fmt(&self.not_fill_cache, "not_fill_cache", &mut s);
        ::protobuf::PbPrint::fmt(&self.sync_log, "sync_log", &mut s);
        ::protobuf::PbPrint::fmt(&self.record_time_stat, "record_time_stat", &mut s);
        ::protobuf::PbPrint::fmt(&self.record_scan_stat, "record_scan_stat", &mut s);
        ::protobuf::PbPrint::fmt(&self.replica_read, "replica_read", &mut s);
        ::protobuf::PbPrint::fmt(&self.resolved_locks, "resolved_locks", &mut s);
        ::protobuf::PbPrint::fmt(&self.max_execution_duration_ms, "max_execution_duration_ms", &mut s);
        ::protobuf::PbPrint::fmt(&self.applied_index, "applied_index", &mut s);
        ::protobuf::PbPrint::fmt(&self.task_id, "task_id", &mut s);
        ::protobuf::PbPrint::fmt(&self.stale_read, "stale_read", &mut s);
        ::protobuf::PbPrint::fmt(&self.resource_group_tag, "resource_group_tag", &mut s);
        ::protobuf::PbPrint::fmt(&self.disk_full_opt, "disk_full_opt", &mut s);
        ::protobuf::PbPrint::fmt(&self.is_retry_request, "is_retry_request", &mut s);
        ::protobuf::PbPrint::fmt(&self.api_version, "api_version", &mut s);
        ::protobuf::PbPrint::fmt(&self.committed_locks, "committed_locks", &mut s);
        ::protobuf::PbPrint::fmt(&self.trace_context, "trace_context", &mut s);
        ::protobuf::PbPrint::fmt(&self.request_source, "request_source", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for Context {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LockInfo {
    // message fields
    pub primary_lock: ::std::vec::Vec<u8>,
    pub lock_version: u64,
    pub key: ::std::vec::Vec<u8>,
    pub lock_ttl: u64,
    pub txn_size: u64,
    pub lock_type: Op,
    pub lock_for_update_ts: u64,
    pub use_async_commit: bool,
    pub min_commit_ts: u64,
    pub secondaries: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LockInfo {
    fn default() -> &'a LockInfo {
        <LockInfo as ::protobuf::Message>::default_instance()
    }
}

impl LockInfo {
    pub fn new() -> LockInfo {
        ::std::default::Default::default()
    }

    // bytes primary_lock = 1;


    pub fn get_primary_lock(&self) -> &[u8] {
        &self.primary_lock
    }
    pub fn clear_primary_lock(&mut self) {
        self.primary_lock.clear();
    }

    // Param is passed by value, moved
    pub fn set_primary_lock(&mut self, v: ::std::vec::Vec<u8>) {
        self.primary_lock = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary_lock(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.primary_lock
    }

    // Take field
    pub fn take_primary_lock(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.primary_lock, ::std::vec::Vec::new())
    }

    // uint64 lock_version = 2;


    pub fn get_lock_version(&self) -> u64 {
        self.lock_version
    }
    pub fn clear_lock_version(&mut self) {
        self.lock_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_lock_version(&mut self, v: u64) {
        self.lock_version = v;
    }

    // bytes key = 3;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // uint64 lock_ttl = 4;


    pub fn get_lock_ttl(&self) -> u64 {
        self.lock_ttl
    }
    pub fn clear_lock_ttl(&mut self) {
        self.lock_ttl = 0;
    }

    // Param is passed by value, moved
    pub fn set_lock_ttl(&mut self, v: u64) {
        self.lock_ttl = v;
    }

    // uint64 txn_size = 5;


    pub fn get_txn_size(&self) -> u64 {
        self.txn_size
    }
    pub fn clear_txn_size(&mut self) {
        self.txn_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_txn_size(&mut self, v: u64) {
        self.txn_size = v;
    }

    // .kvrpcpb.Op lock_type = 6;


    pub fn get_lock_type(&self) -> Op {
        self.lock_type
    }
    pub fn clear_lock_type(&mut self) {
        self.lock_type = Op::Put;
    }

    // Param is passed by value, moved
    pub fn set_lock_type(&mut self, v: Op) {
        self.lock_type = v;
    }

    // uint64 lock_for_update_ts = 7;


    pub fn get_lock_for_update_ts(&self) -> u64 {
        self.lock_for_update_ts
    }
    pub fn clear_lock_for_update_ts(&mut self) {
        self.lock_for_update_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_lock_for_update_ts(&mut self, v: u64) {
        self.lock_for_update_ts = v;
    }

    // bool use_async_commit = 8;


    pub fn get_use_async_commit(&self) -> bool {
        self.use_async_commit
    }
    pub fn clear_use_async_commit(&mut self) {
        self.use_async_commit = false;
    }

    // Param is passed by value, moved
    pub fn set_use_async_commit(&mut self, v: bool) {
        self.use_async_commit = v;
    }

    // uint64 min_commit_ts = 9;


    pub fn get_min_commit_ts(&self) -> u64 {
        self.min_commit_ts
    }
    pub fn clear_min_commit_ts(&mut self) {
        self.min_commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_commit_ts(&mut self, v: u64) {
        self.min_commit_ts = v;
    }

    // repeated bytes secondaries = 10;


    pub fn get_secondaries(&self) -> &[::std::vec::Vec<u8>] {
        &self.secondaries
    }
    pub fn clear_secondaries(&mut self) {
        self.secondaries.clear();
    }

    // Param is passed by value, moved
    pub fn set_secondaries(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.secondaries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_secondaries(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.secondaries
    }

    // Take field
    pub fn take_secondaries(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.secondaries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LockInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.primary_lock)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lock_version = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lock_ttl = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txn_size = tmp;
                },
                6 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.lock_type = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lock_for_update_ts = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_async_commit = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.min_commit_ts = tmp;
                },
                10 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.secondaries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.primary_lock.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.primary_lock);
        }
        if self.lock_version != 0 {
            my_size += ::protobuf::rt::value_size(2, self.lock_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.key);
        }
        if self.lock_ttl != 0 {
            my_size += ::protobuf::rt::value_size(4, self.lock_ttl, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.txn_size != 0 {
            my_size += ::protobuf::rt::value_size(5, self.txn_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.lock_type != Op::Put {
            my_size += ::protobuf::rt::enum_size(6, self.lock_type);
        }
        if self.lock_for_update_ts != 0 {
            my_size += ::protobuf::rt::value_size(7, self.lock_for_update_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.use_async_commit != false {
            my_size += 2;
        }
        if self.min_commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(9, self.min_commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.secondaries {
            my_size += ::protobuf::rt::bytes_size(10, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.primary_lock.is_empty() {
            os.write_bytes(1, &self.primary_lock)?;
        }
        if self.lock_version != 0 {
            os.write_uint64(2, self.lock_version)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(3, &self.key)?;
        }
        if self.lock_ttl != 0 {
            os.write_uint64(4, self.lock_ttl)?;
        }
        if self.txn_size != 0 {
            os.write_uint64(5, self.txn_size)?;
        }
        if self.lock_type != Op::Put {
            os.write_enum(6, self.lock_type.value())?;
        }
        if self.lock_for_update_ts != 0 {
            os.write_uint64(7, self.lock_for_update_ts)?;
        }
        if self.use_async_commit != false {
            os.write_bool(8, self.use_async_commit)?;
        }
        if self.min_commit_ts != 0 {
            os.write_uint64(9, self.min_commit_ts)?;
        }
        for v in &self.secondaries {
            os.write_bytes(10, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LockInfo {
        LockInfo::new()
    }

    fn default_instance() -> &'static LockInfo {
        static mut instance: ::protobuf::lazy::Lazy<LockInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LockInfo,
        };
        unsafe {
            instance.get(LockInfo::new)
        }
    }
}

impl ::protobuf::Clear for LockInfo {
    fn clear(&mut self) {
        self.primary_lock.clear();
        self.lock_version = 0;
        self.key.clear();
        self.lock_ttl = 0;
        self.txn_size = 0;
        self.lock_type = Op::Put;
        self.lock_for_update_ts = 0;
        self.use_async_commit = false;
        self.min_commit_ts = 0;
        self.secondaries.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for LockInfo {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.primary_lock, "primary_lock", buf);
        ::protobuf::PbPrint::fmt(&self.lock_version, "lock_version", buf);
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        ::protobuf::PbPrint::fmt(&self.lock_ttl, "lock_ttl", buf);
        ::protobuf::PbPrint::fmt(&self.txn_size, "txn_size", buf);
        ::protobuf::PbPrint::fmt(&self.lock_type, "lock_type", buf);
        ::protobuf::PbPrint::fmt(&self.lock_for_update_ts, "lock_for_update_ts", buf);
        ::protobuf::PbPrint::fmt(&self.use_async_commit, "use_async_commit", buf);
        ::protobuf::PbPrint::fmt(&self.min_commit_ts, "min_commit_ts", buf);
        ::protobuf::PbPrint::fmt(&self.secondaries, "secondaries", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for LockInfo {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.primary_lock, "primary_lock", &mut s);
        ::protobuf::PbPrint::fmt(&self.lock_version, "lock_version", &mut s);
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        ::protobuf::PbPrint::fmt(&self.lock_ttl, "lock_ttl", &mut s);
        ::protobuf::PbPrint::fmt(&self.txn_size, "txn_size", &mut s);
        ::protobuf::PbPrint::fmt(&self.lock_type, "lock_type", &mut s);
        ::protobuf::PbPrint::fmt(&self.lock_for_update_ts, "lock_for_update_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.use_async_commit, "use_async_commit", &mut s);
        ::protobuf::PbPrint::fmt(&self.min_commit_ts, "min_commit_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.secondaries, "secondaries", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for LockInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyError {
    // message fields
    pub locked: ::protobuf::SingularPtrField<LockInfo>,
    pub retryable: ::std::string::String,
    pub abort: ::std::string::String,
    pub conflict: ::protobuf::SingularPtrField<WriteConflict>,
    pub already_exist: ::protobuf::SingularPtrField<AlreadyExist>,
    pub deadlock: ::protobuf::SingularPtrField<Deadlock>,
    pub commit_ts_expired: ::protobuf::SingularPtrField<CommitTsExpired>,
    pub txn_not_found: ::protobuf::SingularPtrField<TxnNotFound>,
    pub commit_ts_too_large: ::protobuf::SingularPtrField<CommitTsTooLarge>,
    pub assertion_failed: ::protobuf::SingularPtrField<AssertionFailed>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyError {
    fn default() -> &'a KeyError {
        <KeyError as ::protobuf::Message>::default_instance()
    }
}

impl KeyError {
    pub fn new() -> KeyError {
        ::std::default::Default::default()
    }

    // .kvrpcpb.LockInfo locked = 1;


    pub fn get_locked(&self) -> &LockInfo {
        self.locked.as_ref().unwrap_or_else(|| LockInfo::default_instance())
    }
    pub fn clear_locked(&mut self) {
        self.locked.clear();
    }

    pub fn has_locked(&self) -> bool {
        self.locked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locked(&mut self, v: LockInfo) {
        self.locked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locked(&mut self) -> &mut LockInfo {
        if self.locked.is_none() {
            self.locked.set_default();
        }
        self.locked.as_mut().unwrap()
    }

    // Take field
    pub fn take_locked(&mut self) -> LockInfo {
        self.locked.take().unwrap_or_else(|| LockInfo::new())
    }

    // string retryable = 2;


    pub fn get_retryable(&self) -> &str {
        &self.retryable
    }
    pub fn clear_retryable(&mut self) {
        self.retryable.clear();
    }

    // Param is passed by value, moved
    pub fn set_retryable(&mut self, v: ::std::string::String) {
        self.retryable = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retryable(&mut self) -> &mut ::std::string::String {
        &mut self.retryable
    }

    // Take field
    pub fn take_retryable(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.retryable, ::std::string::String::new())
    }

    // string abort = 3;


    pub fn get_abort(&self) -> &str {
        &self.abort
    }
    pub fn clear_abort(&mut self) {
        self.abort.clear();
    }

    // Param is passed by value, moved
    pub fn set_abort(&mut self, v: ::std::string::String) {
        self.abort = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_abort(&mut self) -> &mut ::std::string::String {
        &mut self.abort
    }

    // Take field
    pub fn take_abort(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.abort, ::std::string::String::new())
    }

    // .kvrpcpb.WriteConflict conflict = 4;


    pub fn get_conflict(&self) -> &WriteConflict {
        self.conflict.as_ref().unwrap_or_else(|| WriteConflict::default_instance())
    }
    pub fn clear_conflict(&mut self) {
        self.conflict.clear();
    }

    pub fn has_conflict(&self) -> bool {
        self.conflict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conflict(&mut self, v: WriteConflict) {
        self.conflict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conflict(&mut self) -> &mut WriteConflict {
        if self.conflict.is_none() {
            self.conflict.set_default();
        }
        self.conflict.as_mut().unwrap()
    }

    // Take field
    pub fn take_conflict(&mut self) -> WriteConflict {
        self.conflict.take().unwrap_or_else(|| WriteConflict::new())
    }

    // .kvrpcpb.AlreadyExist already_exist = 5;


    pub fn get_already_exist(&self) -> &AlreadyExist {
        self.already_exist.as_ref().unwrap_or_else(|| AlreadyExist::default_instance())
    }
    pub fn clear_already_exist(&mut self) {
        self.already_exist.clear();
    }

    pub fn has_already_exist(&self) -> bool {
        self.already_exist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_already_exist(&mut self, v: AlreadyExist) {
        self.already_exist = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_already_exist(&mut self) -> &mut AlreadyExist {
        if self.already_exist.is_none() {
            self.already_exist.set_default();
        }
        self.already_exist.as_mut().unwrap()
    }

    // Take field
    pub fn take_already_exist(&mut self) -> AlreadyExist {
        self.already_exist.take().unwrap_or_else(|| AlreadyExist::new())
    }

    // .kvrpcpb.Deadlock deadlock = 6;


    pub fn get_deadlock(&self) -> &Deadlock {
        self.deadlock.as_ref().unwrap_or_else(|| Deadlock::default_instance())
    }
    pub fn clear_deadlock(&mut self) {
        self.deadlock.clear();
    }

    pub fn has_deadlock(&self) -> bool {
        self.deadlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deadlock(&mut self, v: Deadlock) {
        self.deadlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deadlock(&mut self) -> &mut Deadlock {
        if self.deadlock.is_none() {
            self.deadlock.set_default();
        }
        self.deadlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_deadlock(&mut self) -> Deadlock {
        self.deadlock.take().unwrap_or_else(|| Deadlock::new())
    }

    // .kvrpcpb.CommitTsExpired commit_ts_expired = 7;


    pub fn get_commit_ts_expired(&self) -> &CommitTsExpired {
        self.commit_ts_expired.as_ref().unwrap_or_else(|| CommitTsExpired::default_instance())
    }
    pub fn clear_commit_ts_expired(&mut self) {
        self.commit_ts_expired.clear();
    }

    pub fn has_commit_ts_expired(&self) -> bool {
        self.commit_ts_expired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commit_ts_expired(&mut self, v: CommitTsExpired) {
        self.commit_ts_expired = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commit_ts_expired(&mut self) -> &mut CommitTsExpired {
        if self.commit_ts_expired.is_none() {
            self.commit_ts_expired.set_default();
        }
        self.commit_ts_expired.as_mut().unwrap()
    }

    // Take field
    pub fn take_commit_ts_expired(&mut self) -> CommitTsExpired {
        self.commit_ts_expired.take().unwrap_or_else(|| CommitTsExpired::new())
    }

    // .kvrpcpb.TxnNotFound txn_not_found = 8;


    pub fn get_txn_not_found(&self) -> &TxnNotFound {
        self.txn_not_found.as_ref().unwrap_or_else(|| TxnNotFound::default_instance())
    }
    pub fn clear_txn_not_found(&mut self) {
        self.txn_not_found.clear();
    }

    pub fn has_txn_not_found(&self) -> bool {
        self.txn_not_found.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_not_found(&mut self, v: TxnNotFound) {
        self.txn_not_found = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txn_not_found(&mut self) -> &mut TxnNotFound {
        if self.txn_not_found.is_none() {
            self.txn_not_found.set_default();
        }
        self.txn_not_found.as_mut().unwrap()
    }

    // Take field
    pub fn take_txn_not_found(&mut self) -> TxnNotFound {
        self.txn_not_found.take().unwrap_or_else(|| TxnNotFound::new())
    }

    // .kvrpcpb.CommitTsTooLarge commit_ts_too_large = 9;


    pub fn get_commit_ts_too_large(&self) -> &CommitTsTooLarge {
        self.commit_ts_too_large.as_ref().unwrap_or_else(|| CommitTsTooLarge::default_instance())
    }
    pub fn clear_commit_ts_too_large(&mut self) {
        self.commit_ts_too_large.clear();
    }

    pub fn has_commit_ts_too_large(&self) -> bool {
        self.commit_ts_too_large.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commit_ts_too_large(&mut self, v: CommitTsTooLarge) {
        self.commit_ts_too_large = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commit_ts_too_large(&mut self) -> &mut CommitTsTooLarge {
        if self.commit_ts_too_large.is_none() {
            self.commit_ts_too_large.set_default();
        }
        self.commit_ts_too_large.as_mut().unwrap()
    }

    // Take field
    pub fn take_commit_ts_too_large(&mut self) -> CommitTsTooLarge {
        self.commit_ts_too_large.take().unwrap_or_else(|| CommitTsTooLarge::new())
    }

    // .kvrpcpb.AssertionFailed assertion_failed = 10;


    pub fn get_assertion_failed(&self) -> &AssertionFailed {
        self.assertion_failed.as_ref().unwrap_or_else(|| AssertionFailed::default_instance())
    }
    pub fn clear_assertion_failed(&mut self) {
        self.assertion_failed.clear();
    }

    pub fn has_assertion_failed(&self) -> bool {
        self.assertion_failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assertion_failed(&mut self, v: AssertionFailed) {
        self.assertion_failed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_assertion_failed(&mut self) -> &mut AssertionFailed {
        if self.assertion_failed.is_none() {
            self.assertion_failed.set_default();
        }
        self.assertion_failed.as_mut().unwrap()
    }

    // Take field
    pub fn take_assertion_failed(&mut self) -> AssertionFailed {
        self.assertion_failed.take().unwrap_or_else(|| AssertionFailed::new())
    }
}

impl ::protobuf::Message for KeyError {
    fn is_initialized(&self) -> bool {
        for v in &self.locked {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.conflict {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.already_exist {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deadlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commit_ts_expired {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.txn_not_found {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commit_ts_too_large {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.assertion_failed {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.locked)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.retryable)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.abort)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conflict)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.already_exist)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deadlock)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commit_ts_expired)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.txn_not_found)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commit_ts_too_large)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.assertion_failed)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.locked.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.retryable.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.retryable);
        }
        if !self.abort.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.abort);
        }
        if let Some(ref v) = self.conflict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.already_exist.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.deadlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.commit_ts_expired.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.txn_not_found.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.commit_ts_too_large.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.assertion_failed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.locked.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.retryable.is_empty() {
            os.write_string(2, &self.retryable)?;
        }
        if !self.abort.is_empty() {
            os.write_string(3, &self.abort)?;
        }
        if let Some(ref v) = self.conflict.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.already_exist.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.deadlock.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.commit_ts_expired.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.txn_not_found.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.commit_ts_too_large.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.assertion_failed.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyError {
        KeyError::new()
    }

    fn default_instance() -> &'static KeyError {
        static mut instance: ::protobuf::lazy::Lazy<KeyError> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KeyError,
        };
        unsafe {
            instance.get(KeyError::new)
        }
    }
}

impl ::protobuf::Clear for KeyError {
    fn clear(&mut self) {
        self.locked.clear();
        self.retryable.clear();
        self.abort.clear();
        self.conflict.clear();
        self.already_exist.clear();
        self.deadlock.clear();
        self.commit_ts_expired.clear();
        self.txn_not_found.clear();
        self.commit_ts_too_large.clear();
        self.assertion_failed.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for KeyError {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.locked, "locked", buf);
        ::protobuf::PbPrint::fmt(&self.retryable, "retryable", buf);
        ::protobuf::PbPrint::fmt(&self.abort, "abort", buf);
        ::protobuf::PbPrint::fmt(&self.conflict, "conflict", buf);
        ::protobuf::PbPrint::fmt(&self.already_exist, "already_exist", buf);
        ::protobuf::PbPrint::fmt(&self.deadlock, "deadlock", buf);
        ::protobuf::PbPrint::fmt(&self.commit_ts_expired, "commit_ts_expired", buf);
        ::protobuf::PbPrint::fmt(&self.txn_not_found, "txn_not_found", buf);
        ::protobuf::PbPrint::fmt(&self.commit_ts_too_large, "commit_ts_too_large", buf);
        ::protobuf::PbPrint::fmt(&self.assertion_failed, "assertion_failed", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for KeyError {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.locked, "locked", &mut s);
        ::protobuf::PbPrint::fmt(&self.retryable, "retryable", &mut s);
        ::protobuf::PbPrint::fmt(&self.abort, "abort", &mut s);
        ::protobuf::PbPrint::fmt(&self.conflict, "conflict", &mut s);
        ::protobuf::PbPrint::fmt(&self.already_exist, "already_exist", &mut s);
        ::protobuf::PbPrint::fmt(&self.deadlock, "deadlock", &mut s);
        ::protobuf::PbPrint::fmt(&self.commit_ts_expired, "commit_ts_expired", &mut s);
        ::protobuf::PbPrint::fmt(&self.txn_not_found, "txn_not_found", &mut s);
        ::protobuf::PbPrint::fmt(&self.commit_ts_too_large, "commit_ts_too_large", &mut s);
        ::protobuf::PbPrint::fmt(&self.assertion_failed, "assertion_failed", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyError {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteConflict {
    // message fields
    pub start_ts: u64,
    pub conflict_ts: u64,
    pub key: ::std::vec::Vec<u8>,
    pub primary: ::std::vec::Vec<u8>,
    pub conflict_commit_ts: u64,
    pub reason: WriteConflictReason,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteConflict {
    fn default() -> &'a WriteConflict {
        <WriteConflict as ::protobuf::Message>::default_instance()
    }
}

impl WriteConflict {
    pub fn new() -> WriteConflict {
        ::std::default::Default::default()
    }

    // uint64 start_ts = 1;


    pub fn get_start_ts(&self) -> u64 {
        self.start_ts
    }
    pub fn clear_start_ts(&mut self) {
        self.start_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_ts(&mut self, v: u64) {
        self.start_ts = v;
    }

    // uint64 conflict_ts = 2;


    pub fn get_conflict_ts(&self) -> u64 {
        self.conflict_ts
    }
    pub fn clear_conflict_ts(&mut self) {
        self.conflict_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_conflict_ts(&mut self, v: u64) {
        self.conflict_ts = v;
    }

    // bytes key = 3;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes primary = 4;


    pub fn get_primary(&self) -> &[u8] {
        &self.primary
    }
    pub fn clear_primary(&mut self) {
        self.primary.clear();
    }

    // Param is passed by value, moved
    pub fn set_primary(&mut self, v: ::std::vec::Vec<u8>) {
        self.primary = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.primary
    }

    // Take field
    pub fn take_primary(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.primary, ::std::vec::Vec::new())
    }

    // uint64 conflict_commit_ts = 5;


    pub fn get_conflict_commit_ts(&self) -> u64 {
        self.conflict_commit_ts
    }
    pub fn clear_conflict_commit_ts(&mut self) {
        self.conflict_commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_conflict_commit_ts(&mut self, v: u64) {
        self.conflict_commit_ts = v;
    }

    // .kvrpcpb.WriteConflict.Reason reason = 6;


    pub fn get_reason(&self) -> WriteConflictReason {
        self.reason
    }
    pub fn clear_reason(&mut self) {
        self.reason = WriteConflictReason::Unknown;
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: WriteConflictReason) {
        self.reason = v;
    }
}

impl ::protobuf::Message for WriteConflict {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_ts = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.conflict_ts = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.primary)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.conflict_commit_ts = tmp;
                },
                6 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.reason = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_ts != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.conflict_ts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.conflict_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.key);
        }
        if !self.primary.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.primary);
        }
        if self.conflict_commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(5, self.conflict_commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reason != WriteConflictReason::Unknown {
            my_size += ::protobuf::rt::enum_size(6, self.reason);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.start_ts != 0 {
            os.write_uint64(1, self.start_ts)?;
        }
        if self.conflict_ts != 0 {
            os.write_uint64(2, self.conflict_ts)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(3, &self.key)?;
        }
        if !self.primary.is_empty() {
            os.write_bytes(4, &self.primary)?;
        }
        if self.conflict_commit_ts != 0 {
            os.write_uint64(5, self.conflict_commit_ts)?;
        }
        if self.reason != WriteConflictReason::Unknown {
            os.write_enum(6, self.reason.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteConflict {
        WriteConflict::new()
    }

    fn default_instance() -> &'static WriteConflict {
        static mut instance: ::protobuf::lazy::Lazy<WriteConflict> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteConflict,
        };
        unsafe {
            instance.get(WriteConflict::new)
        }
    }
}

impl ::protobuf::Clear for WriteConflict {
    fn clear(&mut self) {
        self.start_ts = 0;
        self.conflict_ts = 0;
        self.key.clear();
        self.primary.clear();
        self.conflict_commit_ts = 0;
        self.reason = WriteConflictReason::Unknown;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for WriteConflict {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", buf);
        ::protobuf::PbPrint::fmt(&self.conflict_ts, "conflict_ts", buf);
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        ::protobuf::PbPrint::fmt(&self.primary, "primary", buf);
        ::protobuf::PbPrint::fmt(&self.conflict_commit_ts, "conflict_commit_ts", buf);
        ::protobuf::PbPrint::fmt(&self.reason, "reason", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for WriteConflict {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.conflict_ts, "conflict_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        ::protobuf::PbPrint::fmt(&self.primary, "primary", &mut s);
        ::protobuf::PbPrint::fmt(&self.conflict_commit_ts, "conflict_commit_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.reason, "reason", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteConflict {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WriteConflictReason {
    Unknown = 0,
    Optimistic = 1,
    PessimisticRetry = 2,
    SelfRolledBack = 3,
    RcCheckTs = 4,
    LazyUniquenessCheck = 5,
}

impl ::protobuf::ProtobufEnum for WriteConflictReason {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WriteConflictReason> {
        match value {
            0 => ::std::option::Option::Some(WriteConflictReason::Unknown),
            1 => ::std::option::Option::Some(WriteConflictReason::Optimistic),
            2 => ::std::option::Option::Some(WriteConflictReason::PessimisticRetry),
            3 => ::std::option::Option::Some(WriteConflictReason::SelfRolledBack),
            4 => ::std::option::Option::Some(WriteConflictReason::RcCheckTs),
            5 => ::std::option::Option::Some(WriteConflictReason::LazyUniquenessCheck),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WriteConflictReason] = &[
            WriteConflictReason::Unknown,
            WriteConflictReason::Optimistic,
            WriteConflictReason::PessimisticRetry,
            WriteConflictReason::SelfRolledBack,
            WriteConflictReason::RcCheckTs,
            WriteConflictReason::LazyUniquenessCheck,
        ];
        values
    }
}

impl ::std::marker::Copy for WriteConflictReason {
}

impl ::protobuf::PbPrint for WriteConflictReason {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == WriteConflictReason::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for WriteConflictReason {
    fn default() -> Self {
        WriteConflictReason::Unknown
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteConflictReason {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AlreadyExist {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AlreadyExist {
    fn default() -> &'a AlreadyExist {
        <AlreadyExist as ::protobuf::Message>::default_instance()
    }
}

impl AlreadyExist {
    pub fn new() -> AlreadyExist {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AlreadyExist {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AlreadyExist {
        AlreadyExist::new()
    }

    fn default_instance() -> &'static AlreadyExist {
        static mut instance: ::protobuf::lazy::Lazy<AlreadyExist> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AlreadyExist,
        };
        unsafe {
            instance.get(AlreadyExist::new)
        }
    }
}

impl ::protobuf::Clear for AlreadyExist {
    fn clear(&mut self) {
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for AlreadyExist {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for AlreadyExist {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlreadyExist {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Deadlock {
    // message fields
    pub lock_ts: u64,
    pub lock_key: ::std::vec::Vec<u8>,
    pub deadlock_key_hash: u64,
    pub wait_chain: ::protobuf::RepeatedField<super::deadlock::WaitForEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Deadlock {
    fn default() -> &'a Deadlock {
        <Deadlock as ::protobuf::Message>::default_instance()
    }
}

impl Deadlock {
    pub fn new() -> Deadlock {
        ::std::default::Default::default()
    }

    // uint64 lock_ts = 1;


    pub fn get_lock_ts(&self) -> u64 {
        self.lock_ts
    }
    pub fn clear_lock_ts(&mut self) {
        self.lock_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_lock_ts(&mut self, v: u64) {
        self.lock_ts = v;
    }

    // bytes lock_key = 2;


    pub fn get_lock_key(&self) -> &[u8] {
        &self.lock_key
    }
    pub fn clear_lock_key(&mut self) {
        self.lock_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_lock_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.lock_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lock_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.lock_key
    }

    // Take field
    pub fn take_lock_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.lock_key, ::std::vec::Vec::new())
    }

    // uint64 deadlock_key_hash = 3;


    pub fn get_deadlock_key_hash(&self) -> u64 {
        self.deadlock_key_hash
    }
    pub fn clear_deadlock_key_hash(&mut self) {
        self.deadlock_key_hash = 0;
    }

    // Param is passed by value, moved
    pub fn set_deadlock_key_hash(&mut self, v: u64) {
        self.deadlock_key_hash = v;
    }

    // repeated .deadlock.WaitForEntry wait_chain = 4;


    pub fn get_wait_chain(&self) -> &[super::deadlock::WaitForEntry] {
        &self.wait_chain
    }
    pub fn clear_wait_chain(&mut self) {
        self.wait_chain.clear();
    }

    // Param is passed by value, moved
    pub fn set_wait_chain(&mut self, v: ::protobuf::RepeatedField<super::deadlock::WaitForEntry>) {
        self.wait_chain = v;
    }

    // Mutable pointer to the field.
    pub fn mut_wait_chain(&mut self) -> &mut ::protobuf::RepeatedField<super::deadlock::WaitForEntry> {
        &mut self.wait_chain
    }

    // Take field
    pub fn take_wait_chain(&mut self) -> ::protobuf::RepeatedField<super::deadlock::WaitForEntry> {
        ::std::mem::replace(&mut self.wait_chain, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Deadlock {
    fn is_initialized(&self) -> bool {
        for v in &self.wait_chain {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lock_ts = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.lock_key)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.deadlock_key_hash = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.wait_chain)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.lock_ts != 0 {
            my_size += ::protobuf::rt::value_size(1, self.lock_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.lock_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.lock_key);
        }
        if self.deadlock_key_hash != 0 {
            my_size += ::protobuf::rt::value_size(3, self.deadlock_key_hash, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.wait_chain {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.lock_ts != 0 {
            os.write_uint64(1, self.lock_ts)?;
        }
        if !self.lock_key.is_empty() {
            os.write_bytes(2, &self.lock_key)?;
        }
        if self.deadlock_key_hash != 0 {
            os.write_uint64(3, self.deadlock_key_hash)?;
        }
        for v in &self.wait_chain {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Deadlock {
        Deadlock::new()
    }

    fn default_instance() -> &'static Deadlock {
        static mut instance: ::protobuf::lazy::Lazy<Deadlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Deadlock,
        };
        unsafe {
            instance.get(Deadlock::new)
        }
    }
}

impl ::protobuf::Clear for Deadlock {
    fn clear(&mut self) {
        self.lock_ts = 0;
        self.lock_key.clear();
        self.deadlock_key_hash = 0;
        self.wait_chain.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for Deadlock {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.lock_ts, "lock_ts", buf);
        ::protobuf::PbPrint::fmt(&self.lock_key, "lock_key", buf);
        ::protobuf::PbPrint::fmt(&self.deadlock_key_hash, "deadlock_key_hash", buf);
        ::protobuf::PbPrint::fmt(&self.wait_chain, "wait_chain", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for Deadlock {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.lock_ts, "lock_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.lock_key, "lock_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.deadlock_key_hash, "deadlock_key_hash", &mut s);
        ::protobuf::PbPrint::fmt(&self.wait_chain, "wait_chain", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for Deadlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommitTsExpired {
    // message fields
    pub start_ts: u64,
    pub attempted_commit_ts: u64,
    pub key: ::std::vec::Vec<u8>,
    pub min_commit_ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommitTsExpired {
    fn default() -> &'a CommitTsExpired {
        <CommitTsExpired as ::protobuf::Message>::default_instance()
    }
}

impl CommitTsExpired {
    pub fn new() -> CommitTsExpired {
        ::std::default::Default::default()
    }

    // uint64 start_ts = 1;


    pub fn get_start_ts(&self) -> u64 {
        self.start_ts
    }
    pub fn clear_start_ts(&mut self) {
        self.start_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_ts(&mut self, v: u64) {
        self.start_ts = v;
    }

    // uint64 attempted_commit_ts = 2;


    pub fn get_attempted_commit_ts(&self) -> u64 {
        self.attempted_commit_ts
    }
    pub fn clear_attempted_commit_ts(&mut self) {
        self.attempted_commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_attempted_commit_ts(&mut self, v: u64) {
        self.attempted_commit_ts = v;
    }

    // bytes key = 3;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // uint64 min_commit_ts = 4;


    pub fn get_min_commit_ts(&self) -> u64 {
        self.min_commit_ts
    }
    pub fn clear_min_commit_ts(&mut self) {
        self.min_commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_commit_ts(&mut self, v: u64) {
        self.min_commit_ts = v;
    }
}

impl ::protobuf::Message for CommitTsExpired {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_ts = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.attempted_commit_ts = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.min_commit_ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_ts != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.attempted_commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.attempted_commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.key);
        }
        if self.min_commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(4, self.min_commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.start_ts != 0 {
            os.write_uint64(1, self.start_ts)?;
        }
        if self.attempted_commit_ts != 0 {
            os.write_uint64(2, self.attempted_commit_ts)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(3, &self.key)?;
        }
        if self.min_commit_ts != 0 {
            os.write_uint64(4, self.min_commit_ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitTsExpired {
        CommitTsExpired::new()
    }

    fn default_instance() -> &'static CommitTsExpired {
        static mut instance: ::protobuf::lazy::Lazy<CommitTsExpired> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommitTsExpired,
        };
        unsafe {
            instance.get(CommitTsExpired::new)
        }
    }
}

impl ::protobuf::Clear for CommitTsExpired {
    fn clear(&mut self) {
        self.start_ts = 0;
        self.attempted_commit_ts = 0;
        self.key.clear();
        self.min_commit_ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CommitTsExpired {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", buf);
        ::protobuf::PbPrint::fmt(&self.attempted_commit_ts, "attempted_commit_ts", buf);
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        ::protobuf::PbPrint::fmt(&self.min_commit_ts, "min_commit_ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for CommitTsExpired {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.attempted_commit_ts, "attempted_commit_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        ::protobuf::PbPrint::fmt(&self.min_commit_ts, "min_commit_ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitTsExpired {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TxnNotFound {
    // message fields
    pub start_ts: u64,
    pub primary_key: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxnNotFound {
    fn default() -> &'a TxnNotFound {
        <TxnNotFound as ::protobuf::Message>::default_instance()
    }
}

impl TxnNotFound {
    pub fn new() -> TxnNotFound {
        ::std::default::Default::default()
    }

    // uint64 start_ts = 1;


    pub fn get_start_ts(&self) -> u64 {
        self.start_ts
    }
    pub fn clear_start_ts(&mut self) {
        self.start_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_ts(&mut self, v: u64) {
        self.start_ts = v;
    }

    // bytes primary_key = 2;


    pub fn get_primary_key(&self) -> &[u8] {
        &self.primary_key
    }
    pub fn clear_primary_key(&mut self) {
        self.primary_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_primary_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.primary_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.primary_key
    }

    // Take field
    pub fn take_primary_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.primary_key, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TxnNotFound {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_ts = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.primary_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_ts != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.primary_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.primary_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.start_ts != 0 {
            os.write_uint64(1, self.start_ts)?;
        }
        if !self.primary_key.is_empty() {
            os.write_bytes(2, &self.primary_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxnNotFound {
        TxnNotFound::new()
    }

    fn default_instance() -> &'static TxnNotFound {
        static mut instance: ::protobuf::lazy::Lazy<TxnNotFound> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TxnNotFound,
        };
        unsafe {
            instance.get(TxnNotFound::new)
        }
    }
}

impl ::protobuf::Clear for TxnNotFound {
    fn clear(&mut self) {
        self.start_ts = 0;
        self.primary_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for TxnNotFound {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", buf);
        ::protobuf::PbPrint::fmt(&self.primary_key, "primary_key", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for TxnNotFound {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.primary_key, "primary_key", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxnNotFound {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommitTsTooLarge {
    // message fields
    pub commit_ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommitTsTooLarge {
    fn default() -> &'a CommitTsTooLarge {
        <CommitTsTooLarge as ::protobuf::Message>::default_instance()
    }
}

impl CommitTsTooLarge {
    pub fn new() -> CommitTsTooLarge {
        ::std::default::Default::default()
    }

    // uint64 commit_ts = 1;


    pub fn get_commit_ts(&self) -> u64 {
        self.commit_ts
    }
    pub fn clear_commit_ts(&mut self) {
        self.commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_ts(&mut self, v: u64) {
        self.commit_ts = v;
    }
}

impl ::protobuf::Message for CommitTsTooLarge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commit_ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(1, self.commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.commit_ts != 0 {
            os.write_uint64(1, self.commit_ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitTsTooLarge {
        CommitTsTooLarge::new()
    }

    fn default_instance() -> &'static CommitTsTooLarge {
        static mut instance: ::protobuf::lazy::Lazy<CommitTsTooLarge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommitTsTooLarge,
        };
        unsafe {
            instance.get(CommitTsTooLarge::new)
        }
    }
}

impl ::protobuf::Clear for CommitTsTooLarge {
    fn clear(&mut self) {
        self.commit_ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CommitTsTooLarge {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.commit_ts, "commit_ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for CommitTsTooLarge {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.commit_ts, "commit_ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitTsTooLarge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AssertionFailed {
    // message fields
    pub start_ts: u64,
    pub key: ::std::vec::Vec<u8>,
    pub assertion: Assertion,
    pub existing_start_ts: u64,
    pub existing_commit_ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AssertionFailed {
    fn default() -> &'a AssertionFailed {
        <AssertionFailed as ::protobuf::Message>::default_instance()
    }
}

impl AssertionFailed {
    pub fn new() -> AssertionFailed {
        ::std::default::Default::default()
    }

    // uint64 start_ts = 1;


    pub fn get_start_ts(&self) -> u64 {
        self.start_ts
    }
    pub fn clear_start_ts(&mut self) {
        self.start_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_ts(&mut self, v: u64) {
        self.start_ts = v;
    }

    // bytes key = 2;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // .kvrpcpb.Assertion assertion = 3;


    pub fn get_assertion(&self) -> Assertion {
        self.assertion
    }
    pub fn clear_assertion(&mut self) {
        self.assertion = Assertion::None;
    }

    // Param is passed by value, moved
    pub fn set_assertion(&mut self, v: Assertion) {
        self.assertion = v;
    }

    // uint64 existing_start_ts = 4;


    pub fn get_existing_start_ts(&self) -> u64 {
        self.existing_start_ts
    }
    pub fn clear_existing_start_ts(&mut self) {
        self.existing_start_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_existing_start_ts(&mut self, v: u64) {
        self.existing_start_ts = v;
    }

    // uint64 existing_commit_ts = 5;


    pub fn get_existing_commit_ts(&self) -> u64 {
        self.existing_commit_ts
    }
    pub fn clear_existing_commit_ts(&mut self) {
        self.existing_commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_existing_commit_ts(&mut self, v: u64) {
        self.existing_commit_ts = v;
    }
}

impl ::protobuf::Message for AssertionFailed {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_ts = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.assertion = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.existing_start_ts = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.existing_commit_ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_ts != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.key);
        }
        if self.assertion != Assertion::None {
            my_size += ::protobuf::rt::enum_size(3, self.assertion);
        }
        if self.existing_start_ts != 0 {
            my_size += ::protobuf::rt::value_size(4, self.existing_start_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.existing_commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(5, self.existing_commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.start_ts != 0 {
            os.write_uint64(1, self.start_ts)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(2, &self.key)?;
        }
        if self.assertion != Assertion::None {
            os.write_enum(3, self.assertion.value())?;
        }
        if self.existing_start_ts != 0 {
            os.write_uint64(4, self.existing_start_ts)?;
        }
        if self.existing_commit_ts != 0 {
            os.write_uint64(5, self.existing_commit_ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssertionFailed {
        AssertionFailed::new()
    }

    fn default_instance() -> &'static AssertionFailed {
        static mut instance: ::protobuf::lazy::Lazy<AssertionFailed> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AssertionFailed,
        };
        unsafe {
            instance.get(AssertionFailed::new)
        }
    }
}

impl ::protobuf::Clear for AssertionFailed {
    fn clear(&mut self) {
        self.start_ts = 0;
        self.key.clear();
        self.assertion = Assertion::None;
        self.existing_start_ts = 0;
        self.existing_commit_ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for AssertionFailed {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", buf);
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        ::protobuf::PbPrint::fmt(&self.assertion, "assertion", buf);
        ::protobuf::PbPrint::fmt(&self.existing_start_ts, "existing_start_ts", buf);
        ::protobuf::PbPrint::fmt(&self.existing_commit_ts, "existing_commit_ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for AssertionFailed {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        ::protobuf::PbPrint::fmt(&self.assertion, "assertion", &mut s);
        ::protobuf::PbPrint::fmt(&self.existing_start_ts, "existing_start_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.existing_commit_ts, "existing_commit_ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssertionFailed {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeDetail {
    // message fields
    pub wait_wall_time_ms: u64,
    pub process_wall_time_ms: u64,
    pub kv_read_wall_time_ms: u64,
    pub total_rpc_wall_time_ns: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimeDetail {
    fn default() -> &'a TimeDetail {
        <TimeDetail as ::protobuf::Message>::default_instance()
    }
}

impl TimeDetail {
    pub fn new() -> TimeDetail {
        ::std::default::Default::default()
    }

    // uint64 wait_wall_time_ms = 1;


    pub fn get_wait_wall_time_ms(&self) -> u64 {
        self.wait_wall_time_ms
    }
    pub fn clear_wait_wall_time_ms(&mut self) {
        self.wait_wall_time_ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_wait_wall_time_ms(&mut self, v: u64) {
        self.wait_wall_time_ms = v;
    }

    // uint64 process_wall_time_ms = 2;


    pub fn get_process_wall_time_ms(&self) -> u64 {
        self.process_wall_time_ms
    }
    pub fn clear_process_wall_time_ms(&mut self) {
        self.process_wall_time_ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_process_wall_time_ms(&mut self, v: u64) {
        self.process_wall_time_ms = v;
    }

    // uint64 kv_read_wall_time_ms = 3;


    pub fn get_kv_read_wall_time_ms(&self) -> u64 {
        self.kv_read_wall_time_ms
    }
    pub fn clear_kv_read_wall_time_ms(&mut self) {
        self.kv_read_wall_time_ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_kv_read_wall_time_ms(&mut self, v: u64) {
        self.kv_read_wall_time_ms = v;
    }

    // uint64 total_rpc_wall_time_ns = 4;


    pub fn get_total_rpc_wall_time_ns(&self) -> u64 {
        self.total_rpc_wall_time_ns
    }
    pub fn clear_total_rpc_wall_time_ns(&mut self) {
        self.total_rpc_wall_time_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_rpc_wall_time_ns(&mut self, v: u64) {
        self.total_rpc_wall_time_ns = v;
    }
}

impl ::protobuf::Message for TimeDetail {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.wait_wall_time_ms = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.process_wall_time_ms = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.kv_read_wall_time_ms = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_rpc_wall_time_ns = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.wait_wall_time_ms != 0 {
            my_size += ::protobuf::rt::value_size(1, self.wait_wall_time_ms, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.process_wall_time_ms != 0 {
            my_size += ::protobuf::rt::value_size(2, self.process_wall_time_ms, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.kv_read_wall_time_ms != 0 {
            my_size += ::protobuf::rt::value_size(3, self.kv_read_wall_time_ms, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_rpc_wall_time_ns != 0 {
            my_size += ::protobuf::rt::value_size(4, self.total_rpc_wall_time_ns, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.wait_wall_time_ms != 0 {
            os.write_uint64(1, self.wait_wall_time_ms)?;
        }
        if self.process_wall_time_ms != 0 {
            os.write_uint64(2, self.process_wall_time_ms)?;
        }
        if self.kv_read_wall_time_ms != 0 {
            os.write_uint64(3, self.kv_read_wall_time_ms)?;
        }
        if self.total_rpc_wall_time_ns != 0 {
            os.write_uint64(4, self.total_rpc_wall_time_ns)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeDetail {
        TimeDetail::new()
    }

    fn default_instance() -> &'static TimeDetail {
        static mut instance: ::protobuf::lazy::Lazy<TimeDetail> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TimeDetail,
        };
        unsafe {
            instance.get(TimeDetail::new)
        }
    }
}

impl ::protobuf::Clear for TimeDetail {
    fn clear(&mut self) {
        self.wait_wall_time_ms = 0;
        self.process_wall_time_ms = 0;
        self.kv_read_wall_time_ms = 0;
        self.total_rpc_wall_time_ns = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for TimeDetail {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.wait_wall_time_ms, "wait_wall_time_ms", buf);
        ::protobuf::PbPrint::fmt(&self.process_wall_time_ms, "process_wall_time_ms", buf);
        ::protobuf::PbPrint::fmt(&self.kv_read_wall_time_ms, "kv_read_wall_time_ms", buf);
        ::protobuf::PbPrint::fmt(&self.total_rpc_wall_time_ns, "total_rpc_wall_time_ns", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for TimeDetail {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.wait_wall_time_ms, "wait_wall_time_ms", &mut s);
        ::protobuf::PbPrint::fmt(&self.process_wall_time_ms, "process_wall_time_ms", &mut s);
        ::protobuf::PbPrint::fmt(&self.kv_read_wall_time_ms, "kv_read_wall_time_ms", &mut s);
        ::protobuf::PbPrint::fmt(&self.total_rpc_wall_time_ns, "total_rpc_wall_time_ns", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeDetail {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScanInfo {
    // message fields
    pub total: i64,
    pub processed: i64,
    pub read_bytes: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScanInfo {
    fn default() -> &'a ScanInfo {
        <ScanInfo as ::protobuf::Message>::default_instance()
    }
}

impl ScanInfo {
    pub fn new() -> ScanInfo {
        ::std::default::Default::default()
    }

    // int64 total = 1;


    pub fn get_total(&self) -> i64 {
        self.total
    }
    pub fn clear_total(&mut self) {
        self.total = 0;
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: i64) {
        self.total = v;
    }

    // int64 processed = 2;


    pub fn get_processed(&self) -> i64 {
        self.processed
    }
    pub fn clear_processed(&mut self) {
        self.processed = 0;
    }

    // Param is passed by value, moved
    pub fn set_processed(&mut self, v: i64) {
        self.processed = v;
    }

    // int64 read_bytes = 3;


    pub fn get_read_bytes(&self) -> i64 {
        self.read_bytes
    }
    pub fn clear_read_bytes(&mut self) {
        self.read_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_read_bytes(&mut self, v: i64) {
        self.read_bytes = v;
    }
}

impl ::protobuf::Message for ScanInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.processed = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.read_bytes = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.processed != 0 {
            my_size += ::protobuf::rt::value_size(2, self.processed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.read_bytes != 0 {
            my_size += ::protobuf::rt::value_size(3, self.read_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.total != 0 {
            os.write_int64(1, self.total)?;
        }
        if self.processed != 0 {
            os.write_int64(2, self.processed)?;
        }
        if self.read_bytes != 0 {
            os.write_int64(3, self.read_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScanInfo {
        ScanInfo::new()
    }

    fn default_instance() -> &'static ScanInfo {
        static mut instance: ::protobuf::lazy::Lazy<ScanInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScanInfo,
        };
        unsafe {
            instance.get(ScanInfo::new)
        }
    }
}

impl ::protobuf::Clear for ScanInfo {
    fn clear(&mut self) {
        self.total = 0;
        self.processed = 0;
        self.read_bytes = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ScanInfo {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.total, "total", buf);
        ::protobuf::PbPrint::fmt(&self.processed, "processed", buf);
        ::protobuf::PbPrint::fmt(&self.read_bytes, "read_bytes", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ScanInfo {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.total, "total", &mut s);
        ::protobuf::PbPrint::fmt(&self.processed, "processed", &mut s);
        ::protobuf::PbPrint::fmt(&self.read_bytes, "read_bytes", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScanInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScanDetail {
    // message fields
    pub write: ::protobuf::SingularPtrField<ScanInfo>,
    pub lock: ::protobuf::SingularPtrField<ScanInfo>,
    pub data: ::protobuf::SingularPtrField<ScanInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScanDetail {
    fn default() -> &'a ScanDetail {
        <ScanDetail as ::protobuf::Message>::default_instance()
    }
}

impl ScanDetail {
    pub fn new() -> ScanDetail {
        ::std::default::Default::default()
    }

    // .kvrpcpb.ScanInfo write = 1;


    pub fn get_write(&self) -> &ScanInfo {
        self.write.as_ref().unwrap_or_else(|| ScanInfo::default_instance())
    }
    pub fn clear_write(&mut self) {
        self.write.clear();
    }

    pub fn has_write(&self) -> bool {
        self.write.is_some()
    }

    // Param is passed by value, moved
    pub fn set_write(&mut self, v: ScanInfo) {
        self.write = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_write(&mut self) -> &mut ScanInfo {
        if self.write.is_none() {
            self.write.set_default();
        }
        self.write.as_mut().unwrap()
    }

    // Take field
    pub fn take_write(&mut self) -> ScanInfo {
        self.write.take().unwrap_or_else(|| ScanInfo::new())
    }

    // .kvrpcpb.ScanInfo lock = 2;


    pub fn get_lock(&self) -> &ScanInfo {
        self.lock.as_ref().unwrap_or_else(|| ScanInfo::default_instance())
    }
    pub fn clear_lock(&mut self) {
        self.lock.clear();
    }

    pub fn has_lock(&self) -> bool {
        self.lock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lock(&mut self, v: ScanInfo) {
        self.lock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lock(&mut self) -> &mut ScanInfo {
        if self.lock.is_none() {
            self.lock.set_default();
        }
        self.lock.as_mut().unwrap()
    }

    // Take field
    pub fn take_lock(&mut self) -> ScanInfo {
        self.lock.take().unwrap_or_else(|| ScanInfo::new())
    }

    // .kvrpcpb.ScanInfo data = 3;


    pub fn get_data(&self) -> &ScanInfo {
        self.data.as_ref().unwrap_or_else(|| ScanInfo::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ScanInfo) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ScanInfo {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ScanInfo {
        self.data.take().unwrap_or_else(|| ScanInfo::new())
    }
}

impl ::protobuf::Message for ScanDetail {
    fn is_initialized(&self) -> bool {
        for v in &self.write {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.write)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lock)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.write.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.write.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lock.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScanDetail {
        ScanDetail::new()
    }

    fn default_instance() -> &'static ScanDetail {
        static mut instance: ::protobuf::lazy::Lazy<ScanDetail> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScanDetail,
        };
        unsafe {
            instance.get(ScanDetail::new)
        }
    }
}

impl ::protobuf::Clear for ScanDetail {
    fn clear(&mut self) {
        self.write.clear();
        self.lock.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ScanDetail {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.write, "write", buf);
        ::protobuf::PbPrint::fmt(&self.lock, "lock", buf);
        ::protobuf::PbPrint::fmt(&self.data, "data", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ScanDetail {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.write, "write", &mut s);
        ::protobuf::PbPrint::fmt(&self.lock, "lock", &mut s);
        ::protobuf::PbPrint::fmt(&self.data, "data", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScanDetail {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScanDetailV2 {
    // message fields
    pub processed_versions: u64,
    pub processed_versions_size: u64,
    pub total_versions: u64,
    pub rocksdb_delete_skipped_count: u64,
    pub rocksdb_key_skipped_count: u64,
    pub rocksdb_block_cache_hit_count: u64,
    pub rocksdb_block_read_count: u64,
    pub rocksdb_block_read_byte: u64,
    pub rocksdb_block_read_nanos: u64,
    pub get_snapshot_nanos: u64,
    pub read_index_propose_wait_nanos: u64,
    pub read_index_confirm_wait_nanos: u64,
    pub read_pool_schedule_wait_nanos: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScanDetailV2 {
    fn default() -> &'a ScanDetailV2 {
        <ScanDetailV2 as ::protobuf::Message>::default_instance()
    }
}

impl ScanDetailV2 {
    pub fn new() -> ScanDetailV2 {
        ::std::default::Default::default()
    }

    // uint64 processed_versions = 1;


    pub fn get_processed_versions(&self) -> u64 {
        self.processed_versions
    }
    pub fn clear_processed_versions(&mut self) {
        self.processed_versions = 0;
    }

    // Param is passed by value, moved
    pub fn set_processed_versions(&mut self, v: u64) {
        self.processed_versions = v;
    }

    // uint64 processed_versions_size = 8;


    pub fn get_processed_versions_size(&self) -> u64 {
        self.processed_versions_size
    }
    pub fn clear_processed_versions_size(&mut self) {
        self.processed_versions_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_processed_versions_size(&mut self, v: u64) {
        self.processed_versions_size = v;
    }

    // uint64 total_versions = 2;


    pub fn get_total_versions(&self) -> u64 {
        self.total_versions
    }
    pub fn clear_total_versions(&mut self) {
        self.total_versions = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_versions(&mut self, v: u64) {
        self.total_versions = v;
    }

    // uint64 rocksdb_delete_skipped_count = 3;


    pub fn get_rocksdb_delete_skipped_count(&self) -> u64 {
        self.rocksdb_delete_skipped_count
    }
    pub fn clear_rocksdb_delete_skipped_count(&mut self) {
        self.rocksdb_delete_skipped_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_rocksdb_delete_skipped_count(&mut self, v: u64) {
        self.rocksdb_delete_skipped_count = v;
    }

    // uint64 rocksdb_key_skipped_count = 4;


    pub fn get_rocksdb_key_skipped_count(&self) -> u64 {
        self.rocksdb_key_skipped_count
    }
    pub fn clear_rocksdb_key_skipped_count(&mut self) {
        self.rocksdb_key_skipped_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_rocksdb_key_skipped_count(&mut self, v: u64) {
        self.rocksdb_key_skipped_count = v;
    }

    // uint64 rocksdb_block_cache_hit_count = 5;


    pub fn get_rocksdb_block_cache_hit_count(&self) -> u64 {
        self.rocksdb_block_cache_hit_count
    }
    pub fn clear_rocksdb_block_cache_hit_count(&mut self) {
        self.rocksdb_block_cache_hit_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_rocksdb_block_cache_hit_count(&mut self, v: u64) {
        self.rocksdb_block_cache_hit_count = v;
    }

    // uint64 rocksdb_block_read_count = 6;


    pub fn get_rocksdb_block_read_count(&self) -> u64 {
        self.rocksdb_block_read_count
    }
    pub fn clear_rocksdb_block_read_count(&mut self) {
        self.rocksdb_block_read_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_rocksdb_block_read_count(&mut self, v: u64) {
        self.rocksdb_block_read_count = v;
    }

    // uint64 rocksdb_block_read_byte = 7;


    pub fn get_rocksdb_block_read_byte(&self) -> u64 {
        self.rocksdb_block_read_byte
    }
    pub fn clear_rocksdb_block_read_byte(&mut self) {
        self.rocksdb_block_read_byte = 0;
    }

    // Param is passed by value, moved
    pub fn set_rocksdb_block_read_byte(&mut self, v: u64) {
        self.rocksdb_block_read_byte = v;
    }

    // uint64 rocksdb_block_read_nanos = 9;


    pub fn get_rocksdb_block_read_nanos(&self) -> u64 {
        self.rocksdb_block_read_nanos
    }
    pub fn clear_rocksdb_block_read_nanos(&mut self) {
        self.rocksdb_block_read_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_rocksdb_block_read_nanos(&mut self, v: u64) {
        self.rocksdb_block_read_nanos = v;
    }

    // uint64 get_snapshot_nanos = 10;


    pub fn get_get_snapshot_nanos(&self) -> u64 {
        self.get_snapshot_nanos
    }
    pub fn clear_get_snapshot_nanos(&mut self) {
        self.get_snapshot_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_get_snapshot_nanos(&mut self, v: u64) {
        self.get_snapshot_nanos = v;
    }

    // uint64 read_index_propose_wait_nanos = 11;


    pub fn get_read_index_propose_wait_nanos(&self) -> u64 {
        self.read_index_propose_wait_nanos
    }
    pub fn clear_read_index_propose_wait_nanos(&mut self) {
        self.read_index_propose_wait_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_read_index_propose_wait_nanos(&mut self, v: u64) {
        self.read_index_propose_wait_nanos = v;
    }

    // uint64 read_index_confirm_wait_nanos = 12;


    pub fn get_read_index_confirm_wait_nanos(&self) -> u64 {
        self.read_index_confirm_wait_nanos
    }
    pub fn clear_read_index_confirm_wait_nanos(&mut self) {
        self.read_index_confirm_wait_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_read_index_confirm_wait_nanos(&mut self, v: u64) {
        self.read_index_confirm_wait_nanos = v;
    }

    // uint64 read_pool_schedule_wait_nanos = 13;


    pub fn get_read_pool_schedule_wait_nanos(&self) -> u64 {
        self.read_pool_schedule_wait_nanos
    }
    pub fn clear_read_pool_schedule_wait_nanos(&mut self) {
        self.read_pool_schedule_wait_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_read_pool_schedule_wait_nanos(&mut self, v: u64) {
        self.read_pool_schedule_wait_nanos = v;
    }
}

impl ::protobuf::Message for ScanDetailV2 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.processed_versions = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.processed_versions_size = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_versions = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rocksdb_delete_skipped_count = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rocksdb_key_skipped_count = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rocksdb_block_cache_hit_count = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rocksdb_block_read_count = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rocksdb_block_read_byte = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rocksdb_block_read_nanos = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.get_snapshot_nanos = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.read_index_propose_wait_nanos = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.read_index_confirm_wait_nanos = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.read_pool_schedule_wait_nanos = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.processed_versions != 0 {
            my_size += ::protobuf::rt::value_size(1, self.processed_versions, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.processed_versions_size != 0 {
            my_size += ::protobuf::rt::value_size(8, self.processed_versions_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_versions != 0 {
            my_size += ::protobuf::rt::value_size(2, self.total_versions, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rocksdb_delete_skipped_count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.rocksdb_delete_skipped_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rocksdb_key_skipped_count != 0 {
            my_size += ::protobuf::rt::value_size(4, self.rocksdb_key_skipped_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rocksdb_block_cache_hit_count != 0 {
            my_size += ::protobuf::rt::value_size(5, self.rocksdb_block_cache_hit_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rocksdb_block_read_count != 0 {
            my_size += ::protobuf::rt::value_size(6, self.rocksdb_block_read_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rocksdb_block_read_byte != 0 {
            my_size += ::protobuf::rt::value_size(7, self.rocksdb_block_read_byte, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rocksdb_block_read_nanos != 0 {
            my_size += ::protobuf::rt::value_size(9, self.rocksdb_block_read_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.get_snapshot_nanos != 0 {
            my_size += ::protobuf::rt::value_size(10, self.get_snapshot_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.read_index_propose_wait_nanos != 0 {
            my_size += ::protobuf::rt::value_size(11, self.read_index_propose_wait_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.read_index_confirm_wait_nanos != 0 {
            my_size += ::protobuf::rt::value_size(12, self.read_index_confirm_wait_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.read_pool_schedule_wait_nanos != 0 {
            my_size += ::protobuf::rt::value_size(13, self.read_pool_schedule_wait_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.processed_versions != 0 {
            os.write_uint64(1, self.processed_versions)?;
        }
        if self.processed_versions_size != 0 {
            os.write_uint64(8, self.processed_versions_size)?;
        }
        if self.total_versions != 0 {
            os.write_uint64(2, self.total_versions)?;
        }
        if self.rocksdb_delete_skipped_count != 0 {
            os.write_uint64(3, self.rocksdb_delete_skipped_count)?;
        }
        if self.rocksdb_key_skipped_count != 0 {
            os.write_uint64(4, self.rocksdb_key_skipped_count)?;
        }
        if self.rocksdb_block_cache_hit_count != 0 {
            os.write_uint64(5, self.rocksdb_block_cache_hit_count)?;
        }
        if self.rocksdb_block_read_count != 0 {
            os.write_uint64(6, self.rocksdb_block_read_count)?;
        }
        if self.rocksdb_block_read_byte != 0 {
            os.write_uint64(7, self.rocksdb_block_read_byte)?;
        }
        if self.rocksdb_block_read_nanos != 0 {
            os.write_uint64(9, self.rocksdb_block_read_nanos)?;
        }
        if self.get_snapshot_nanos != 0 {
            os.write_uint64(10, self.get_snapshot_nanos)?;
        }
        if self.read_index_propose_wait_nanos != 0 {
            os.write_uint64(11, self.read_index_propose_wait_nanos)?;
        }
        if self.read_index_confirm_wait_nanos != 0 {
            os.write_uint64(12, self.read_index_confirm_wait_nanos)?;
        }
        if self.read_pool_schedule_wait_nanos != 0 {
            os.write_uint64(13, self.read_pool_schedule_wait_nanos)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScanDetailV2 {
        ScanDetailV2::new()
    }

    fn default_instance() -> &'static ScanDetailV2 {
        static mut instance: ::protobuf::lazy::Lazy<ScanDetailV2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScanDetailV2,
        };
        unsafe {
            instance.get(ScanDetailV2::new)
        }
    }
}

impl ::protobuf::Clear for ScanDetailV2 {
    fn clear(&mut self) {
        self.processed_versions = 0;
        self.processed_versions_size = 0;
        self.total_versions = 0;
        self.rocksdb_delete_skipped_count = 0;
        self.rocksdb_key_skipped_count = 0;
        self.rocksdb_block_cache_hit_count = 0;
        self.rocksdb_block_read_count = 0;
        self.rocksdb_block_read_byte = 0;
        self.rocksdb_block_read_nanos = 0;
        self.get_snapshot_nanos = 0;
        self.read_index_propose_wait_nanos = 0;
        self.read_index_confirm_wait_nanos = 0;
        self.read_pool_schedule_wait_nanos = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ScanDetailV2 {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.processed_versions, "processed_versions", buf);
        ::protobuf::PbPrint::fmt(&self.processed_versions_size, "processed_versions_size", buf);
        ::protobuf::PbPrint::fmt(&self.total_versions, "total_versions", buf);
        ::protobuf::PbPrint::fmt(&self.rocksdb_delete_skipped_count, "rocksdb_delete_skipped_count", buf);
        ::protobuf::PbPrint::fmt(&self.rocksdb_key_skipped_count, "rocksdb_key_skipped_count", buf);
        ::protobuf::PbPrint::fmt(&self.rocksdb_block_cache_hit_count, "rocksdb_block_cache_hit_count", buf);
        ::protobuf::PbPrint::fmt(&self.rocksdb_block_read_count, "rocksdb_block_read_count", buf);
        ::protobuf::PbPrint::fmt(&self.rocksdb_block_read_byte, "rocksdb_block_read_byte", buf);
        ::protobuf::PbPrint::fmt(&self.rocksdb_block_read_nanos, "rocksdb_block_read_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.get_snapshot_nanos, "get_snapshot_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.read_index_propose_wait_nanos, "read_index_propose_wait_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.read_index_confirm_wait_nanos, "read_index_confirm_wait_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.read_pool_schedule_wait_nanos, "read_pool_schedule_wait_nanos", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ScanDetailV2 {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.processed_versions, "processed_versions", &mut s);
        ::protobuf::PbPrint::fmt(&self.processed_versions_size, "processed_versions_size", &mut s);
        ::protobuf::PbPrint::fmt(&self.total_versions, "total_versions", &mut s);
        ::protobuf::PbPrint::fmt(&self.rocksdb_delete_skipped_count, "rocksdb_delete_skipped_count", &mut s);
        ::protobuf::PbPrint::fmt(&self.rocksdb_key_skipped_count, "rocksdb_key_skipped_count", &mut s);
        ::protobuf::PbPrint::fmt(&self.rocksdb_block_cache_hit_count, "rocksdb_block_cache_hit_count", &mut s);
        ::protobuf::PbPrint::fmt(&self.rocksdb_block_read_count, "rocksdb_block_read_count", &mut s);
        ::protobuf::PbPrint::fmt(&self.rocksdb_block_read_byte, "rocksdb_block_read_byte", &mut s);
        ::protobuf::PbPrint::fmt(&self.rocksdb_block_read_nanos, "rocksdb_block_read_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.get_snapshot_nanos, "get_snapshot_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.read_index_propose_wait_nanos, "read_index_propose_wait_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.read_index_confirm_wait_nanos, "read_index_confirm_wait_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.read_pool_schedule_wait_nanos, "read_pool_schedule_wait_nanos", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScanDetailV2 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecDetails {
    // message fields
    pub time_detail: ::protobuf::SingularPtrField<TimeDetail>,
    pub scan_detail: ::protobuf::SingularPtrField<ScanDetail>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecDetails {
    fn default() -> &'a ExecDetails {
        <ExecDetails as ::protobuf::Message>::default_instance()
    }
}

impl ExecDetails {
    pub fn new() -> ExecDetails {
        ::std::default::Default::default()
    }

    // .kvrpcpb.TimeDetail time_detail = 1;


    pub fn get_time_detail(&self) -> &TimeDetail {
        self.time_detail.as_ref().unwrap_or_else(|| TimeDetail::default_instance())
    }
    pub fn clear_time_detail(&mut self) {
        self.time_detail.clear();
    }

    pub fn has_time_detail(&self) -> bool {
        self.time_detail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_detail(&mut self, v: TimeDetail) {
        self.time_detail = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_detail(&mut self) -> &mut TimeDetail {
        if self.time_detail.is_none() {
            self.time_detail.set_default();
        }
        self.time_detail.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_detail(&mut self) -> TimeDetail {
        self.time_detail.take().unwrap_or_else(|| TimeDetail::new())
    }

    // .kvrpcpb.ScanDetail scan_detail = 2;


    pub fn get_scan_detail(&self) -> &ScanDetail {
        self.scan_detail.as_ref().unwrap_or_else(|| ScanDetail::default_instance())
    }
    pub fn clear_scan_detail(&mut self) {
        self.scan_detail.clear();
    }

    pub fn has_scan_detail(&self) -> bool {
        self.scan_detail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scan_detail(&mut self, v: ScanDetail) {
        self.scan_detail = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scan_detail(&mut self) -> &mut ScanDetail {
        if self.scan_detail.is_none() {
            self.scan_detail.set_default();
        }
        self.scan_detail.as_mut().unwrap()
    }

    // Take field
    pub fn take_scan_detail(&mut self) -> ScanDetail {
        self.scan_detail.take().unwrap_or_else(|| ScanDetail::new())
    }
}

impl ::protobuf::Message for ExecDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.time_detail {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scan_detail {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_detail)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scan_detail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.time_detail.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.scan_detail.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.time_detail.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.scan_detail.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecDetails {
        ExecDetails::new()
    }

    fn default_instance() -> &'static ExecDetails {
        static mut instance: ::protobuf::lazy::Lazy<ExecDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExecDetails,
        };
        unsafe {
            instance.get(ExecDetails::new)
        }
    }
}

impl ::protobuf::Clear for ExecDetails {
    fn clear(&mut self) {
        self.time_detail.clear();
        self.scan_detail.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ExecDetails {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.time_detail, "time_detail", buf);
        ::protobuf::PbPrint::fmt(&self.scan_detail, "scan_detail", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ExecDetails {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.time_detail, "time_detail", &mut s);
        ::protobuf::PbPrint::fmt(&self.scan_detail, "scan_detail", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecDetailsV2 {
    // message fields
    pub time_detail: ::protobuf::SingularPtrField<TimeDetail>,
    pub scan_detail_v2: ::protobuf::SingularPtrField<ScanDetailV2>,
    pub write_detail: ::protobuf::SingularPtrField<WriteDetail>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecDetailsV2 {
    fn default() -> &'a ExecDetailsV2 {
        <ExecDetailsV2 as ::protobuf::Message>::default_instance()
    }
}

impl ExecDetailsV2 {
    pub fn new() -> ExecDetailsV2 {
        ::std::default::Default::default()
    }

    // .kvrpcpb.TimeDetail time_detail = 1;


    pub fn get_time_detail(&self) -> &TimeDetail {
        self.time_detail.as_ref().unwrap_or_else(|| TimeDetail::default_instance())
    }
    pub fn clear_time_detail(&mut self) {
        self.time_detail.clear();
    }

    pub fn has_time_detail(&self) -> bool {
        self.time_detail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_detail(&mut self, v: TimeDetail) {
        self.time_detail = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_detail(&mut self) -> &mut TimeDetail {
        if self.time_detail.is_none() {
            self.time_detail.set_default();
        }
        self.time_detail.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_detail(&mut self) -> TimeDetail {
        self.time_detail.take().unwrap_or_else(|| TimeDetail::new())
    }

    // .kvrpcpb.ScanDetailV2 scan_detail_v2 = 2;


    pub fn get_scan_detail_v2(&self) -> &ScanDetailV2 {
        self.scan_detail_v2.as_ref().unwrap_or_else(|| ScanDetailV2::default_instance())
    }
    pub fn clear_scan_detail_v2(&mut self) {
        self.scan_detail_v2.clear();
    }

    pub fn has_scan_detail_v2(&self) -> bool {
        self.scan_detail_v2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scan_detail_v2(&mut self, v: ScanDetailV2) {
        self.scan_detail_v2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scan_detail_v2(&mut self) -> &mut ScanDetailV2 {
        if self.scan_detail_v2.is_none() {
            self.scan_detail_v2.set_default();
        }
        self.scan_detail_v2.as_mut().unwrap()
    }

    // Take field
    pub fn take_scan_detail_v2(&mut self) -> ScanDetailV2 {
        self.scan_detail_v2.take().unwrap_or_else(|| ScanDetailV2::new())
    }

    // .kvrpcpb.WriteDetail write_detail = 3;


    pub fn get_write_detail(&self) -> &WriteDetail {
        self.write_detail.as_ref().unwrap_or_else(|| WriteDetail::default_instance())
    }
    pub fn clear_write_detail(&mut self) {
        self.write_detail.clear();
    }

    pub fn has_write_detail(&self) -> bool {
        self.write_detail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_write_detail(&mut self, v: WriteDetail) {
        self.write_detail = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_write_detail(&mut self) -> &mut WriteDetail {
        if self.write_detail.is_none() {
            self.write_detail.set_default();
        }
        self.write_detail.as_mut().unwrap()
    }

    // Take field
    pub fn take_write_detail(&mut self) -> WriteDetail {
        self.write_detail.take().unwrap_or_else(|| WriteDetail::new())
    }
}

impl ::protobuf::Message for ExecDetailsV2 {
    fn is_initialized(&self) -> bool {
        for v in &self.time_detail {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scan_detail_v2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.write_detail {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_detail)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scan_detail_v2)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.write_detail)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.time_detail.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.scan_detail_v2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.write_detail.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.time_detail.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.scan_detail_v2.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.write_detail.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecDetailsV2 {
        ExecDetailsV2::new()
    }

    fn default_instance() -> &'static ExecDetailsV2 {
        static mut instance: ::protobuf::lazy::Lazy<ExecDetailsV2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExecDetailsV2,
        };
        unsafe {
            instance.get(ExecDetailsV2::new)
        }
    }
}

impl ::protobuf::Clear for ExecDetailsV2 {
    fn clear(&mut self) {
        self.time_detail.clear();
        self.scan_detail_v2.clear();
        self.write_detail.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ExecDetailsV2 {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.time_detail, "time_detail", buf);
        ::protobuf::PbPrint::fmt(&self.scan_detail_v2, "scan_detail_v2", buf);
        ::protobuf::PbPrint::fmt(&self.write_detail, "write_detail", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ExecDetailsV2 {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.time_detail, "time_detail", &mut s);
        ::protobuf::PbPrint::fmt(&self.scan_detail_v2, "scan_detail_v2", &mut s);
        ::protobuf::PbPrint::fmt(&self.write_detail, "write_detail", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecDetailsV2 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteDetail {
    // message fields
    pub store_batch_wait_nanos: u64,
    pub propose_send_wait_nanos: u64,
    pub persist_log_nanos: u64,
    pub raft_db_write_leader_wait_nanos: u64,
    pub raft_db_sync_log_nanos: u64,
    pub raft_db_write_memtable_nanos: u64,
    pub commit_log_nanos: u64,
    pub apply_batch_wait_nanos: u64,
    pub apply_log_nanos: u64,
    pub apply_mutex_lock_nanos: u64,
    pub apply_write_leader_wait_nanos: u64,
    pub apply_write_wal_nanos: u64,
    pub apply_write_memtable_nanos: u64,
    pub latch_wait_nanos: u64,
    pub process_nanos: u64,
    pub throttle_nanos: u64,
    pub pessimistic_lock_wait_nanos: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteDetail {
    fn default() -> &'a WriteDetail {
        <WriteDetail as ::protobuf::Message>::default_instance()
    }
}

impl WriteDetail {
    pub fn new() -> WriteDetail {
        ::std::default::Default::default()
    }

    // uint64 store_batch_wait_nanos = 1;


    pub fn get_store_batch_wait_nanos(&self) -> u64 {
        self.store_batch_wait_nanos
    }
    pub fn clear_store_batch_wait_nanos(&mut self) {
        self.store_batch_wait_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_store_batch_wait_nanos(&mut self, v: u64) {
        self.store_batch_wait_nanos = v;
    }

    // uint64 propose_send_wait_nanos = 2;


    pub fn get_propose_send_wait_nanos(&self) -> u64 {
        self.propose_send_wait_nanos
    }
    pub fn clear_propose_send_wait_nanos(&mut self) {
        self.propose_send_wait_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_propose_send_wait_nanos(&mut self, v: u64) {
        self.propose_send_wait_nanos = v;
    }

    // uint64 persist_log_nanos = 3;


    pub fn get_persist_log_nanos(&self) -> u64 {
        self.persist_log_nanos
    }
    pub fn clear_persist_log_nanos(&mut self) {
        self.persist_log_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_persist_log_nanos(&mut self, v: u64) {
        self.persist_log_nanos = v;
    }

    // uint64 raft_db_write_leader_wait_nanos = 4;


    pub fn get_raft_db_write_leader_wait_nanos(&self) -> u64 {
        self.raft_db_write_leader_wait_nanos
    }
    pub fn clear_raft_db_write_leader_wait_nanos(&mut self) {
        self.raft_db_write_leader_wait_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_raft_db_write_leader_wait_nanos(&mut self, v: u64) {
        self.raft_db_write_leader_wait_nanos = v;
    }

    // uint64 raft_db_sync_log_nanos = 5;


    pub fn get_raft_db_sync_log_nanos(&self) -> u64 {
        self.raft_db_sync_log_nanos
    }
    pub fn clear_raft_db_sync_log_nanos(&mut self) {
        self.raft_db_sync_log_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_raft_db_sync_log_nanos(&mut self, v: u64) {
        self.raft_db_sync_log_nanos = v;
    }

    // uint64 raft_db_write_memtable_nanos = 6;


    pub fn get_raft_db_write_memtable_nanos(&self) -> u64 {
        self.raft_db_write_memtable_nanos
    }
    pub fn clear_raft_db_write_memtable_nanos(&mut self) {
        self.raft_db_write_memtable_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_raft_db_write_memtable_nanos(&mut self, v: u64) {
        self.raft_db_write_memtable_nanos = v;
    }

    // uint64 commit_log_nanos = 7;


    pub fn get_commit_log_nanos(&self) -> u64 {
        self.commit_log_nanos
    }
    pub fn clear_commit_log_nanos(&mut self) {
        self.commit_log_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_log_nanos(&mut self, v: u64) {
        self.commit_log_nanos = v;
    }

    // uint64 apply_batch_wait_nanos = 8;


    pub fn get_apply_batch_wait_nanos(&self) -> u64 {
        self.apply_batch_wait_nanos
    }
    pub fn clear_apply_batch_wait_nanos(&mut self) {
        self.apply_batch_wait_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_apply_batch_wait_nanos(&mut self, v: u64) {
        self.apply_batch_wait_nanos = v;
    }

    // uint64 apply_log_nanos = 9;


    pub fn get_apply_log_nanos(&self) -> u64 {
        self.apply_log_nanos
    }
    pub fn clear_apply_log_nanos(&mut self) {
        self.apply_log_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_apply_log_nanos(&mut self, v: u64) {
        self.apply_log_nanos = v;
    }

    // uint64 apply_mutex_lock_nanos = 10;


    pub fn get_apply_mutex_lock_nanos(&self) -> u64 {
        self.apply_mutex_lock_nanos
    }
    pub fn clear_apply_mutex_lock_nanos(&mut self) {
        self.apply_mutex_lock_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_apply_mutex_lock_nanos(&mut self, v: u64) {
        self.apply_mutex_lock_nanos = v;
    }

    // uint64 apply_write_leader_wait_nanos = 11;


    pub fn get_apply_write_leader_wait_nanos(&self) -> u64 {
        self.apply_write_leader_wait_nanos
    }
    pub fn clear_apply_write_leader_wait_nanos(&mut self) {
        self.apply_write_leader_wait_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_apply_write_leader_wait_nanos(&mut self, v: u64) {
        self.apply_write_leader_wait_nanos = v;
    }

    // uint64 apply_write_wal_nanos = 12;


    pub fn get_apply_write_wal_nanos(&self) -> u64 {
        self.apply_write_wal_nanos
    }
    pub fn clear_apply_write_wal_nanos(&mut self) {
        self.apply_write_wal_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_apply_write_wal_nanos(&mut self, v: u64) {
        self.apply_write_wal_nanos = v;
    }

    // uint64 apply_write_memtable_nanos = 13;


    pub fn get_apply_write_memtable_nanos(&self) -> u64 {
        self.apply_write_memtable_nanos
    }
    pub fn clear_apply_write_memtable_nanos(&mut self) {
        self.apply_write_memtable_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_apply_write_memtable_nanos(&mut self, v: u64) {
        self.apply_write_memtable_nanos = v;
    }

    // uint64 latch_wait_nanos = 14;


    pub fn get_latch_wait_nanos(&self) -> u64 {
        self.latch_wait_nanos
    }
    pub fn clear_latch_wait_nanos(&mut self) {
        self.latch_wait_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_latch_wait_nanos(&mut self, v: u64) {
        self.latch_wait_nanos = v;
    }

    // uint64 process_nanos = 15;


    pub fn get_process_nanos(&self) -> u64 {
        self.process_nanos
    }
    pub fn clear_process_nanos(&mut self) {
        self.process_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_process_nanos(&mut self, v: u64) {
        self.process_nanos = v;
    }

    // uint64 throttle_nanos = 16;


    pub fn get_throttle_nanos(&self) -> u64 {
        self.throttle_nanos
    }
    pub fn clear_throttle_nanos(&mut self) {
        self.throttle_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_throttle_nanos(&mut self, v: u64) {
        self.throttle_nanos = v;
    }

    // uint64 pessimistic_lock_wait_nanos = 17;


    pub fn get_pessimistic_lock_wait_nanos(&self) -> u64 {
        self.pessimistic_lock_wait_nanos
    }
    pub fn clear_pessimistic_lock_wait_nanos(&mut self) {
        self.pessimistic_lock_wait_nanos = 0;
    }

    // Param is passed by value, moved
    pub fn set_pessimistic_lock_wait_nanos(&mut self, v: u64) {
        self.pessimistic_lock_wait_nanos = v;
    }
}

impl ::protobuf::Message for WriteDetail {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.store_batch_wait_nanos = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.propose_send_wait_nanos = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.persist_log_nanos = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.raft_db_write_leader_wait_nanos = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.raft_db_sync_log_nanos = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.raft_db_write_memtable_nanos = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commit_log_nanos = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.apply_batch_wait_nanos = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.apply_log_nanos = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.apply_mutex_lock_nanos = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.apply_write_leader_wait_nanos = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.apply_write_wal_nanos = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.apply_write_memtable_nanos = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.latch_wait_nanos = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.process_nanos = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.throttle_nanos = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pessimistic_lock_wait_nanos = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.store_batch_wait_nanos != 0 {
            my_size += ::protobuf::rt::value_size(1, self.store_batch_wait_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.propose_send_wait_nanos != 0 {
            my_size += ::protobuf::rt::value_size(2, self.propose_send_wait_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.persist_log_nanos != 0 {
            my_size += ::protobuf::rt::value_size(3, self.persist_log_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.raft_db_write_leader_wait_nanos != 0 {
            my_size += ::protobuf::rt::value_size(4, self.raft_db_write_leader_wait_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.raft_db_sync_log_nanos != 0 {
            my_size += ::protobuf::rt::value_size(5, self.raft_db_sync_log_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.raft_db_write_memtable_nanos != 0 {
            my_size += ::protobuf::rt::value_size(6, self.raft_db_write_memtable_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_log_nanos != 0 {
            my_size += ::protobuf::rt::value_size(7, self.commit_log_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.apply_batch_wait_nanos != 0 {
            my_size += ::protobuf::rt::value_size(8, self.apply_batch_wait_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.apply_log_nanos != 0 {
            my_size += ::protobuf::rt::value_size(9, self.apply_log_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.apply_mutex_lock_nanos != 0 {
            my_size += ::protobuf::rt::value_size(10, self.apply_mutex_lock_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.apply_write_leader_wait_nanos != 0 {
            my_size += ::protobuf::rt::value_size(11, self.apply_write_leader_wait_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.apply_write_wal_nanos != 0 {
            my_size += ::protobuf::rt::value_size(12, self.apply_write_wal_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.apply_write_memtable_nanos != 0 {
            my_size += ::protobuf::rt::value_size(13, self.apply_write_memtable_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latch_wait_nanos != 0 {
            my_size += ::protobuf::rt::value_size(14, self.latch_wait_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.process_nanos != 0 {
            my_size += ::protobuf::rt::value_size(15, self.process_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.throttle_nanos != 0 {
            my_size += ::protobuf::rt::value_size(16, self.throttle_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pessimistic_lock_wait_nanos != 0 {
            my_size += ::protobuf::rt::value_size(17, self.pessimistic_lock_wait_nanos, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.store_batch_wait_nanos != 0 {
            os.write_uint64(1, self.store_batch_wait_nanos)?;
        }
        if self.propose_send_wait_nanos != 0 {
            os.write_uint64(2, self.propose_send_wait_nanos)?;
        }
        if self.persist_log_nanos != 0 {
            os.write_uint64(3, self.persist_log_nanos)?;
        }
        if self.raft_db_write_leader_wait_nanos != 0 {
            os.write_uint64(4, self.raft_db_write_leader_wait_nanos)?;
        }
        if self.raft_db_sync_log_nanos != 0 {
            os.write_uint64(5, self.raft_db_sync_log_nanos)?;
        }
        if self.raft_db_write_memtable_nanos != 0 {
            os.write_uint64(6, self.raft_db_write_memtable_nanos)?;
        }
        if self.commit_log_nanos != 0 {
            os.write_uint64(7, self.commit_log_nanos)?;
        }
        if self.apply_batch_wait_nanos != 0 {
            os.write_uint64(8, self.apply_batch_wait_nanos)?;
        }
        if self.apply_log_nanos != 0 {
            os.write_uint64(9, self.apply_log_nanos)?;
        }
        if self.apply_mutex_lock_nanos != 0 {
            os.write_uint64(10, self.apply_mutex_lock_nanos)?;
        }
        if self.apply_write_leader_wait_nanos != 0 {
            os.write_uint64(11, self.apply_write_leader_wait_nanos)?;
        }
        if self.apply_write_wal_nanos != 0 {
            os.write_uint64(12, self.apply_write_wal_nanos)?;
        }
        if self.apply_write_memtable_nanos != 0 {
            os.write_uint64(13, self.apply_write_memtable_nanos)?;
        }
        if self.latch_wait_nanos != 0 {
            os.write_uint64(14, self.latch_wait_nanos)?;
        }
        if self.process_nanos != 0 {
            os.write_uint64(15, self.process_nanos)?;
        }
        if self.throttle_nanos != 0 {
            os.write_uint64(16, self.throttle_nanos)?;
        }
        if self.pessimistic_lock_wait_nanos != 0 {
            os.write_uint64(17, self.pessimistic_lock_wait_nanos)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteDetail {
        WriteDetail::new()
    }

    fn default_instance() -> &'static WriteDetail {
        static mut instance: ::protobuf::lazy::Lazy<WriteDetail> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteDetail,
        };
        unsafe {
            instance.get(WriteDetail::new)
        }
    }
}

impl ::protobuf::Clear for WriteDetail {
    fn clear(&mut self) {
        self.store_batch_wait_nanos = 0;
        self.propose_send_wait_nanos = 0;
        self.persist_log_nanos = 0;
        self.raft_db_write_leader_wait_nanos = 0;
        self.raft_db_sync_log_nanos = 0;
        self.raft_db_write_memtable_nanos = 0;
        self.commit_log_nanos = 0;
        self.apply_batch_wait_nanos = 0;
        self.apply_log_nanos = 0;
        self.apply_mutex_lock_nanos = 0;
        self.apply_write_leader_wait_nanos = 0;
        self.apply_write_wal_nanos = 0;
        self.apply_write_memtable_nanos = 0;
        self.latch_wait_nanos = 0;
        self.process_nanos = 0;
        self.throttle_nanos = 0;
        self.pessimistic_lock_wait_nanos = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for WriteDetail {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.store_batch_wait_nanos, "store_batch_wait_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.propose_send_wait_nanos, "propose_send_wait_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.persist_log_nanos, "persist_log_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.raft_db_write_leader_wait_nanos, "raft_db_write_leader_wait_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.raft_db_sync_log_nanos, "raft_db_sync_log_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.raft_db_write_memtable_nanos, "raft_db_write_memtable_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.commit_log_nanos, "commit_log_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.apply_batch_wait_nanos, "apply_batch_wait_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.apply_log_nanos, "apply_log_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.apply_mutex_lock_nanos, "apply_mutex_lock_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.apply_write_leader_wait_nanos, "apply_write_leader_wait_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.apply_write_wal_nanos, "apply_write_wal_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.apply_write_memtable_nanos, "apply_write_memtable_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.latch_wait_nanos, "latch_wait_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.process_nanos, "process_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.throttle_nanos, "throttle_nanos", buf);
        ::protobuf::PbPrint::fmt(&self.pessimistic_lock_wait_nanos, "pessimistic_lock_wait_nanos", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for WriteDetail {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.store_batch_wait_nanos, "store_batch_wait_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.propose_send_wait_nanos, "propose_send_wait_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.persist_log_nanos, "persist_log_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.raft_db_write_leader_wait_nanos, "raft_db_write_leader_wait_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.raft_db_sync_log_nanos, "raft_db_sync_log_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.raft_db_write_memtable_nanos, "raft_db_write_memtable_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.commit_log_nanos, "commit_log_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.apply_batch_wait_nanos, "apply_batch_wait_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.apply_log_nanos, "apply_log_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.apply_mutex_lock_nanos, "apply_mutex_lock_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.apply_write_leader_wait_nanos, "apply_write_leader_wait_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.apply_write_wal_nanos, "apply_write_wal_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.apply_write_memtable_nanos, "apply_write_memtable_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.latch_wait_nanos, "latch_wait_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.process_nanos, "process_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.throttle_nanos, "throttle_nanos", &mut s);
        ::protobuf::PbPrint::fmt(&self.pessimistic_lock_wait_nanos, "pessimistic_lock_wait_nanos", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteDetail {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KvPair {
    // message fields
    pub error: ::protobuf::SingularPtrField<KeyError>,
    pub key: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KvPair {
    fn default() -> &'a KvPair {
        <KvPair as ::protobuf::Message>::default_instance()
    }
}

impl KvPair {
    pub fn new() -> KvPair {
        ::std::default::Default::default()
    }

    // .kvrpcpb.KeyError error = 1;


    pub fn get_error(&self) -> &KeyError {
        self.error.as_ref().unwrap_or_else(|| KeyError::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: KeyError) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut KeyError {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> KeyError {
        self.error.take().unwrap_or_else(|| KeyError::new())
    }

    // bytes key = 2;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes value = 3;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for KvPair {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(2, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(3, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KvPair {
        KvPair::new()
    }

    fn default_instance() -> &'static KvPair {
        static mut instance: ::protobuf::lazy::Lazy<KvPair> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KvPair,
        };
        unsafe {
            instance.get(KvPair::new)
        }
    }
}

impl ::protobuf::Clear for KvPair {
    fn clear(&mut self) {
        self.error.clear();
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for KvPair {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        ::protobuf::PbPrint::fmt(&self.value, "value", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for KvPair {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        ::protobuf::PbPrint::fmt(&self.value, "value", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for KvPair {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mutation {
    // message fields
    pub op: Op,
    pub key: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub assertion: Assertion,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mutation {
    fn default() -> &'a Mutation {
        <Mutation as ::protobuf::Message>::default_instance()
    }
}

impl Mutation {
    pub fn new() -> Mutation {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Op op = 1;


    pub fn get_op(&self) -> Op {
        self.op
    }
    pub fn clear_op(&mut self) {
        self.op = Op::Put;
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: Op) {
        self.op = v;
    }

    // bytes key = 2;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes value = 3;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // .kvrpcpb.Assertion assertion = 4;


    pub fn get_assertion(&self) -> Assertion {
        self.assertion
    }
    pub fn clear_assertion(&mut self) {
        self.assertion = Assertion::None;
    }

    // Param is passed by value, moved
    pub fn set_assertion(&mut self, v: Assertion) {
        self.assertion = v;
    }
}

impl ::protobuf::Message for Mutation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.op = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.assertion = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.op != Op::Put {
            my_size += ::protobuf::rt::enum_size(1, self.op);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.value);
        }
        if self.assertion != Assertion::None {
            my_size += ::protobuf::rt::enum_size(4, self.assertion);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.op != Op::Put {
            os.write_enum(1, self.op.value())?;
        }
        if !self.key.is_empty() {
            os.write_bytes(2, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(3, &self.value)?;
        }
        if self.assertion != Assertion::None {
            os.write_enum(4, self.assertion.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mutation {
        Mutation::new()
    }

    fn default_instance() -> &'static Mutation {
        static mut instance: ::protobuf::lazy::Lazy<Mutation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Mutation,
        };
        unsafe {
            instance.get(Mutation::new)
        }
    }
}

impl ::protobuf::Clear for Mutation {
    fn clear(&mut self) {
        self.op = Op::Put;
        self.key.clear();
        self.value.clear();
        self.assertion = Assertion::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for Mutation {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.op, "op", buf);
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        ::protobuf::PbPrint::fmt(&self.value, "value", buf);
        ::protobuf::PbPrint::fmt(&self.assertion, "assertion", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for Mutation {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.op, "op", &mut s);
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        ::protobuf::PbPrint::fmt(&self.value, "value", &mut s);
        ::protobuf::PbPrint::fmt(&self.assertion, "assertion", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mutation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MvccWrite {
    // message fields
    pub r_type: Op,
    pub start_ts: u64,
    pub commit_ts: u64,
    pub short_value: ::std::vec::Vec<u8>,
    pub has_overlapped_rollback: bool,
    pub has_gc_fence: bool,
    pub gc_fence: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MvccWrite {
    fn default() -> &'a MvccWrite {
        <MvccWrite as ::protobuf::Message>::default_instance()
    }
}

impl MvccWrite {
    pub fn new() -> MvccWrite {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Op type = 1;


    pub fn get_type(&self) -> Op {
        self.r_type
    }
    pub fn clear_type(&mut self) {
        self.r_type = Op::Put;
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: Op) {
        self.r_type = v;
    }

    // uint64 start_ts = 2;


    pub fn get_start_ts(&self) -> u64 {
        self.start_ts
    }
    pub fn clear_start_ts(&mut self) {
        self.start_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_ts(&mut self, v: u64) {
        self.start_ts = v;
    }

    // uint64 commit_ts = 3;


    pub fn get_commit_ts(&self) -> u64 {
        self.commit_ts
    }
    pub fn clear_commit_ts(&mut self) {
        self.commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_ts(&mut self, v: u64) {
        self.commit_ts = v;
    }

    // bytes short_value = 4;


    pub fn get_short_value(&self) -> &[u8] {
        &self.short_value
    }
    pub fn clear_short_value(&mut self) {
        self.short_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_short_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.short_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_short_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.short_value
    }

    // Take field
    pub fn take_short_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.short_value, ::std::vec::Vec::new())
    }

    // bool has_overlapped_rollback = 5;


    pub fn get_has_overlapped_rollback(&self) -> bool {
        self.has_overlapped_rollback
    }
    pub fn clear_has_overlapped_rollback(&mut self) {
        self.has_overlapped_rollback = false;
    }

    // Param is passed by value, moved
    pub fn set_has_overlapped_rollback(&mut self, v: bool) {
        self.has_overlapped_rollback = v;
    }

    // bool has_gc_fence = 6;


    pub fn get_has_gc_fence(&self) -> bool {
        self.has_gc_fence
    }
    pub fn clear_has_gc_fence(&mut self) {
        self.has_gc_fence = false;
    }

    // Param is passed by value, moved
    pub fn set_has_gc_fence(&mut self, v: bool) {
        self.has_gc_fence = v;
    }

    // uint64 gc_fence = 7;


    pub fn get_gc_fence(&self) -> u64 {
        self.gc_fence
    }
    pub fn clear_gc_fence(&mut self) {
        self.gc_fence = 0;
    }

    // Param is passed by value, moved
    pub fn set_gc_fence(&mut self, v: u64) {
        self.gc_fence = v;
    }
}

impl ::protobuf::Message for MvccWrite {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.r_type = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_ts = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commit_ts = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.short_value)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_overlapped_rollback = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_gc_fence = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gc_fence = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.r_type != Op::Put {
            my_size += ::protobuf::rt::enum_size(1, self.r_type);
        }
        if self.start_ts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.start_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(3, self.commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.short_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.short_value);
        }
        if self.has_overlapped_rollback != false {
            my_size += 2;
        }
        if self.has_gc_fence != false {
            my_size += 2;
        }
        if self.gc_fence != 0 {
            my_size += ::protobuf::rt::value_size(7, self.gc_fence, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.r_type != Op::Put {
            os.write_enum(1, self.r_type.value())?;
        }
        if self.start_ts != 0 {
            os.write_uint64(2, self.start_ts)?;
        }
        if self.commit_ts != 0 {
            os.write_uint64(3, self.commit_ts)?;
        }
        if !self.short_value.is_empty() {
            os.write_bytes(4, &self.short_value)?;
        }
        if self.has_overlapped_rollback != false {
            os.write_bool(5, self.has_overlapped_rollback)?;
        }
        if self.has_gc_fence != false {
            os.write_bool(6, self.has_gc_fence)?;
        }
        if self.gc_fence != 0 {
            os.write_uint64(7, self.gc_fence)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MvccWrite {
        MvccWrite::new()
    }

    fn default_instance() -> &'static MvccWrite {
        static mut instance: ::protobuf::lazy::Lazy<MvccWrite> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MvccWrite,
        };
        unsafe {
            instance.get(MvccWrite::new)
        }
    }
}

impl ::protobuf::Clear for MvccWrite {
    fn clear(&mut self) {
        self.r_type = Op::Put;
        self.start_ts = 0;
        self.commit_ts = 0;
        self.short_value.clear();
        self.has_overlapped_rollback = false;
        self.has_gc_fence = false;
        self.gc_fence = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for MvccWrite {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.r_type, "r_type", buf);
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", buf);
        ::protobuf::PbPrint::fmt(&self.commit_ts, "commit_ts", buf);
        ::protobuf::PbPrint::fmt(&self.short_value, "short_value", buf);
        ::protobuf::PbPrint::fmt(&self.has_overlapped_rollback, "has_overlapped_rollback", buf);
        ::protobuf::PbPrint::fmt(&self.has_gc_fence, "has_gc_fence", buf);
        ::protobuf::PbPrint::fmt(&self.gc_fence, "gc_fence", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for MvccWrite {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.r_type, "r_type", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.commit_ts, "commit_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.short_value, "short_value", &mut s);
        ::protobuf::PbPrint::fmt(&self.has_overlapped_rollback, "has_overlapped_rollback", &mut s);
        ::protobuf::PbPrint::fmt(&self.has_gc_fence, "has_gc_fence", &mut s);
        ::protobuf::PbPrint::fmt(&self.gc_fence, "gc_fence", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for MvccWrite {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MvccValue {
    // message fields
    pub start_ts: u64,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MvccValue {
    fn default() -> &'a MvccValue {
        <MvccValue as ::protobuf::Message>::default_instance()
    }
}

impl MvccValue {
    pub fn new() -> MvccValue {
        ::std::default::Default::default()
    }

    // uint64 start_ts = 1;


    pub fn get_start_ts(&self) -> u64 {
        self.start_ts
    }
    pub fn clear_start_ts(&mut self) {
        self.start_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_ts(&mut self, v: u64) {
        self.start_ts = v;
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MvccValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_ts = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_ts != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.start_ts != 0 {
            os.write_uint64(1, self.start_ts)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MvccValue {
        MvccValue::new()
    }

    fn default_instance() -> &'static MvccValue {
        static mut instance: ::protobuf::lazy::Lazy<MvccValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MvccValue,
        };
        unsafe {
            instance.get(MvccValue::new)
        }
    }
}

impl ::protobuf::Clear for MvccValue {
    fn clear(&mut self) {
        self.start_ts = 0;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for MvccValue {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", buf);
        ::protobuf::PbPrint::fmt(&self.value, "value", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for MvccValue {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.value, "value", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for MvccValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MvccLock {
    // message fields
    pub r_type: Op,
    pub start_ts: u64,
    pub primary: ::std::vec::Vec<u8>,
    pub short_value: ::std::vec::Vec<u8>,
    pub ttl: u64,
    pub for_update_ts: u64,
    pub txn_size: u64,
    pub use_async_commit: bool,
    pub secondaries: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub rollback_ts: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MvccLock {
    fn default() -> &'a MvccLock {
        <MvccLock as ::protobuf::Message>::default_instance()
    }
}

impl MvccLock {
    pub fn new() -> MvccLock {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Op type = 1;


    pub fn get_type(&self) -> Op {
        self.r_type
    }
    pub fn clear_type(&mut self) {
        self.r_type = Op::Put;
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: Op) {
        self.r_type = v;
    }

    // uint64 start_ts = 2;


    pub fn get_start_ts(&self) -> u64 {
        self.start_ts
    }
    pub fn clear_start_ts(&mut self) {
        self.start_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_ts(&mut self, v: u64) {
        self.start_ts = v;
    }

    // bytes primary = 3;


    pub fn get_primary(&self) -> &[u8] {
        &self.primary
    }
    pub fn clear_primary(&mut self) {
        self.primary.clear();
    }

    // Param is passed by value, moved
    pub fn set_primary(&mut self, v: ::std::vec::Vec<u8>) {
        self.primary = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.primary
    }

    // Take field
    pub fn take_primary(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.primary, ::std::vec::Vec::new())
    }

    // bytes short_value = 4;


    pub fn get_short_value(&self) -> &[u8] {
        &self.short_value
    }
    pub fn clear_short_value(&mut self) {
        self.short_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_short_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.short_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_short_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.short_value
    }

    // Take field
    pub fn take_short_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.short_value, ::std::vec::Vec::new())
    }

    // uint64 ttl = 5;


    pub fn get_ttl(&self) -> u64 {
        self.ttl
    }
    pub fn clear_ttl(&mut self) {
        self.ttl = 0;
    }

    // Param is passed by value, moved
    pub fn set_ttl(&mut self, v: u64) {
        self.ttl = v;
    }

    // uint64 for_update_ts = 6;


    pub fn get_for_update_ts(&self) -> u64 {
        self.for_update_ts
    }
    pub fn clear_for_update_ts(&mut self) {
        self.for_update_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_for_update_ts(&mut self, v: u64) {
        self.for_update_ts = v;
    }

    // uint64 txn_size = 7;


    pub fn get_txn_size(&self) -> u64 {
        self.txn_size
    }
    pub fn clear_txn_size(&mut self) {
        self.txn_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_txn_size(&mut self, v: u64) {
        self.txn_size = v;
    }

    // bool use_async_commit = 8;


    pub fn get_use_async_commit(&self) -> bool {
        self.use_async_commit
    }
    pub fn clear_use_async_commit(&mut self) {
        self.use_async_commit = false;
    }

    // Param is passed by value, moved
    pub fn set_use_async_commit(&mut self, v: bool) {
        self.use_async_commit = v;
    }

    // repeated bytes secondaries = 9;


    pub fn get_secondaries(&self) -> &[::std::vec::Vec<u8>] {
        &self.secondaries
    }
    pub fn clear_secondaries(&mut self) {
        self.secondaries.clear();
    }

    // Param is passed by value, moved
    pub fn set_secondaries(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.secondaries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_secondaries(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.secondaries
    }

    // Take field
    pub fn take_secondaries(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.secondaries, ::protobuf::RepeatedField::new())
    }

    // repeated uint64 rollback_ts = 10;


    pub fn get_rollback_ts(&self) -> &[u64] {
        &self.rollback_ts
    }
    pub fn clear_rollback_ts(&mut self) {
        self.rollback_ts.clear();
    }

    // Param is passed by value, moved
    pub fn set_rollback_ts(&mut self, v: ::std::vec::Vec<u64>) {
        self.rollback_ts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rollback_ts(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.rollback_ts
    }

    // Take field
    pub fn take_rollback_ts(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.rollback_ts, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MvccLock {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.r_type = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_ts = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.primary)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.short_value)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ttl = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.for_update_ts = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txn_size = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_async_commit = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.secondaries)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.rollback_ts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.r_type != Op::Put {
            my_size += ::protobuf::rt::enum_size(1, self.r_type);
        }
        if self.start_ts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.start_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.primary.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.primary);
        }
        if !self.short_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.short_value);
        }
        if self.ttl != 0 {
            my_size += ::protobuf::rt::value_size(5, self.ttl, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.for_update_ts != 0 {
            my_size += ::protobuf::rt::value_size(6, self.for_update_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.txn_size != 0 {
            my_size += ::protobuf::rt::value_size(7, self.txn_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.use_async_commit != false {
            my_size += 2;
        }
        for value in &self.secondaries {
            my_size += ::protobuf::rt::bytes_size(9, &value);
        };
        for value in &self.rollback_ts {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.r_type != Op::Put {
            os.write_enum(1, self.r_type.value())?;
        }
        if self.start_ts != 0 {
            os.write_uint64(2, self.start_ts)?;
        }
        if !self.primary.is_empty() {
            os.write_bytes(3, &self.primary)?;
        }
        if !self.short_value.is_empty() {
            os.write_bytes(4, &self.short_value)?;
        }
        if self.ttl != 0 {
            os.write_uint64(5, self.ttl)?;
        }
        if self.for_update_ts != 0 {
            os.write_uint64(6, self.for_update_ts)?;
        }
        if self.txn_size != 0 {
            os.write_uint64(7, self.txn_size)?;
        }
        if self.use_async_commit != false {
            os.write_bool(8, self.use_async_commit)?;
        }
        for v in &self.secondaries {
            os.write_bytes(9, &v)?;
        };
        for v in &self.rollback_ts {
            os.write_uint64(10, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MvccLock {
        MvccLock::new()
    }

    fn default_instance() -> &'static MvccLock {
        static mut instance: ::protobuf::lazy::Lazy<MvccLock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MvccLock,
        };
        unsafe {
            instance.get(MvccLock::new)
        }
    }
}

impl ::protobuf::Clear for MvccLock {
    fn clear(&mut self) {
        self.r_type = Op::Put;
        self.start_ts = 0;
        self.primary.clear();
        self.short_value.clear();
        self.ttl = 0;
        self.for_update_ts = 0;
        self.txn_size = 0;
        self.use_async_commit = false;
        self.secondaries.clear();
        self.rollback_ts.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for MvccLock {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.r_type, "r_type", buf);
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", buf);
        ::protobuf::PbPrint::fmt(&self.primary, "primary", buf);
        ::protobuf::PbPrint::fmt(&self.short_value, "short_value", buf);
        ::protobuf::PbPrint::fmt(&self.ttl, "ttl", buf);
        ::protobuf::PbPrint::fmt(&self.for_update_ts, "for_update_ts", buf);
        ::protobuf::PbPrint::fmt(&self.txn_size, "txn_size", buf);
        ::protobuf::PbPrint::fmt(&self.use_async_commit, "use_async_commit", buf);
        ::protobuf::PbPrint::fmt(&self.secondaries, "secondaries", buf);
        ::protobuf::PbPrint::fmt(&self.rollback_ts, "rollback_ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for MvccLock {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.r_type, "r_type", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.primary, "primary", &mut s);
        ::protobuf::PbPrint::fmt(&self.short_value, "short_value", &mut s);
        ::protobuf::PbPrint::fmt(&self.ttl, "ttl", &mut s);
        ::protobuf::PbPrint::fmt(&self.for_update_ts, "for_update_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.txn_size, "txn_size", &mut s);
        ::protobuf::PbPrint::fmt(&self.use_async_commit, "use_async_commit", &mut s);
        ::protobuf::PbPrint::fmt(&self.secondaries, "secondaries", &mut s);
        ::protobuf::PbPrint::fmt(&self.rollback_ts, "rollback_ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for MvccLock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MvccInfo {
    // message fields
    pub lock: ::protobuf::SingularPtrField<MvccLock>,
    pub writes: ::protobuf::RepeatedField<MvccWrite>,
    pub values: ::protobuf::RepeatedField<MvccValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MvccInfo {
    fn default() -> &'a MvccInfo {
        <MvccInfo as ::protobuf::Message>::default_instance()
    }
}

impl MvccInfo {
    pub fn new() -> MvccInfo {
        ::std::default::Default::default()
    }

    // .kvrpcpb.MvccLock lock = 1;


    pub fn get_lock(&self) -> &MvccLock {
        self.lock.as_ref().unwrap_or_else(|| MvccLock::default_instance())
    }
    pub fn clear_lock(&mut self) {
        self.lock.clear();
    }

    pub fn has_lock(&self) -> bool {
        self.lock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lock(&mut self, v: MvccLock) {
        self.lock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lock(&mut self) -> &mut MvccLock {
        if self.lock.is_none() {
            self.lock.set_default();
        }
        self.lock.as_mut().unwrap()
    }

    // Take field
    pub fn take_lock(&mut self) -> MvccLock {
        self.lock.take().unwrap_or_else(|| MvccLock::new())
    }

    // repeated .kvrpcpb.MvccWrite writes = 2;


    pub fn get_writes(&self) -> &[MvccWrite] {
        &self.writes
    }
    pub fn clear_writes(&mut self) {
        self.writes.clear();
    }

    // Param is passed by value, moved
    pub fn set_writes(&mut self, v: ::protobuf::RepeatedField<MvccWrite>) {
        self.writes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_writes(&mut self) -> &mut ::protobuf::RepeatedField<MvccWrite> {
        &mut self.writes
    }

    // Take field
    pub fn take_writes(&mut self) -> ::protobuf::RepeatedField<MvccWrite> {
        ::std::mem::replace(&mut self.writes, ::protobuf::RepeatedField::new())
    }

    // repeated .kvrpcpb.MvccValue values = 3;


    pub fn get_values(&self) -> &[MvccValue] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<MvccValue>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<MvccValue> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<MvccValue> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MvccInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.lock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.writes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.values {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lock)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.writes)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.lock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.writes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.lock.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.writes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.values {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MvccInfo {
        MvccInfo::new()
    }

    fn default_instance() -> &'static MvccInfo {
        static mut instance: ::protobuf::lazy::Lazy<MvccInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MvccInfo,
        };
        unsafe {
            instance.get(MvccInfo::new)
        }
    }
}

impl ::protobuf::Clear for MvccInfo {
    fn clear(&mut self) {
        self.lock.clear();
        self.writes.clear();
        self.values.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for MvccInfo {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.lock, "lock", buf);
        ::protobuf::PbPrint::fmt(&self.writes, "writes", buf);
        ::protobuf::PbPrint::fmt(&self.values, "values", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for MvccInfo {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.lock, "lock", &mut s);
        ::protobuf::PbPrint::fmt(&self.writes, "writes", &mut s);
        ::protobuf::PbPrint::fmt(&self.values, "values", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for MvccInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TxnInfo {
    // message fields
    pub txn: u64,
    pub status: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxnInfo {
    fn default() -> &'a TxnInfo {
        <TxnInfo as ::protobuf::Message>::default_instance()
    }
}

impl TxnInfo {
    pub fn new() -> TxnInfo {
        ::std::default::Default::default()
    }

    // uint64 txn = 1;


    pub fn get_txn(&self) -> u64 {
        self.txn
    }
    pub fn clear_txn(&mut self) {
        self.txn = 0;
    }

    // Param is passed by value, moved
    pub fn set_txn(&mut self, v: u64) {
        self.txn = v;
    }

    // uint64 status = 2;


    pub fn get_status(&self) -> u64 {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = 0;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: u64) {
        self.status = v;
    }
}

impl ::protobuf::Message for TxnInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txn = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.status = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.txn != 0 {
            my_size += ::protobuf::rt::value_size(1, self.txn, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.status != 0 {
            my_size += ::protobuf::rt::value_size(2, self.status, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.txn != 0 {
            os.write_uint64(1, self.txn)?;
        }
        if self.status != 0 {
            os.write_uint64(2, self.status)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxnInfo {
        TxnInfo::new()
    }

    fn default_instance() -> &'static TxnInfo {
        static mut instance: ::protobuf::lazy::Lazy<TxnInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TxnInfo,
        };
        unsafe {
            instance.get(TxnInfo::new)
        }
    }
}

impl ::protobuf::Clear for TxnInfo {
    fn clear(&mut self) {
        self.txn = 0;
        self.status = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for TxnInfo {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.txn, "txn", buf);
        ::protobuf::PbPrint::fmt(&self.status, "status", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for TxnInfo {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.txn, "txn", &mut s);
        ::protobuf::PbPrint::fmt(&self.status, "status", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxnInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyRange {
    // message fields
    pub start_key: ::std::vec::Vec<u8>,
    pub end_key: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyRange {
    fn default() -> &'a KeyRange {
        <KeyRange as ::protobuf::Message>::default_instance()
    }
}

impl KeyRange {
    pub fn new() -> KeyRange {
        ::std::default::Default::default()
    }

    // bytes start_key = 1;


    pub fn get_start_key(&self) -> &[u8] {
        &self.start_key
    }
    pub fn clear_start_key(&mut self) {
        self.start_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.start_key
    }

    // Take field
    pub fn take_start_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.start_key, ::std::vec::Vec::new())
    }

    // bytes end_key = 2;


    pub fn get_end_key(&self) -> &[u8] {
        &self.end_key
    }
    pub fn clear_end_key(&mut self) {
        self.end_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_end_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.end_key
    }

    // Take field
    pub fn take_end_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.end_key, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for KeyRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.start_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.end_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.start_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.start_key);
        }
        if !self.end_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.end_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.start_key.is_empty() {
            os.write_bytes(1, &self.start_key)?;
        }
        if !self.end_key.is_empty() {
            os.write_bytes(2, &self.end_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyRange {
        KeyRange::new()
    }

    fn default_instance() -> &'static KeyRange {
        static mut instance: ::protobuf::lazy::Lazy<KeyRange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KeyRange,
        };
        unsafe {
            instance.get(KeyRange::new)
        }
    }
}

impl ::protobuf::Clear for KeyRange {
    fn clear(&mut self) {
        self.start_key.clear();
        self.end_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for KeyRange {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", buf);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for KeyRange {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyRange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaderInfo {
    // message fields
    pub region_id: u64,
    pub peer_id: u64,
    pub term: u64,
    pub region_epoch: ::protobuf::SingularPtrField<super::metapb::RegionEpoch>,
    pub read_state: ::protobuf::SingularPtrField<ReadState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LeaderInfo {
    fn default() -> &'a LeaderInfo {
        <LeaderInfo as ::protobuf::Message>::default_instance()
    }
}

impl LeaderInfo {
    pub fn new() -> LeaderInfo {
        ::std::default::Default::default()
    }

    // uint64 region_id = 1;


    pub fn get_region_id(&self) -> u64 {
        self.region_id
    }
    pub fn clear_region_id(&mut self) {
        self.region_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_region_id(&mut self, v: u64) {
        self.region_id = v;
    }

    // uint64 peer_id = 2;


    pub fn get_peer_id(&self) -> u64 {
        self.peer_id
    }
    pub fn clear_peer_id(&mut self) {
        self.peer_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_peer_id(&mut self, v: u64) {
        self.peer_id = v;
    }

    // uint64 term = 3;


    pub fn get_term(&self) -> u64 {
        self.term
    }
    pub fn clear_term(&mut self) {
        self.term = 0;
    }

    // Param is passed by value, moved
    pub fn set_term(&mut self, v: u64) {
        self.term = v;
    }

    // .metapb.RegionEpoch region_epoch = 4;


    pub fn get_region_epoch(&self) -> &super::metapb::RegionEpoch {
        self.region_epoch.as_ref().unwrap_or_else(|| super::metapb::RegionEpoch::default_instance())
    }
    pub fn clear_region_epoch(&mut self) {
        self.region_epoch.clear();
    }

    pub fn has_region_epoch(&self) -> bool {
        self.region_epoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_epoch(&mut self, v: super::metapb::RegionEpoch) {
        self.region_epoch = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_epoch(&mut self) -> &mut super::metapb::RegionEpoch {
        if self.region_epoch.is_none() {
            self.region_epoch.set_default();
        }
        self.region_epoch.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_epoch(&mut self) -> super::metapb::RegionEpoch {
        self.region_epoch.take().unwrap_or_else(|| super::metapb::RegionEpoch::new())
    }

    // .kvrpcpb.ReadState read_state = 5;


    pub fn get_read_state(&self) -> &ReadState {
        self.read_state.as_ref().unwrap_or_else(|| ReadState::default_instance())
    }
    pub fn clear_read_state(&mut self) {
        self.read_state.clear();
    }

    pub fn has_read_state(&self) -> bool {
        self.read_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_state(&mut self, v: ReadState) {
        self.read_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_state(&mut self) -> &mut ReadState {
        if self.read_state.is_none() {
            self.read_state.set_default();
        }
        self.read_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_state(&mut self) -> ReadState {
        self.read_state.take().unwrap_or_else(|| ReadState::new())
    }
}

impl ::protobuf::Message for LeaderInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.region_epoch {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.read_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.region_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.peer_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.term = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_epoch)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.region_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.region_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.peer_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.peer_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.term != 0 {
            my_size += ::protobuf::rt::value_size(3, self.term, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.region_epoch.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.read_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.region_id != 0 {
            os.write_uint64(1, self.region_id)?;
        }
        if self.peer_id != 0 {
            os.write_uint64(2, self.peer_id)?;
        }
        if self.term != 0 {
            os.write_uint64(3, self.term)?;
        }
        if let Some(ref v) = self.region_epoch.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.read_state.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaderInfo {
        LeaderInfo::new()
    }

    fn default_instance() -> &'static LeaderInfo {
        static mut instance: ::protobuf::lazy::Lazy<LeaderInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LeaderInfo,
        };
        unsafe {
            instance.get(LeaderInfo::new)
        }
    }
}

impl ::protobuf::Clear for LeaderInfo {
    fn clear(&mut self) {
        self.region_id = 0;
        self.peer_id = 0;
        self.term = 0;
        self.region_epoch.clear();
        self.read_state.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for LeaderInfo {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_id, "region_id", buf);
        ::protobuf::PbPrint::fmt(&self.peer_id, "peer_id", buf);
        ::protobuf::PbPrint::fmt(&self.term, "term", buf);
        ::protobuf::PbPrint::fmt(&self.region_epoch, "region_epoch", buf);
        ::protobuf::PbPrint::fmt(&self.read_state, "read_state", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for LeaderInfo {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_id, "region_id", &mut s);
        ::protobuf::PbPrint::fmt(&self.peer_id, "peer_id", &mut s);
        ::protobuf::PbPrint::fmt(&self.term, "term", &mut s);
        ::protobuf::PbPrint::fmt(&self.region_epoch, "region_epoch", &mut s);
        ::protobuf::PbPrint::fmt(&self.read_state, "read_state", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaderInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadState {
    // message fields
    pub applied_index: u64,
    pub safe_ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadState {
    fn default() -> &'a ReadState {
        <ReadState as ::protobuf::Message>::default_instance()
    }
}

impl ReadState {
    pub fn new() -> ReadState {
        ::std::default::Default::default()
    }

    // uint64 applied_index = 1;


    pub fn get_applied_index(&self) -> u64 {
        self.applied_index
    }
    pub fn clear_applied_index(&mut self) {
        self.applied_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_applied_index(&mut self, v: u64) {
        self.applied_index = v;
    }

    // uint64 safe_ts = 2;


    pub fn get_safe_ts(&self) -> u64 {
        self.safe_ts
    }
    pub fn clear_safe_ts(&mut self) {
        self.safe_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_safe_ts(&mut self, v: u64) {
        self.safe_ts = v;
    }
}

impl ::protobuf::Message for ReadState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.applied_index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.safe_ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.applied_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.applied_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.safe_ts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.safe_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.applied_index != 0 {
            os.write_uint64(1, self.applied_index)?;
        }
        if self.safe_ts != 0 {
            os.write_uint64(2, self.safe_ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadState {
        ReadState::new()
    }

    fn default_instance() -> &'static ReadState {
        static mut instance: ::protobuf::lazy::Lazy<ReadState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadState,
        };
        unsafe {
            instance.get(ReadState::new)
        }
    }
}

impl ::protobuf::Clear for ReadState {
    fn clear(&mut self) {
        self.applied_index = 0;
        self.safe_ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ReadState {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.applied_index, "applied_index", buf);
        ::protobuf::PbPrint::fmt(&self.safe_ts, "safe_ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ReadState {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.applied_index, "applied_index", &mut s);
        ::protobuf::PbPrint::fmt(&self.safe_ts, "safe_ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckLeaderRequest {
    // message fields
    pub regions: ::protobuf::RepeatedField<LeaderInfo>,
    pub ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckLeaderRequest {
    fn default() -> &'a CheckLeaderRequest {
        <CheckLeaderRequest as ::protobuf::Message>::default_instance()
    }
}

impl CheckLeaderRequest {
    pub fn new() -> CheckLeaderRequest {
        ::std::default::Default::default()
    }

    // repeated .kvrpcpb.LeaderInfo regions = 1;


    pub fn get_regions(&self) -> &[LeaderInfo] {
        &self.regions
    }
    pub fn clear_regions(&mut self) {
        self.regions.clear();
    }

    // Param is passed by value, moved
    pub fn set_regions(&mut self, v: ::protobuf::RepeatedField<LeaderInfo>) {
        self.regions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_regions(&mut self) -> &mut ::protobuf::RepeatedField<LeaderInfo> {
        &mut self.regions
    }

    // Take field
    pub fn take_regions(&mut self) -> ::protobuf::RepeatedField<LeaderInfo> {
        ::std::mem::replace(&mut self.regions, ::protobuf::RepeatedField::new())
    }

    // uint64 ts = 2;


    pub fn get_ts(&self) -> u64 {
        self.ts
    }
    pub fn clear_ts(&mut self) {
        self.ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_ts(&mut self, v: u64) {
        self.ts = v;
    }
}

impl ::protobuf::Message for CheckLeaderRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.regions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.regions)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.regions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.ts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.regions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.ts != 0 {
            os.write_uint64(2, self.ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckLeaderRequest {
        CheckLeaderRequest::new()
    }

    fn default_instance() -> &'static CheckLeaderRequest {
        static mut instance: ::protobuf::lazy::Lazy<CheckLeaderRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckLeaderRequest,
        };
        unsafe {
            instance.get(CheckLeaderRequest::new)
        }
    }
}

impl ::protobuf::Clear for CheckLeaderRequest {
    fn clear(&mut self) {
        self.regions.clear();
        self.ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CheckLeaderRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.regions, "regions", buf);
        ::protobuf::PbPrint::fmt(&self.ts, "ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for CheckLeaderRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.regions, "regions", &mut s);
        ::protobuf::PbPrint::fmt(&self.ts, "ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckLeaderRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckLeaderResponse {
    // message fields
    pub regions: ::std::vec::Vec<u64>,
    pub ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckLeaderResponse {
    fn default() -> &'a CheckLeaderResponse {
        <CheckLeaderResponse as ::protobuf::Message>::default_instance()
    }
}

impl CheckLeaderResponse {
    pub fn new() -> CheckLeaderResponse {
        ::std::default::Default::default()
    }

    // repeated uint64 regions = 1;


    pub fn get_regions(&self) -> &[u64] {
        &self.regions
    }
    pub fn clear_regions(&mut self) {
        self.regions.clear();
    }

    // Param is passed by value, moved
    pub fn set_regions(&mut self, v: ::std::vec::Vec<u64>) {
        self.regions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_regions(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.regions
    }

    // Take field
    pub fn take_regions(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.regions, ::std::vec::Vec::new())
    }

    // uint64 ts = 2;


    pub fn get_ts(&self) -> u64 {
        self.ts
    }
    pub fn clear_ts(&mut self) {
        self.ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_ts(&mut self, v: u64) {
        self.ts = v;
    }
}

impl ::protobuf::Message for CheckLeaderResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.regions)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.regions {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.ts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.regions {
            os.write_uint64(1, *v)?;
        };
        if self.ts != 0 {
            os.write_uint64(2, self.ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckLeaderResponse {
        CheckLeaderResponse::new()
    }

    fn default_instance() -> &'static CheckLeaderResponse {
        static mut instance: ::protobuf::lazy::Lazy<CheckLeaderResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckLeaderResponse,
        };
        unsafe {
            instance.get(CheckLeaderResponse::new)
        }
    }
}

impl ::protobuf::Clear for CheckLeaderResponse {
    fn clear(&mut self) {
        self.regions.clear();
        self.ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CheckLeaderResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.regions, "regions", buf);
        ::protobuf::PbPrint::fmt(&self.ts, "ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for CheckLeaderResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.regions, "regions", &mut s);
        ::protobuf::PbPrint::fmt(&self.ts, "ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckLeaderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StoreSafeTsRequest {
    // message fields
    pub key_range: ::protobuf::SingularPtrField<KeyRange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StoreSafeTsRequest {
    fn default() -> &'a StoreSafeTsRequest {
        <StoreSafeTsRequest as ::protobuf::Message>::default_instance()
    }
}

impl StoreSafeTsRequest {
    pub fn new() -> StoreSafeTsRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.KeyRange key_range = 1;


    pub fn get_key_range(&self) -> &KeyRange {
        self.key_range.as_ref().unwrap_or_else(|| KeyRange::default_instance())
    }
    pub fn clear_key_range(&mut self) {
        self.key_range.clear();
    }

    pub fn has_key_range(&self) -> bool {
        self.key_range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_range(&mut self, v: KeyRange) {
        self.key_range = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_range(&mut self) -> &mut KeyRange {
        if self.key_range.is_none() {
            self.key_range.set_default();
        }
        self.key_range.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_range(&mut self) -> KeyRange {
        self.key_range.take().unwrap_or_else(|| KeyRange::new())
    }
}

impl ::protobuf::Message for StoreSafeTsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.key_range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key_range)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key_range.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StoreSafeTsRequest {
        StoreSafeTsRequest::new()
    }

    fn default_instance() -> &'static StoreSafeTsRequest {
        static mut instance: ::protobuf::lazy::Lazy<StoreSafeTsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StoreSafeTsRequest,
        };
        unsafe {
            instance.get(StoreSafeTsRequest::new)
        }
    }
}

impl ::protobuf::Clear for StoreSafeTsRequest {
    fn clear(&mut self) {
        self.key_range.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for StoreSafeTsRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.key_range, "key_range", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for StoreSafeTsRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.key_range, "key_range", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for StoreSafeTsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StoreSafeTsResponse {
    // message fields
    pub safe_ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StoreSafeTsResponse {
    fn default() -> &'a StoreSafeTsResponse {
        <StoreSafeTsResponse as ::protobuf::Message>::default_instance()
    }
}

impl StoreSafeTsResponse {
    pub fn new() -> StoreSafeTsResponse {
        ::std::default::Default::default()
    }

    // uint64 safe_ts = 1;


    pub fn get_safe_ts(&self) -> u64 {
        self.safe_ts
    }
    pub fn clear_safe_ts(&mut self) {
        self.safe_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_safe_ts(&mut self, v: u64) {
        self.safe_ts = v;
    }
}

impl ::protobuf::Message for StoreSafeTsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.safe_ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.safe_ts != 0 {
            my_size += ::protobuf::rt::value_size(1, self.safe_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.safe_ts != 0 {
            os.write_uint64(1, self.safe_ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StoreSafeTsResponse {
        StoreSafeTsResponse::new()
    }

    fn default_instance() -> &'static StoreSafeTsResponse {
        static mut instance: ::protobuf::lazy::Lazy<StoreSafeTsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StoreSafeTsResponse,
        };
        unsafe {
            instance.get(StoreSafeTsResponse::new)
        }
    }
}

impl ::protobuf::Clear for StoreSafeTsResponse {
    fn clear(&mut self) {
        self.safe_ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for StoreSafeTsResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.safe_ts, "safe_ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for StoreSafeTsResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.safe_ts, "safe_ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for StoreSafeTsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawGetKeyTtlRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub key: ::std::vec::Vec<u8>,
    pub cf: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawGetKeyTtlRequest {
    fn default() -> &'a RawGetKeyTtlRequest {
        <RawGetKeyTtlRequest as ::protobuf::Message>::default_instance()
    }
}

impl RawGetKeyTtlRequest {
    pub fn new() -> RawGetKeyTtlRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // bytes key = 2;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // string cf = 3;


    pub fn get_cf(&self) -> &str {
        &self.cf
    }
    pub fn clear_cf(&mut self) {
        self.cf.clear();
    }

    // Param is passed by value, moved
    pub fn set_cf(&mut self, v: ::std::string::String) {
        self.cf = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cf(&mut self) -> &mut ::std::string::String {
        &mut self.cf
    }

    // Take field
    pub fn take_cf(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cf, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RawGetKeyTtlRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cf)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.key);
        }
        if !self.cf.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cf);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(2, &self.key)?;
        }
        if !self.cf.is_empty() {
            os.write_string(3, &self.cf)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawGetKeyTtlRequest {
        RawGetKeyTtlRequest::new()
    }

    fn default_instance() -> &'static RawGetKeyTtlRequest {
        static mut instance: ::protobuf::lazy::Lazy<RawGetKeyTtlRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawGetKeyTtlRequest,
        };
        unsafe {
            instance.get(RawGetKeyTtlRequest::new)
        }
    }
}

impl ::protobuf::Clear for RawGetKeyTtlRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.key.clear();
        self.cf.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawGetKeyTtlRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawGetKeyTtlRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawGetKeyTtlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawGetKeyTtlResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::std::string::String,
    pub ttl: u64,
    pub not_found: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawGetKeyTtlResponse {
    fn default() -> &'a RawGetKeyTtlResponse {
        <RawGetKeyTtlResponse as ::protobuf::Message>::default_instance()
    }
}

impl RawGetKeyTtlResponse {
    pub fn new() -> RawGetKeyTtlResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // uint64 ttl = 3;


    pub fn get_ttl(&self) -> u64 {
        self.ttl
    }
    pub fn clear_ttl(&mut self) {
        self.ttl = 0;
    }

    // Param is passed by value, moved
    pub fn set_ttl(&mut self, v: u64) {
        self.ttl = v;
    }

    // bool not_found = 4;


    pub fn get_not_found(&self) -> bool {
        self.not_found
    }
    pub fn clear_not_found(&mut self) {
        self.not_found = false;
    }

    // Param is passed by value, moved
    pub fn set_not_found(&mut self, v: bool) {
        self.not_found = v;
    }
}

impl ::protobuf::Message for RawGetKeyTtlResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ttl = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.not_found = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if self.ttl != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ttl, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.not_found != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if self.ttl != 0 {
            os.write_uint64(3, self.ttl)?;
        }
        if self.not_found != false {
            os.write_bool(4, self.not_found)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawGetKeyTtlResponse {
        RawGetKeyTtlResponse::new()
    }

    fn default_instance() -> &'static RawGetKeyTtlResponse {
        static mut instance: ::protobuf::lazy::Lazy<RawGetKeyTtlResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawGetKeyTtlResponse,
        };
        unsafe {
            instance.get(RawGetKeyTtlResponse::new)
        }
    }
}

impl ::protobuf::Clear for RawGetKeyTtlResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.ttl = 0;
        self.not_found = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawGetKeyTtlResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.ttl, "ttl", buf);
        ::protobuf::PbPrint::fmt(&self.not_found, "not_found", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawGetKeyTtlResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.ttl, "ttl", &mut s);
        ::protobuf::PbPrint::fmt(&self.not_found, "not_found", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawGetKeyTtlResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawCasRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub key: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub previous_not_exist: bool,
    pub previous_value: ::std::vec::Vec<u8>,
    pub cf: ::std::string::String,
    pub ttl: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawCasRequest {
    fn default() -> &'a RawCasRequest {
        <RawCasRequest as ::protobuf::Message>::default_instance()
    }
}

impl RawCasRequest {
    pub fn new() -> RawCasRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // bytes key = 2;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes value = 3;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // bool previous_not_exist = 4;


    pub fn get_previous_not_exist(&self) -> bool {
        self.previous_not_exist
    }
    pub fn clear_previous_not_exist(&mut self) {
        self.previous_not_exist = false;
    }

    // Param is passed by value, moved
    pub fn set_previous_not_exist(&mut self, v: bool) {
        self.previous_not_exist = v;
    }

    // bytes previous_value = 5;


    pub fn get_previous_value(&self) -> &[u8] {
        &self.previous_value
    }
    pub fn clear_previous_value(&mut self) {
        self.previous_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_previous_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.previous_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_previous_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.previous_value
    }

    // Take field
    pub fn take_previous_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.previous_value, ::std::vec::Vec::new())
    }

    // string cf = 6;


    pub fn get_cf(&self) -> &str {
        &self.cf
    }
    pub fn clear_cf(&mut self) {
        self.cf.clear();
    }

    // Param is passed by value, moved
    pub fn set_cf(&mut self, v: ::std::string::String) {
        self.cf = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cf(&mut self) -> &mut ::std::string::String {
        &mut self.cf
    }

    // Take field
    pub fn take_cf(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cf, ::std::string::String::new())
    }

    // uint64 ttl = 7;


    pub fn get_ttl(&self) -> u64 {
        self.ttl
    }
    pub fn clear_ttl(&mut self) {
        self.ttl = 0;
    }

    // Param is passed by value, moved
    pub fn set_ttl(&mut self, v: u64) {
        self.ttl = v;
    }
}

impl ::protobuf::Message for RawCasRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.previous_not_exist = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.previous_value)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cf)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ttl = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.value);
        }
        if self.previous_not_exist != false {
            my_size += 2;
        }
        if !self.previous_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.previous_value);
        }
        if !self.cf.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.cf);
        }
        if self.ttl != 0 {
            my_size += ::protobuf::rt::value_size(7, self.ttl, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(2, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(3, &self.value)?;
        }
        if self.previous_not_exist != false {
            os.write_bool(4, self.previous_not_exist)?;
        }
        if !self.previous_value.is_empty() {
            os.write_bytes(5, &self.previous_value)?;
        }
        if !self.cf.is_empty() {
            os.write_string(6, &self.cf)?;
        }
        if self.ttl != 0 {
            os.write_uint64(7, self.ttl)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawCasRequest {
        RawCasRequest::new()
    }

    fn default_instance() -> &'static RawCasRequest {
        static mut instance: ::protobuf::lazy::Lazy<RawCasRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawCasRequest,
        };
        unsafe {
            instance.get(RawCasRequest::new)
        }
    }
}

impl ::protobuf::Clear for RawCasRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.key.clear();
        self.value.clear();
        self.previous_not_exist = false;
        self.previous_value.clear();
        self.cf.clear();
        self.ttl = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawCasRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        ::protobuf::PbPrint::fmt(&self.value, "value", buf);
        ::protobuf::PbPrint::fmt(&self.previous_not_exist, "previous_not_exist", buf);
        ::protobuf::PbPrint::fmt(&self.previous_value, "previous_value", buf);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", buf);
        ::protobuf::PbPrint::fmt(&self.ttl, "ttl", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawCasRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        ::protobuf::PbPrint::fmt(&self.value, "value", &mut s);
        ::protobuf::PbPrint::fmt(&self.previous_not_exist, "previous_not_exist", &mut s);
        ::protobuf::PbPrint::fmt(&self.previous_value, "previous_value", &mut s);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", &mut s);
        ::protobuf::PbPrint::fmt(&self.ttl, "ttl", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawCasRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawCasResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::std::string::String,
    pub succeed: bool,
    pub previous_not_exist: bool,
    pub previous_value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawCasResponse {
    fn default() -> &'a RawCasResponse {
        <RawCasResponse as ::protobuf::Message>::default_instance()
    }
}

impl RawCasResponse {
    pub fn new() -> RawCasResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // bool succeed = 3;


    pub fn get_succeed(&self) -> bool {
        self.succeed
    }
    pub fn clear_succeed(&mut self) {
        self.succeed = false;
    }

    // Param is passed by value, moved
    pub fn set_succeed(&mut self, v: bool) {
        self.succeed = v;
    }

    // bool previous_not_exist = 4;


    pub fn get_previous_not_exist(&self) -> bool {
        self.previous_not_exist
    }
    pub fn clear_previous_not_exist(&mut self) {
        self.previous_not_exist = false;
    }

    // Param is passed by value, moved
    pub fn set_previous_not_exist(&mut self, v: bool) {
        self.previous_not_exist = v;
    }

    // bytes previous_value = 5;


    pub fn get_previous_value(&self) -> &[u8] {
        &self.previous_value
    }
    pub fn clear_previous_value(&mut self) {
        self.previous_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_previous_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.previous_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_previous_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.previous_value
    }

    // Take field
    pub fn take_previous_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.previous_value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RawCasResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.succeed = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.previous_not_exist = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.previous_value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if self.succeed != false {
            my_size += 2;
        }
        if self.previous_not_exist != false {
            my_size += 2;
        }
        if !self.previous_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.previous_value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if self.succeed != false {
            os.write_bool(3, self.succeed)?;
        }
        if self.previous_not_exist != false {
            os.write_bool(4, self.previous_not_exist)?;
        }
        if !self.previous_value.is_empty() {
            os.write_bytes(5, &self.previous_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawCasResponse {
        RawCasResponse::new()
    }

    fn default_instance() -> &'static RawCasResponse {
        static mut instance: ::protobuf::lazy::Lazy<RawCasResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawCasResponse,
        };
        unsafe {
            instance.get(RawCasResponse::new)
        }
    }
}

impl ::protobuf::Clear for RawCasResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.succeed = false;
        self.previous_not_exist = false;
        self.previous_value.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawCasResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.succeed, "succeed", buf);
        ::protobuf::PbPrint::fmt(&self.previous_not_exist, "previous_not_exist", buf);
        ::protobuf::PbPrint::fmt(&self.previous_value, "previous_value", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawCasResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.succeed, "succeed", &mut s);
        ::protobuf::PbPrint::fmt(&self.previous_not_exist, "previous_not_exist", &mut s);
        ::protobuf::PbPrint::fmt(&self.previous_value, "previous_value", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawCasResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLockWaitInfoRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLockWaitInfoRequest {
    fn default() -> &'a GetLockWaitInfoRequest {
        <GetLockWaitInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetLockWaitInfoRequest {
    pub fn new() -> GetLockWaitInfoRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }
}

impl ::protobuf::Message for GetLockWaitInfoRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLockWaitInfoRequest {
        GetLockWaitInfoRequest::new()
    }

    fn default_instance() -> &'static GetLockWaitInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetLockWaitInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetLockWaitInfoRequest,
        };
        unsafe {
            instance.get(GetLockWaitInfoRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetLockWaitInfoRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for GetLockWaitInfoRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for GetLockWaitInfoRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLockWaitInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLockWaitInfoResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::std::string::String,
    pub entries: ::protobuf::RepeatedField<super::deadlock::WaitForEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLockWaitInfoResponse {
    fn default() -> &'a GetLockWaitInfoResponse {
        <GetLockWaitInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetLockWaitInfoResponse {
    pub fn new() -> GetLockWaitInfoResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // repeated .deadlock.WaitForEntry entries = 3;


    pub fn get_entries(&self) -> &[super::deadlock::WaitForEntry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<super::deadlock::WaitForEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<super::deadlock::WaitForEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<super::deadlock::WaitForEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetLockWaitInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        for v in &self.entries {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLockWaitInfoResponse {
        GetLockWaitInfoResponse::new()
    }

    fn default_instance() -> &'static GetLockWaitInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetLockWaitInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetLockWaitInfoResponse,
        };
        unsafe {
            instance.get(GetLockWaitInfoResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetLockWaitInfoResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for GetLockWaitInfoResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.entries, "entries", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for GetLockWaitInfoResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.entries, "entries", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLockWaitInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLockWaitHistoryRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLockWaitHistoryRequest {
    fn default() -> &'a GetLockWaitHistoryRequest {
        <GetLockWaitHistoryRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetLockWaitHistoryRequest {
    pub fn new() -> GetLockWaitHistoryRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }
}

impl ::protobuf::Message for GetLockWaitHistoryRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLockWaitHistoryRequest {
        GetLockWaitHistoryRequest::new()
    }

    fn default_instance() -> &'static GetLockWaitHistoryRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetLockWaitHistoryRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetLockWaitHistoryRequest,
        };
        unsafe {
            instance.get(GetLockWaitHistoryRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetLockWaitHistoryRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for GetLockWaitHistoryRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for GetLockWaitHistoryRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLockWaitHistoryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLockWaitHistoryResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::std::string::String,
    pub entries: ::protobuf::RepeatedField<super::deadlock::WaitForEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLockWaitHistoryResponse {
    fn default() -> &'a GetLockWaitHistoryResponse {
        <GetLockWaitHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetLockWaitHistoryResponse {
    pub fn new() -> GetLockWaitHistoryResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // repeated .deadlock.WaitForEntry entries = 3;


    pub fn get_entries(&self) -> &[super::deadlock::WaitForEntry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<super::deadlock::WaitForEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<super::deadlock::WaitForEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<super::deadlock::WaitForEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetLockWaitHistoryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        for v in &self.entries {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLockWaitHistoryResponse {
        GetLockWaitHistoryResponse::new()
    }

    fn default_instance() -> &'static GetLockWaitHistoryResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetLockWaitHistoryResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetLockWaitHistoryResponse,
        };
        unsafe {
            instance.get(GetLockWaitHistoryResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetLockWaitHistoryResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for GetLockWaitHistoryResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.entries, "entries", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for GetLockWaitHistoryResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.entries, "entries", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLockWaitHistoryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawCoprocessorRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub copr_name: ::std::string::String,
    pub copr_version_req: ::std::string::String,
    pub ranges: ::protobuf::RepeatedField<KeyRange>,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawCoprocessorRequest {
    fn default() -> &'a RawCoprocessorRequest {
        <RawCoprocessorRequest as ::protobuf::Message>::default_instance()
    }
}

impl RawCoprocessorRequest {
    pub fn new() -> RawCoprocessorRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // string copr_name = 2;


    pub fn get_copr_name(&self) -> &str {
        &self.copr_name
    }
    pub fn clear_copr_name(&mut self) {
        self.copr_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_copr_name(&mut self, v: ::std::string::String) {
        self.copr_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_copr_name(&mut self) -> &mut ::std::string::String {
        &mut self.copr_name
    }

    // Take field
    pub fn take_copr_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.copr_name, ::std::string::String::new())
    }

    // string copr_version_req = 3;


    pub fn get_copr_version_req(&self) -> &str {
        &self.copr_version_req
    }
    pub fn clear_copr_version_req(&mut self) {
        self.copr_version_req.clear();
    }

    // Param is passed by value, moved
    pub fn set_copr_version_req(&mut self, v: ::std::string::String) {
        self.copr_version_req = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_copr_version_req(&mut self) -> &mut ::std::string::String {
        &mut self.copr_version_req
    }

    // Take field
    pub fn take_copr_version_req(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.copr_version_req, ::std::string::String::new())
    }

    // repeated .kvrpcpb.KeyRange ranges = 4;


    pub fn get_ranges(&self) -> &[KeyRange] {
        &self.ranges
    }
    pub fn clear_ranges(&mut self) {
        self.ranges.clear();
    }

    // Param is passed by value, moved
    pub fn set_ranges(&mut self, v: ::protobuf::RepeatedField<KeyRange>) {
        self.ranges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ranges(&mut self) -> &mut ::protobuf::RepeatedField<KeyRange> {
        &mut self.ranges
    }

    // Take field
    pub fn take_ranges(&mut self) -> ::protobuf::RepeatedField<KeyRange> {
        ::std::mem::replace(&mut self.ranges, ::protobuf::RepeatedField::new())
    }

    // bytes data = 5;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RawCoprocessorRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ranges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.copr_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.copr_version_req)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ranges)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.copr_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.copr_name);
        }
        if !self.copr_version_req.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.copr_version_req);
        }
        for value in &self.ranges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.copr_name.is_empty() {
            os.write_string(2, &self.copr_name)?;
        }
        if !self.copr_version_req.is_empty() {
            os.write_string(3, &self.copr_version_req)?;
        }
        for v in &self.ranges {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.data.is_empty() {
            os.write_bytes(5, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawCoprocessorRequest {
        RawCoprocessorRequest::new()
    }

    fn default_instance() -> &'static RawCoprocessorRequest {
        static mut instance: ::protobuf::lazy::Lazy<RawCoprocessorRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawCoprocessorRequest,
        };
        unsafe {
            instance.get(RawCoprocessorRequest::new)
        }
    }
}

impl ::protobuf::Clear for RawCoprocessorRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.copr_name.clear();
        self.copr_version_req.clear();
        self.ranges.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawCoprocessorRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.copr_name, "copr_name", buf);
        ::protobuf::PbPrint::fmt(&self.copr_version_req, "copr_version_req", buf);
        ::protobuf::PbPrint::fmt(&self.ranges, "ranges", buf);
        ::protobuf::PbPrint::fmt(&self.data, "data", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawCoprocessorRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.copr_name, "copr_name", &mut s);
        ::protobuf::PbPrint::fmt(&self.copr_version_req, "copr_version_req", &mut s);
        ::protobuf::PbPrint::fmt(&self.ranges, "ranges", &mut s);
        ::protobuf::PbPrint::fmt(&self.data, "data", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawCoprocessorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawCoprocessorResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::std::string::String,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawCoprocessorResponse {
    fn default() -> &'a RawCoprocessorResponse {
        <RawCoprocessorResponse as ::protobuf::Message>::default_instance()
    }
}

impl RawCoprocessorResponse {
    pub fn new() -> RawCoprocessorResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // bytes data = 3;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RawCoprocessorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawCoprocessorResponse {
        RawCoprocessorResponse::new()
    }

    fn default_instance() -> &'static RawCoprocessorResponse {
        static mut instance: ::protobuf::lazy::Lazy<RawCoprocessorResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawCoprocessorResponse,
        };
        unsafe {
            instance.get(RawCoprocessorResponse::new)
        }
    }
}

impl ::protobuf::Clear for RawCoprocessorResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawCoprocessorResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.data, "data", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawCoprocessorResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.data, "data", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawCoprocessorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawChecksumRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<Context>,
    pub algorithm: ChecksumAlgorithm,
    pub ranges: ::protobuf::RepeatedField<KeyRange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawChecksumRequest {
    fn default() -> &'a RawChecksumRequest {
        <RawChecksumRequest as ::protobuf::Message>::default_instance()
    }
}

impl RawChecksumRequest {
    pub fn new() -> RawChecksumRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &Context {
        self.context.as_ref().unwrap_or_else(|| Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> Context {
        self.context.take().unwrap_or_else(|| Context::new())
    }

    // .kvrpcpb.ChecksumAlgorithm algorithm = 2;


    pub fn get_algorithm(&self) -> ChecksumAlgorithm {
        self.algorithm
    }
    pub fn clear_algorithm(&mut self) {
        self.algorithm = ChecksumAlgorithm::Crc64Xor;
    }

    // Param is passed by value, moved
    pub fn set_algorithm(&mut self, v: ChecksumAlgorithm) {
        self.algorithm = v;
    }

    // repeated .kvrpcpb.KeyRange ranges = 3;


    pub fn get_ranges(&self) -> &[KeyRange] {
        &self.ranges
    }
    pub fn clear_ranges(&mut self) {
        self.ranges.clear();
    }

    // Param is passed by value, moved
    pub fn set_ranges(&mut self, v: ::protobuf::RepeatedField<KeyRange>) {
        self.ranges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ranges(&mut self) -> &mut ::protobuf::RepeatedField<KeyRange> {
        &mut self.ranges
    }

    // Take field
    pub fn take_ranges(&mut self) -> ::protobuf::RepeatedField<KeyRange> {
        ::std::mem::replace(&mut self.ranges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RawChecksumRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ranges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.algorithm = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ranges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.algorithm != ChecksumAlgorithm::Crc64Xor {
            my_size += ::protobuf::rt::enum_size(2, self.algorithm);
        }
        for value in &self.ranges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.algorithm != ChecksumAlgorithm::Crc64Xor {
            os.write_enum(2, self.algorithm.value())?;
        }
        for v in &self.ranges {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawChecksumRequest {
        RawChecksumRequest::new()
    }

    fn default_instance() -> &'static RawChecksumRequest {
        static mut instance: ::protobuf::lazy::Lazy<RawChecksumRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawChecksumRequest,
        };
        unsafe {
            instance.get(RawChecksumRequest::new)
        }
    }
}

impl ::protobuf::Clear for RawChecksumRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.algorithm = ChecksumAlgorithm::Crc64Xor;
        self.ranges.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawChecksumRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.algorithm, "algorithm", buf);
        ::protobuf::PbPrint::fmt(&self.ranges, "ranges", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawChecksumRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.algorithm, "algorithm", &mut s);
        ::protobuf::PbPrint::fmt(&self.ranges, "ranges", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawChecksumRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawChecksumResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub error: ::std::string::String,
    pub checksum: u64,
    pub total_kvs: u64,
    pub total_bytes: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawChecksumResponse {
    fn default() -> &'a RawChecksumResponse {
        <RawChecksumResponse as ::protobuf::Message>::default_instance()
    }
}

impl RawChecksumResponse {
    pub fn new() -> RawChecksumResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // string error = 2;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    // uint64 checksum = 3;


    pub fn get_checksum(&self) -> u64 {
        self.checksum
    }
    pub fn clear_checksum(&mut self) {
        self.checksum = 0;
    }

    // Param is passed by value, moved
    pub fn set_checksum(&mut self, v: u64) {
        self.checksum = v;
    }

    // uint64 total_kvs = 4;


    pub fn get_total_kvs(&self) -> u64 {
        self.total_kvs
    }
    pub fn clear_total_kvs(&mut self) {
        self.total_kvs = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_kvs(&mut self, v: u64) {
        self.total_kvs = v;
    }

    // uint64 total_bytes = 5;


    pub fn get_total_bytes(&self) -> u64 {
        self.total_bytes
    }
    pub fn clear_total_bytes(&mut self) {
        self.total_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_bytes(&mut self, v: u64) {
        self.total_bytes = v;
    }
}

impl ::protobuf::Message for RawChecksumResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.checksum = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_kvs = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_bytes = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if self.checksum != 0 {
            my_size += ::protobuf::rt::value_size(3, self.checksum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_kvs != 0 {
            my_size += ::protobuf::rt::value_size(4, self.total_kvs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_bytes != 0 {
            my_size += ::protobuf::rt::value_size(5, self.total_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if self.checksum != 0 {
            os.write_uint64(3, self.checksum)?;
        }
        if self.total_kvs != 0 {
            os.write_uint64(4, self.total_kvs)?;
        }
        if self.total_bytes != 0 {
            os.write_uint64(5, self.total_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawChecksumResponse {
        RawChecksumResponse::new()
    }

    fn default_instance() -> &'static RawChecksumResponse {
        static mut instance: ::protobuf::lazy::Lazy<RawChecksumResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawChecksumResponse,
        };
        unsafe {
            instance.get(RawChecksumResponse::new)
        }
    }
}

impl ::protobuf::Clear for RawChecksumResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.error.clear();
        self.checksum = 0;
        self.total_kvs = 0;
        self.total_bytes = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawChecksumResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.checksum, "checksum", buf);
        ::protobuf::PbPrint::fmt(&self.total_kvs, "total_kvs", buf);
        ::protobuf::PbPrint::fmt(&self.total_bytes, "total_bytes", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawChecksumResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.checksum, "checksum", &mut s);
        ::protobuf::PbPrint::fmt(&self.total_kvs, "total_kvs", &mut s);
        ::protobuf::PbPrint::fmt(&self.total_bytes, "total_bytes", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawChecksumResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompactError {
    // message oneof groups
    pub error: ::std::option::Option<CompactError_oneof_error>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompactError {
    fn default() -> &'a CompactError {
        <CompactError as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq)]
pub enum CompactError_oneof_error {
    ErrInvalidStartKey(CompactErrorInvalidStartKey),
    ErrPhysicalTableNotExist(CompactErrorPhysicalTableNotExist),
    ErrCompactInProgress(CompactErrorCompactInProgress),
    ErrTooManyPendingTasks(CompactErrorTooManyPendingTasks),
}

impl ::protobuf::PbPrint for CompactError_oneof_error {
    fn fmt(&self, name: &str, buf: &mut String) {
        match self {
            CompactError_oneof_error::ErrInvalidStartKey(v) => ::protobuf::PbPrint::fmt(v, name, buf),
            CompactError_oneof_error::ErrPhysicalTableNotExist(v) => ::protobuf::PbPrint::fmt(v, name, buf),
            CompactError_oneof_error::ErrCompactInProgress(v) => ::protobuf::PbPrint::fmt(v, name, buf),
            CompactError_oneof_error::ErrTooManyPendingTasks(v) => ::protobuf::PbPrint::fmt(v, name, buf),
        }
    }
}

impl CompactError {
    pub fn new() -> CompactError {
        ::std::default::Default::default()
    }

    // .kvrpcpb.CompactErrorInvalidStartKey err_invalid_start_key = 1;


    pub fn get_err_invalid_start_key(&self) -> &CompactErrorInvalidStartKey {
        match self.error {
            ::std::option::Option::Some(CompactError_oneof_error::ErrInvalidStartKey(ref v)) => v,
            _ => CompactErrorInvalidStartKey::default_instance(),
        }
    }
    pub fn clear_err_invalid_start_key(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_err_invalid_start_key(&self) -> bool {
        match self.error {
            ::std::option::Option::Some(CompactError_oneof_error::ErrInvalidStartKey(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_err_invalid_start_key(&mut self, v: CompactErrorInvalidStartKey) {
        self.error = ::std::option::Option::Some(CompactError_oneof_error::ErrInvalidStartKey(v))
    }

    // Mutable pointer to the field.
    pub fn mut_err_invalid_start_key(&mut self) -> &mut CompactErrorInvalidStartKey {
        if let ::std::option::Option::Some(CompactError_oneof_error::ErrInvalidStartKey(_)) = self.error {
        } else {
            self.error = ::std::option::Option::Some(CompactError_oneof_error::ErrInvalidStartKey(CompactErrorInvalidStartKey::new()));
        }
        match self.error {
            ::std::option::Option::Some(CompactError_oneof_error::ErrInvalidStartKey(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_err_invalid_start_key(&mut self) -> CompactErrorInvalidStartKey {
        if self.has_err_invalid_start_key() {
            match self.error.take() {
                ::std::option::Option::Some(CompactError_oneof_error::ErrInvalidStartKey(v)) => v,
                _ => panic!(),
            }
        } else {
            CompactErrorInvalidStartKey::new()
        }
    }

    // .kvrpcpb.CompactErrorPhysicalTableNotExist err_physical_table_not_exist = 2;


    pub fn get_err_physical_table_not_exist(&self) -> &CompactErrorPhysicalTableNotExist {
        match self.error {
            ::std::option::Option::Some(CompactError_oneof_error::ErrPhysicalTableNotExist(ref v)) => v,
            _ => CompactErrorPhysicalTableNotExist::default_instance(),
        }
    }
    pub fn clear_err_physical_table_not_exist(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_err_physical_table_not_exist(&self) -> bool {
        match self.error {
            ::std::option::Option::Some(CompactError_oneof_error::ErrPhysicalTableNotExist(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_err_physical_table_not_exist(&mut self, v: CompactErrorPhysicalTableNotExist) {
        self.error = ::std::option::Option::Some(CompactError_oneof_error::ErrPhysicalTableNotExist(v))
    }

    // Mutable pointer to the field.
    pub fn mut_err_physical_table_not_exist(&mut self) -> &mut CompactErrorPhysicalTableNotExist {
        if let ::std::option::Option::Some(CompactError_oneof_error::ErrPhysicalTableNotExist(_)) = self.error {
        } else {
            self.error = ::std::option::Option::Some(CompactError_oneof_error::ErrPhysicalTableNotExist(CompactErrorPhysicalTableNotExist::new()));
        }
        match self.error {
            ::std::option::Option::Some(CompactError_oneof_error::ErrPhysicalTableNotExist(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_err_physical_table_not_exist(&mut self) -> CompactErrorPhysicalTableNotExist {
        if self.has_err_physical_table_not_exist() {
            match self.error.take() {
                ::std::option::Option::Some(CompactError_oneof_error::ErrPhysicalTableNotExist(v)) => v,
                _ => panic!(),
            }
        } else {
            CompactErrorPhysicalTableNotExist::new()
        }
    }

    // .kvrpcpb.CompactErrorCompactInProgress err_compact_in_progress = 3;


    pub fn get_err_compact_in_progress(&self) -> &CompactErrorCompactInProgress {
        match self.error {
            ::std::option::Option::Some(CompactError_oneof_error::ErrCompactInProgress(ref v)) => v,
            _ => CompactErrorCompactInProgress::default_instance(),
        }
    }
    pub fn clear_err_compact_in_progress(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_err_compact_in_progress(&self) -> bool {
        match self.error {
            ::std::option::Option::Some(CompactError_oneof_error::ErrCompactInProgress(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_err_compact_in_progress(&mut self, v: CompactErrorCompactInProgress) {
        self.error = ::std::option::Option::Some(CompactError_oneof_error::ErrCompactInProgress(v))
    }

    // Mutable pointer to the field.
    pub fn mut_err_compact_in_progress(&mut self) -> &mut CompactErrorCompactInProgress {
        if let ::std::option::Option::Some(CompactError_oneof_error::ErrCompactInProgress(_)) = self.error {
        } else {
            self.error = ::std::option::Option::Some(CompactError_oneof_error::ErrCompactInProgress(CompactErrorCompactInProgress::new()));
        }
        match self.error {
            ::std::option::Option::Some(CompactError_oneof_error::ErrCompactInProgress(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_err_compact_in_progress(&mut self) -> CompactErrorCompactInProgress {
        if self.has_err_compact_in_progress() {
            match self.error.take() {
                ::std::option::Option::Some(CompactError_oneof_error::ErrCompactInProgress(v)) => v,
                _ => panic!(),
            }
        } else {
            CompactErrorCompactInProgress::new()
        }
    }

    // .kvrpcpb.CompactErrorTooManyPendingTasks err_too_many_pending_tasks = 4;


    pub fn get_err_too_many_pending_tasks(&self) -> &CompactErrorTooManyPendingTasks {
        match self.error {
            ::std::option::Option::Some(CompactError_oneof_error::ErrTooManyPendingTasks(ref v)) => v,
            _ => CompactErrorTooManyPendingTasks::default_instance(),
        }
    }
    pub fn clear_err_too_many_pending_tasks(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_err_too_many_pending_tasks(&self) -> bool {
        match self.error {
            ::std::option::Option::Some(CompactError_oneof_error::ErrTooManyPendingTasks(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_err_too_many_pending_tasks(&mut self, v: CompactErrorTooManyPendingTasks) {
        self.error = ::std::option::Option::Some(CompactError_oneof_error::ErrTooManyPendingTasks(v))
    }

    // Mutable pointer to the field.
    pub fn mut_err_too_many_pending_tasks(&mut self) -> &mut CompactErrorTooManyPendingTasks {
        if let ::std::option::Option::Some(CompactError_oneof_error::ErrTooManyPendingTasks(_)) = self.error {
        } else {
            self.error = ::std::option::Option::Some(CompactError_oneof_error::ErrTooManyPendingTasks(CompactErrorTooManyPendingTasks::new()));
        }
        match self.error {
            ::std::option::Option::Some(CompactError_oneof_error::ErrTooManyPendingTasks(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_err_too_many_pending_tasks(&mut self) -> CompactErrorTooManyPendingTasks {
        if self.has_err_too_many_pending_tasks() {
            match self.error.take() {
                ::std::option::Option::Some(CompactError_oneof_error::ErrTooManyPendingTasks(v)) => v,
                _ => panic!(),
            }
        } else {
            CompactErrorTooManyPendingTasks::new()
        }
    }
}

impl ::protobuf::Message for CompactError {
    fn is_initialized(&self) -> bool {
        if let Some(CompactError_oneof_error::ErrInvalidStartKey(ref v)) = self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CompactError_oneof_error::ErrPhysicalTableNotExist(ref v)) = self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CompactError_oneof_error::ErrCompactInProgress(ref v)) = self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CompactError_oneof_error::ErrTooManyPendingTasks(ref v)) = self.error {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error = ::std::option::Option::Some(CompactError_oneof_error::ErrInvalidStartKey(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error = ::std::option::Option::Some(CompactError_oneof_error::ErrPhysicalTableNotExist(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error = ::std::option::Option::Some(CompactError_oneof_error::ErrCompactInProgress(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error = ::std::option::Option::Some(CompactError_oneof_error::ErrTooManyPendingTasks(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.error {
            match v {
                &CompactError_oneof_error::ErrInvalidStartKey(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CompactError_oneof_error::ErrPhysicalTableNotExist(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CompactError_oneof_error::ErrCompactInProgress(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CompactError_oneof_error::ErrTooManyPendingTasks(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.error {
            match v {
                &CompactError_oneof_error::ErrInvalidStartKey(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CompactError_oneof_error::ErrPhysicalTableNotExist(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CompactError_oneof_error::ErrCompactInProgress(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CompactError_oneof_error::ErrTooManyPendingTasks(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompactError {
        CompactError::new()
    }

    fn default_instance() -> &'static CompactError {
        static mut instance: ::protobuf::lazy::Lazy<CompactError> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompactError,
        };
        unsafe {
            instance.get(CompactError::new)
        }
    }
}

impl ::protobuf::Clear for CompactError {
    fn clear(&mut self) {
        self.error = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CompactError {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for CompactError {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompactError {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompactErrorInvalidStartKey {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompactErrorInvalidStartKey {
    fn default() -> &'a CompactErrorInvalidStartKey {
        <CompactErrorInvalidStartKey as ::protobuf::Message>::default_instance()
    }
}

impl CompactErrorInvalidStartKey {
    pub fn new() -> CompactErrorInvalidStartKey {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CompactErrorInvalidStartKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompactErrorInvalidStartKey {
        CompactErrorInvalidStartKey::new()
    }

    fn default_instance() -> &'static CompactErrorInvalidStartKey {
        static mut instance: ::protobuf::lazy::Lazy<CompactErrorInvalidStartKey> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompactErrorInvalidStartKey,
        };
        unsafe {
            instance.get(CompactErrorInvalidStartKey::new)
        }
    }
}

impl ::protobuf::Clear for CompactErrorInvalidStartKey {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CompactErrorInvalidStartKey {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
    }
}
impl ::std::fmt::Debug for CompactErrorInvalidStartKey {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        Ok(())
    }
}

impl ::protobuf::reflect::ProtobufValue for CompactErrorInvalidStartKey {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompactErrorPhysicalTableNotExist {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompactErrorPhysicalTableNotExist {
    fn default() -> &'a CompactErrorPhysicalTableNotExist {
        <CompactErrorPhysicalTableNotExist as ::protobuf::Message>::default_instance()
    }
}

impl CompactErrorPhysicalTableNotExist {
    pub fn new() -> CompactErrorPhysicalTableNotExist {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CompactErrorPhysicalTableNotExist {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompactErrorPhysicalTableNotExist {
        CompactErrorPhysicalTableNotExist::new()
    }

    fn default_instance() -> &'static CompactErrorPhysicalTableNotExist {
        static mut instance: ::protobuf::lazy::Lazy<CompactErrorPhysicalTableNotExist> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompactErrorPhysicalTableNotExist,
        };
        unsafe {
            instance.get(CompactErrorPhysicalTableNotExist::new)
        }
    }
}

impl ::protobuf::Clear for CompactErrorPhysicalTableNotExist {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CompactErrorPhysicalTableNotExist {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
    }
}
impl ::std::fmt::Debug for CompactErrorPhysicalTableNotExist {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        Ok(())
    }
}

impl ::protobuf::reflect::ProtobufValue for CompactErrorPhysicalTableNotExist {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompactErrorCompactInProgress {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompactErrorCompactInProgress {
    fn default() -> &'a CompactErrorCompactInProgress {
        <CompactErrorCompactInProgress as ::protobuf::Message>::default_instance()
    }
}

impl CompactErrorCompactInProgress {
    pub fn new() -> CompactErrorCompactInProgress {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CompactErrorCompactInProgress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompactErrorCompactInProgress {
        CompactErrorCompactInProgress::new()
    }

    fn default_instance() -> &'static CompactErrorCompactInProgress {
        static mut instance: ::protobuf::lazy::Lazy<CompactErrorCompactInProgress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompactErrorCompactInProgress,
        };
        unsafe {
            instance.get(CompactErrorCompactInProgress::new)
        }
    }
}

impl ::protobuf::Clear for CompactErrorCompactInProgress {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CompactErrorCompactInProgress {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
    }
}
impl ::std::fmt::Debug for CompactErrorCompactInProgress {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        Ok(())
    }
}

impl ::protobuf::reflect::ProtobufValue for CompactErrorCompactInProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompactErrorTooManyPendingTasks {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompactErrorTooManyPendingTasks {
    fn default() -> &'a CompactErrorTooManyPendingTasks {
        <CompactErrorTooManyPendingTasks as ::protobuf::Message>::default_instance()
    }
}

impl CompactErrorTooManyPendingTasks {
    pub fn new() -> CompactErrorTooManyPendingTasks {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CompactErrorTooManyPendingTasks {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompactErrorTooManyPendingTasks {
        CompactErrorTooManyPendingTasks::new()
    }

    fn default_instance() -> &'static CompactErrorTooManyPendingTasks {
        static mut instance: ::protobuf::lazy::Lazy<CompactErrorTooManyPendingTasks> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompactErrorTooManyPendingTasks,
        };
        unsafe {
            instance.get(CompactErrorTooManyPendingTasks::new)
        }
    }
}

impl ::protobuf::Clear for CompactErrorTooManyPendingTasks {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CompactErrorTooManyPendingTasks {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
    }
}
impl ::std::fmt::Debug for CompactErrorTooManyPendingTasks {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        Ok(())
    }
}

impl ::protobuf::reflect::ProtobufValue for CompactErrorTooManyPendingTasks {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompactRequest {
    // message fields
    pub start_key: ::std::vec::Vec<u8>,
    pub physical_table_id: i64,
    pub logical_table_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompactRequest {
    fn default() -> &'a CompactRequest {
        <CompactRequest as ::protobuf::Message>::default_instance()
    }
}

impl CompactRequest {
    pub fn new() -> CompactRequest {
        ::std::default::Default::default()
    }

    // bytes start_key = 1;


    pub fn get_start_key(&self) -> &[u8] {
        &self.start_key
    }
    pub fn clear_start_key(&mut self) {
        self.start_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.start_key
    }

    // Take field
    pub fn take_start_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.start_key, ::std::vec::Vec::new())
    }

    // int64 physical_table_id = 2;


    pub fn get_physical_table_id(&self) -> i64 {
        self.physical_table_id
    }
    pub fn clear_physical_table_id(&mut self) {
        self.physical_table_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_physical_table_id(&mut self, v: i64) {
        self.physical_table_id = v;
    }

    // int64 logical_table_id = 3;


    pub fn get_logical_table_id(&self) -> i64 {
        self.logical_table_id
    }
    pub fn clear_logical_table_id(&mut self) {
        self.logical_table_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_logical_table_id(&mut self, v: i64) {
        self.logical_table_id = v;
    }
}

impl ::protobuf::Message for CompactRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.start_key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.physical_table_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.logical_table_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.start_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.start_key);
        }
        if self.physical_table_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.physical_table_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.logical_table_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.logical_table_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.start_key.is_empty() {
            os.write_bytes(1, &self.start_key)?;
        }
        if self.physical_table_id != 0 {
            os.write_int64(2, self.physical_table_id)?;
        }
        if self.logical_table_id != 0 {
            os.write_int64(3, self.logical_table_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompactRequest {
        CompactRequest::new()
    }

    fn default_instance() -> &'static CompactRequest {
        static mut instance: ::protobuf::lazy::Lazy<CompactRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompactRequest,
        };
        unsafe {
            instance.get(CompactRequest::new)
        }
    }
}

impl ::protobuf::Clear for CompactRequest {
    fn clear(&mut self) {
        self.start_key.clear();
        self.physical_table_id = 0;
        self.logical_table_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CompactRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", buf);
        ::protobuf::PbPrint::fmt(&self.physical_table_id, "physical_table_id", buf);
        ::protobuf::PbPrint::fmt(&self.logical_table_id, "logical_table_id", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for CompactRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.physical_table_id, "physical_table_id", &mut s);
        ::protobuf::PbPrint::fmt(&self.logical_table_id, "logical_table_id", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompactRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompactResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<CompactError>,
    pub has_remaining: bool,
    pub compacted_start_key: ::std::vec::Vec<u8>,
    pub compacted_end_key: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompactResponse {
    fn default() -> &'a CompactResponse {
        <CompactResponse as ::protobuf::Message>::default_instance()
    }
}

impl CompactResponse {
    pub fn new() -> CompactResponse {
        ::std::default::Default::default()
    }

    // .kvrpcpb.CompactError error = 1;


    pub fn get_error(&self) -> &CompactError {
        self.error.as_ref().unwrap_or_else(|| CompactError::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CompactError) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut CompactError {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> CompactError {
        self.error.take().unwrap_or_else(|| CompactError::new())
    }

    // bool has_remaining = 2;


    pub fn get_has_remaining(&self) -> bool {
        self.has_remaining
    }
    pub fn clear_has_remaining(&mut self) {
        self.has_remaining = false;
    }

    // Param is passed by value, moved
    pub fn set_has_remaining(&mut self, v: bool) {
        self.has_remaining = v;
    }

    // bytes compacted_start_key = 3;


    pub fn get_compacted_start_key(&self) -> &[u8] {
        &self.compacted_start_key
    }
    pub fn clear_compacted_start_key(&mut self) {
        self.compacted_start_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_compacted_start_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.compacted_start_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compacted_start_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.compacted_start_key
    }

    // Take field
    pub fn take_compacted_start_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.compacted_start_key, ::std::vec::Vec::new())
    }

    // bytes compacted_end_key = 4;


    pub fn get_compacted_end_key(&self) -> &[u8] {
        &self.compacted_end_key
    }
    pub fn clear_compacted_end_key(&mut self) {
        self.compacted_end_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_compacted_end_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.compacted_end_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compacted_end_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.compacted_end_key
    }

    // Take field
    pub fn take_compacted_end_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.compacted_end_key, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CompactResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_remaining = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.compacted_start_key)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.compacted_end_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.has_remaining != false {
            my_size += 2;
        }
        if !self.compacted_start_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.compacted_start_key);
        }
        if !self.compacted_end_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.compacted_end_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.has_remaining != false {
            os.write_bool(2, self.has_remaining)?;
        }
        if !self.compacted_start_key.is_empty() {
            os.write_bytes(3, &self.compacted_start_key)?;
        }
        if !self.compacted_end_key.is_empty() {
            os.write_bytes(4, &self.compacted_end_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompactResponse {
        CompactResponse::new()
    }

    fn default_instance() -> &'static CompactResponse {
        static mut instance: ::protobuf::lazy::Lazy<CompactResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompactResponse,
        };
        unsafe {
            instance.get(CompactResponse::new)
        }
    }
}

impl ::protobuf::Clear for CompactResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.has_remaining = false;
        self.compacted_start_key.clear();
        self.compacted_end_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CompactResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.has_remaining, "has_remaining", buf);
        ::protobuf::PbPrint::fmt(&self.compacted_start_key, "compacted_start_key", buf);
        ::protobuf::PbPrint::fmt(&self.compacted_end_key, "compacted_end_key", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for CompactResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.has_remaining, "has_remaining", &mut s);
        ::protobuf::PbPrint::fmt(&self.compacted_start_key, "compacted_start_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.compacted_end_key, "compacted_end_key", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompactResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ApiVersion {
    V1 = 0,
    V1ttl = 1,
    V2 = 2,
}

impl ::protobuf::ProtobufEnum for ApiVersion {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ApiVersion> {
        match value {
            0 => ::std::option::Option::Some(ApiVersion::V1),
            1 => ::std::option::Option::Some(ApiVersion::V1ttl),
            2 => ::std::option::Option::Some(ApiVersion::V2),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ApiVersion] = &[
            ApiVersion::V1,
            ApiVersion::V1ttl,
            ApiVersion::V2,
        ];
        values
    }
}

impl ::std::marker::Copy for ApiVersion {
}

impl ::protobuf::PbPrint for ApiVersion {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == ApiVersion::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for ApiVersion {
    fn default() -> Self {
        ApiVersion::V1
    }
}

impl ::protobuf::reflect::ProtobufValue for ApiVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommandPri {
    Normal = 0,
    Low = 1,
    High = 2,
}

impl ::protobuf::ProtobufEnum for CommandPri {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommandPri> {
        match value {
            0 => ::std::option::Option::Some(CommandPri::Normal),
            1 => ::std::option::Option::Some(CommandPri::Low),
            2 => ::std::option::Option::Some(CommandPri::High),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommandPri] = &[
            CommandPri::Normal,
            CommandPri::Low,
            CommandPri::High,
        ];
        values
    }
}

impl ::std::marker::Copy for CommandPri {
}

impl ::protobuf::PbPrint for CommandPri {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == CommandPri::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for CommandPri {
    fn default() -> Self {
        CommandPri::Normal
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandPri {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum IsolationLevel {
    Si = 0,
    Rc = 1,
    RcCheckTs = 2,
}

impl ::protobuf::ProtobufEnum for IsolationLevel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<IsolationLevel> {
        match value {
            0 => ::std::option::Option::Some(IsolationLevel::Si),
            1 => ::std::option::Option::Some(IsolationLevel::Rc),
            2 => ::std::option::Option::Some(IsolationLevel::RcCheckTs),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [IsolationLevel] = &[
            IsolationLevel::Si,
            IsolationLevel::Rc,
            IsolationLevel::RcCheckTs,
        ];
        values
    }
}

impl ::std::marker::Copy for IsolationLevel {
}

impl ::protobuf::PbPrint for IsolationLevel {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == IsolationLevel::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for IsolationLevel {
    fn default() -> Self {
        IsolationLevel::Si
    }
}

impl ::protobuf::reflect::ProtobufValue for IsolationLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DiskFullOpt {
    NotAllowedOnFull = 0,
    AllowedOnAlmostFull = 1,
    AllowedOnAlreadyFull = 2,
}

impl ::protobuf::ProtobufEnum for DiskFullOpt {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DiskFullOpt> {
        match value {
            0 => ::std::option::Option::Some(DiskFullOpt::NotAllowedOnFull),
            1 => ::std::option::Option::Some(DiskFullOpt::AllowedOnAlmostFull),
            2 => ::std::option::Option::Some(DiskFullOpt::AllowedOnAlreadyFull),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DiskFullOpt] = &[
            DiskFullOpt::NotAllowedOnFull,
            DiskFullOpt::AllowedOnAlmostFull,
            DiskFullOpt::AllowedOnAlreadyFull,
        ];
        values
    }
}

impl ::std::marker::Copy for DiskFullOpt {
}

impl ::protobuf::PbPrint for DiskFullOpt {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == DiskFullOpt::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for DiskFullOpt {
    fn default() -> Self {
        DiskFullOpt::NotAllowedOnFull
    }
}

impl ::protobuf::reflect::ProtobufValue for DiskFullOpt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Op {
    Put = 0,
    Del = 1,
    Lock = 2,
    Rollback = 3,
    Insert = 4,
    PessimisticLock = 5,
    CheckNotExists = 6,
}

impl ::protobuf::ProtobufEnum for Op {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Op> {
        match value {
            0 => ::std::option::Option::Some(Op::Put),
            1 => ::std::option::Option::Some(Op::Del),
            2 => ::std::option::Option::Some(Op::Lock),
            3 => ::std::option::Option::Some(Op::Rollback),
            4 => ::std::option::Option::Some(Op::Insert),
            5 => ::std::option::Option::Some(Op::PessimisticLock),
            6 => ::std::option::Option::Some(Op::CheckNotExists),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Op] = &[
            Op::Put,
            Op::Del,
            Op::Lock,
            Op::Rollback,
            Op::Insert,
            Op::PessimisticLock,
            Op::CheckNotExists,
        ];
        values
    }
}

impl ::std::marker::Copy for Op {
}

impl ::protobuf::PbPrint for Op {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == Op::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for Op {
    fn default() -> Self {
        Op::Put
    }
}

impl ::protobuf::reflect::ProtobufValue for Op {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Assertion {
    None = 0,
    Exist = 1,
    NotExist = 2,
}

impl ::protobuf::ProtobufEnum for Assertion {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Assertion> {
        match value {
            0 => ::std::option::Option::Some(Assertion::None),
            1 => ::std::option::Option::Some(Assertion::Exist),
            2 => ::std::option::Option::Some(Assertion::NotExist),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Assertion] = &[
            Assertion::None,
            Assertion::Exist,
            Assertion::NotExist,
        ];
        values
    }
}

impl ::std::marker::Copy for Assertion {
}

impl ::protobuf::PbPrint for Assertion {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == Assertion::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for Assertion {
    fn default() -> Self {
        Assertion::None
    }
}

impl ::protobuf::reflect::ProtobufValue for Assertion {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AssertionLevel {
    Off = 0,
    Fast = 1,
    Strict = 2,
}

impl ::protobuf::ProtobufEnum for AssertionLevel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AssertionLevel> {
        match value {
            0 => ::std::option::Option::Some(AssertionLevel::Off),
            1 => ::std::option::Option::Some(AssertionLevel::Fast),
            2 => ::std::option::Option::Some(AssertionLevel::Strict),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AssertionLevel] = &[
            AssertionLevel::Off,
            AssertionLevel::Fast,
            AssertionLevel::Strict,
        ];
        values
    }
}

impl ::std::marker::Copy for AssertionLevel {
}

impl ::protobuf::PbPrint for AssertionLevel {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == AssertionLevel::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for AssertionLevel {
    fn default() -> Self {
        AssertionLevel::Off
    }
}

impl ::protobuf::reflect::ProtobufValue for AssertionLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Action {
    NoAction = 0,
    TtlExpireRollback = 1,
    LockNotExistRollback = 2,
    MinCommitTsPushed = 3,
    TtlExpirePessimisticRollback = 4,
    LockNotExistDoNothing = 5,
}

impl ::protobuf::ProtobufEnum for Action {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Action> {
        match value {
            0 => ::std::option::Option::Some(Action::NoAction),
            1 => ::std::option::Option::Some(Action::TtlExpireRollback),
            2 => ::std::option::Option::Some(Action::LockNotExistRollback),
            3 => ::std::option::Option::Some(Action::MinCommitTsPushed),
            4 => ::std::option::Option::Some(Action::TtlExpirePessimisticRollback),
            5 => ::std::option::Option::Some(Action::LockNotExistDoNothing),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Action] = &[
            Action::NoAction,
            Action::TtlExpireRollback,
            Action::LockNotExistRollback,
            Action::MinCommitTsPushed,
            Action::TtlExpirePessimisticRollback,
            Action::LockNotExistDoNothing,
        ];
        values
    }
}

impl ::std::marker::Copy for Action {
}

impl ::protobuf::PbPrint for Action {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == Action::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for Action {
    fn default() -> Self {
        Action::NoAction
    }
}

impl ::protobuf::reflect::ProtobufValue for Action {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExtraOp {
    Noop = 0,
    ReadOldValue = 1,
}

impl ::protobuf::ProtobufEnum for ExtraOp {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExtraOp> {
        match value {
            0 => ::std::option::Option::Some(ExtraOp::Noop),
            1 => ::std::option::Option::Some(ExtraOp::ReadOldValue),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExtraOp] = &[
            ExtraOp::Noop,
            ExtraOp::ReadOldValue,
        ];
        values
    }
}

impl ::std::marker::Copy for ExtraOp {
}

impl ::protobuf::PbPrint for ExtraOp {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == ExtraOp::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for ExtraOp {
    fn default() -> Self {
        ExtraOp::Noop
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtraOp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ChecksumAlgorithm {
    Crc64Xor = 0,
}

impl ::protobuf::ProtobufEnum for ChecksumAlgorithm {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChecksumAlgorithm> {
        match value {
            0 => ::std::option::Option::Some(ChecksumAlgorithm::Crc64Xor),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ChecksumAlgorithm] = &[
            ChecksumAlgorithm::Crc64Xor,
        ];
        values
    }
}

impl ::std::marker::Copy for ChecksumAlgorithm {
}

impl ::protobuf::PbPrint for ChecksumAlgorithm {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == ChecksumAlgorithm::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for ChecksumAlgorithm {
    fn default() -> Self {
        ChecksumAlgorithm::Crc64Xor
    }
}

impl ::protobuf::reflect::ProtobufValue for ChecksumAlgorithm {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}
